
Freeartos_Driver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000045fa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000124  00800060  000045fa  0000468e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002fb  00800184  00800184  000047b2  2**0
                  ALLOC
  3 .stab         00005a9c  00000000  00000000  000047b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003813  00000000  00000000  0000a250  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0000da63  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0000dc03  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0000ddf5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  00010200  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00011586  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001275c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001291c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  00012c12  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013580  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 22 17 	jmp	0x2e44	; 0x2e44 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	f5 e4       	ldi	r31, 0x45	; 69
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 38       	cpi	r26, 0x84	; 132
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a4 e8       	ldi	r26, 0x84	; 132
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 37       	cpi	r26, 0x7F	; 127
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b6 13 	call	0x276c	; 0x276c <main>
      8a:	0c 94 fb 22 	jmp	0x45f6	; 0x45f6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 a5 22 	jmp	0x454a	; 0x454a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a9 e7       	ldi	r26, 0x79	; 121
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 c1 22 	jmp	0x4582	; 0x4582 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 b1 22 	jmp	0x4562	; 0x4562 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 b1 22 	jmp	0x4562	; 0x4562 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 a5 22 	jmp	0x454a	; 0x454a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	89 e7       	ldi	r24, 0x79	; 121
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 c1 22 	jmp	0x4582	; 0x4582 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 ad 22 	jmp	0x455a	; 0x455a <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	69 e7       	ldi	r22, 0x79	; 121
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 c9 22 	jmp	0x4592	; 0x4592 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 b1 22 	jmp	0x4562	; 0x4562 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 b1 22 	jmp	0x4562	; 0x4562 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 b1 22 	jmp	0x4562	; 0x4562 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 b5 22 	jmp	0x456a	; 0x456a <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 ad 22 	jmp	0x455a	; 0x455a <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 c9 22 	jmp	0x4592	; 0x4592 <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	ef 57       	subi	r30, 0x7F	; 127
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <PORT_VoidInit>:
#include "PORT_Interface.h"
#include "PORT_REG.h"
#include "PORT_private.h"

void PORT_VoidInit()
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
DDRA_REG=PORTA_DIR;
     e36:	ea e3       	ldi	r30, 0x3A	; 58
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	80 ef       	ldi	r24, 0xF0	; 240
     e3c:	80 83       	st	Z, r24
DDRB_REG=PORTB_DIR;
     e3e:	e7 e3       	ldi	r30, 0x37	; 55
     e40:	f0 e0       	ldi	r31, 0x00	; 0
     e42:	10 82       	st	Z, r1
DDRC_REG=PORTC_DIR;
     e44:	e4 e3       	ldi	r30, 0x34	; 52
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	8f ef       	ldi	r24, 0xFF	; 255
     e4a:	80 83       	st	Z, r24
DDRD_REG=PORTD_DIR;
     e4c:	e1 e3       	ldi	r30, 0x31	; 49
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	8f ef       	ldi	r24, 0xFF	; 255
     e52:	80 83       	st	Z, r24

PORTA_REG_INITIAL=PORTA_INITIAL_VALUE;
     e54:	eb e3       	ldi	r30, 0x3B	; 59
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	8f ef       	ldi	r24, 0xFF	; 255
     e5a:	80 83       	st	Z, r24
PORTB_REG_INITIAL=PORTB_INITIAL_VALUE;
     e5c:	e8 e3       	ldi	r30, 0x38	; 56
     e5e:	f0 e0       	ldi	r31, 0x00	; 0
     e60:	10 82       	st	Z, r1
PORTC_REG_INITIAL=PORTC_INITIAL_VALUE;
     e62:	e5 e3       	ldi	r30, 0x35	; 53
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	10 82       	st	Z, r1
PORTD_REG_INITIAL=PORTD_INITIAL_VALUE;
     e68:	e2 e3       	ldi	r30, 0x32	; 50
     e6a:	f0 e0       	ldi	r31, 0x00	; 0
     e6c:	10 82       	st	Z, r1

}
     e6e:	cf 91       	pop	r28
     e70:	df 91       	pop	r29
     e72:	08 95       	ret

00000e74 <DIO_U8SetPortDir>:
#include "DIO_REG.h"
#include "DIO_Interface.h"


u8 DIO_U8SetPortDir(enum PORTS Copy_u8PortNo,u8  Copy_u8dDir)
{
     e74:	df 93       	push	r29
     e76:	cf 93       	push	r28
     e78:	00 d0       	rcall	.+0      	; 0xe7a <DIO_U8SetPortDir+0x6>
     e7a:	00 d0       	rcall	.+0      	; 0xe7c <DIO_U8SetPortDir+0x8>
     e7c:	0f 92       	push	r0
     e7e:	cd b7       	in	r28, 0x3d	; 61
     e80:	de b7       	in	r29, 0x3e	; 62
     e82:	8a 83       	std	Y+2, r24	; 0x02
     e84:	6b 83       	std	Y+3, r22	; 0x03

	 u8 Local_Status=RT_OK;
     e86:	19 82       	std	Y+1, r1	; 0x01
if(Copy_u8PortNo<0||Copy_u8PortNo>3)
     e88:	8a 81       	ldd	r24, Y+2	; 0x02
     e8a:	84 30       	cpi	r24, 0x04	; 4
     e8c:	18 f0       	brcs	.+6      	; 0xe94 <DIO_U8SetPortDir+0x20>
{
	Local_Status=RT_NOK;
     e8e:	81 e0       	ldi	r24, 0x01	; 1
     e90:	89 83       	std	Y+1, r24	; 0x01
     e92:	32 c0       	rjmp	.+100    	; 0xef8 <DIO_U8SetPortDir+0x84>

}
else
{
	switch(Copy_u8PortNo)
     e94:	8a 81       	ldd	r24, Y+2	; 0x02
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	3d 83       	std	Y+5, r19	; 0x05
     e9c:	2c 83       	std	Y+4, r18	; 0x04
     e9e:	8c 81       	ldd	r24, Y+4	; 0x04
     ea0:	9d 81       	ldd	r25, Y+5	; 0x05
     ea2:	81 30       	cpi	r24, 0x01	; 1
     ea4:	91 05       	cpc	r25, r1
     ea6:	d1 f0       	breq	.+52     	; 0xedc <DIO_U8SetPortDir+0x68>
     ea8:	2c 81       	ldd	r18, Y+4	; 0x04
     eaa:	3d 81       	ldd	r19, Y+5	; 0x05
     eac:	22 30       	cpi	r18, 0x02	; 2
     eae:	31 05       	cpc	r19, r1
     eb0:	2c f4       	brge	.+10     	; 0xebc <DIO_U8SetPortDir+0x48>
     eb2:	8c 81       	ldd	r24, Y+4	; 0x04
     eb4:	9d 81       	ldd	r25, Y+5	; 0x05
     eb6:	00 97       	sbiw	r24, 0x00	; 0
     eb8:	61 f0       	breq	.+24     	; 0xed2 <DIO_U8SetPortDir+0x5e>
     eba:	1e c0       	rjmp	.+60     	; 0xef8 <DIO_U8SetPortDir+0x84>
     ebc:	2c 81       	ldd	r18, Y+4	; 0x04
     ebe:	3d 81       	ldd	r19, Y+5	; 0x05
     ec0:	22 30       	cpi	r18, 0x02	; 2
     ec2:	31 05       	cpc	r19, r1
     ec4:	81 f0       	breq	.+32     	; 0xee6 <DIO_U8SetPortDir+0x72>
     ec6:	8c 81       	ldd	r24, Y+4	; 0x04
     ec8:	9d 81       	ldd	r25, Y+5	; 0x05
     eca:	83 30       	cpi	r24, 0x03	; 3
     ecc:	91 05       	cpc	r25, r1
     ece:	81 f0       	breq	.+32     	; 0xef0 <DIO_U8SetPortDir+0x7c>
     ed0:	13 c0       	rjmp	.+38     	; 0xef8 <DIO_U8SetPortDir+0x84>
	{
	case 0:{DDRA_REG=Copy_u8dDir; break;}
     ed2:	ea e3       	ldi	r30, 0x3A	; 58
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	8b 81       	ldd	r24, Y+3	; 0x03
     ed8:	80 83       	st	Z, r24
     eda:	0e c0       	rjmp	.+28     	; 0xef8 <DIO_U8SetPortDir+0x84>
	case 1:{DDRB_REG=Copy_u8dDir; break;}
     edc:	e7 e3       	ldi	r30, 0x37	; 55
     ede:	f0 e0       	ldi	r31, 0x00	; 0
     ee0:	8b 81       	ldd	r24, Y+3	; 0x03
     ee2:	80 83       	st	Z, r24
     ee4:	09 c0       	rjmp	.+18     	; 0xef8 <DIO_U8SetPortDir+0x84>
	case 2:{DDRC_REG=Copy_u8dDir; break;}
     ee6:	e4 e3       	ldi	r30, 0x34	; 52
     ee8:	f0 e0       	ldi	r31, 0x00	; 0
     eea:	8b 81       	ldd	r24, Y+3	; 0x03
     eec:	80 83       	st	Z, r24
     eee:	04 c0       	rjmp	.+8      	; 0xef8 <DIO_U8SetPortDir+0x84>
	case 3:{DDRD_REG=Copy_u8dDir; break;}
     ef0:	e1 e3       	ldi	r30, 0x31	; 49
     ef2:	f0 e0       	ldi	r31, 0x00	; 0
     ef4:	8b 81       	ldd	r24, Y+3	; 0x03
     ef6:	80 83       	st	Z, r24
	}
}
return Local_Status;
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
}
     efa:	0f 90       	pop	r0
     efc:	0f 90       	pop	r0
     efe:	0f 90       	pop	r0
     f00:	0f 90       	pop	r0
     f02:	0f 90       	pop	r0
     f04:	cf 91       	pop	r28
     f06:	df 91       	pop	r29
     f08:	08 95       	ret

00000f0a <DIO_U8SetPortVal>:

u8 DIO_U8SetPortVal(enum PORTS Copy_u8PortNo , u8 Copy_Val)
{
     f0a:	df 93       	push	r29
     f0c:	cf 93       	push	r28
     f0e:	00 d0       	rcall	.+0      	; 0xf10 <DIO_U8SetPortVal+0x6>
     f10:	00 d0       	rcall	.+0      	; 0xf12 <DIO_U8SetPortVal+0x8>
     f12:	0f 92       	push	r0
     f14:	cd b7       	in	r28, 0x3d	; 61
     f16:	de b7       	in	r29, 0x3e	; 62
     f18:	8a 83       	std	Y+2, r24	; 0x02
     f1a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_Status=RT_OK;
     f1c:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8PortNo <0||Copy_u8PortNo>3)
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	84 30       	cpi	r24, 0x04	; 4
     f22:	18 f0       	brcs	.+6      	; 0xf2a <DIO_U8SetPortVal+0x20>
	{
		 Local_Status=RT_NOK;
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	89 83       	std	Y+1, r24	; 0x01
     f28:	32 c0       	rjmp	.+100    	; 0xf8e <DIO_U8SetPortVal+0x84>

	}
	else
	{
		switch(Copy_u8PortNo)
     f2a:	8a 81       	ldd	r24, Y+2	; 0x02
     f2c:	28 2f       	mov	r18, r24
     f2e:	30 e0       	ldi	r19, 0x00	; 0
     f30:	3d 83       	std	Y+5, r19	; 0x05
     f32:	2c 83       	std	Y+4, r18	; 0x04
     f34:	8c 81       	ldd	r24, Y+4	; 0x04
     f36:	9d 81       	ldd	r25, Y+5	; 0x05
     f38:	81 30       	cpi	r24, 0x01	; 1
     f3a:	91 05       	cpc	r25, r1
     f3c:	d1 f0       	breq	.+52     	; 0xf72 <DIO_U8SetPortVal+0x68>
     f3e:	2c 81       	ldd	r18, Y+4	; 0x04
     f40:	3d 81       	ldd	r19, Y+5	; 0x05
     f42:	22 30       	cpi	r18, 0x02	; 2
     f44:	31 05       	cpc	r19, r1
     f46:	2c f4       	brge	.+10     	; 0xf52 <DIO_U8SetPortVal+0x48>
     f48:	8c 81       	ldd	r24, Y+4	; 0x04
     f4a:	9d 81       	ldd	r25, Y+5	; 0x05
     f4c:	00 97       	sbiw	r24, 0x00	; 0
     f4e:	61 f0       	breq	.+24     	; 0xf68 <DIO_U8SetPortVal+0x5e>
     f50:	1e c0       	rjmp	.+60     	; 0xf8e <DIO_U8SetPortVal+0x84>
     f52:	2c 81       	ldd	r18, Y+4	; 0x04
     f54:	3d 81       	ldd	r19, Y+5	; 0x05
     f56:	22 30       	cpi	r18, 0x02	; 2
     f58:	31 05       	cpc	r19, r1
     f5a:	81 f0       	breq	.+32     	; 0xf7c <DIO_U8SetPortVal+0x72>
     f5c:	8c 81       	ldd	r24, Y+4	; 0x04
     f5e:	9d 81       	ldd	r25, Y+5	; 0x05
     f60:	83 30       	cpi	r24, 0x03	; 3
     f62:	91 05       	cpc	r25, r1
     f64:	81 f0       	breq	.+32     	; 0xf86 <DIO_U8SetPortVal+0x7c>
     f66:	13 c0       	rjmp	.+38     	; 0xf8e <DIO_U8SetPortVal+0x84>
		{
		case 0:{PORTA_REG=Copy_Val; break;}
     f68:	eb e3       	ldi	r30, 0x3B	; 59
     f6a:	f0 e0       	ldi	r31, 0x00	; 0
     f6c:	8b 81       	ldd	r24, Y+3	; 0x03
     f6e:	80 83       	st	Z, r24
     f70:	0e c0       	rjmp	.+28     	; 0xf8e <DIO_U8SetPortVal+0x84>
		case 1:{PORTB_REG=Copy_Val; break;}
     f72:	e8 e3       	ldi	r30, 0x38	; 56
     f74:	f0 e0       	ldi	r31, 0x00	; 0
     f76:	8b 81       	ldd	r24, Y+3	; 0x03
     f78:	80 83       	st	Z, r24
     f7a:	09 c0       	rjmp	.+18     	; 0xf8e <DIO_U8SetPortVal+0x84>
		case 2:{PORTC_REG=Copy_Val; break;}
     f7c:	e5 e3       	ldi	r30, 0x35	; 53
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	8b 81       	ldd	r24, Y+3	; 0x03
     f82:	80 83       	st	Z, r24
     f84:	04 c0       	rjmp	.+8      	; 0xf8e <DIO_U8SetPortVal+0x84>
		case 3:{PORTD_REG=Copy_Val; break;}
     f86:	e2 e3       	ldi	r30, 0x32	; 50
     f88:	f0 e0       	ldi	r31, 0x00	; 0
     f8a:	8b 81       	ldd	r24, Y+3	; 0x03
     f8c:	80 83       	st	Z, r24
		}
	}
	return Local_Status;
     f8e:	89 81       	ldd	r24, Y+1	; 0x01

}
     f90:	0f 90       	pop	r0
     f92:	0f 90       	pop	r0
     f94:	0f 90       	pop	r0
     f96:	0f 90       	pop	r0
     f98:	0f 90       	pop	r0
     f9a:	cf 91       	pop	r28
     f9c:	df 91       	pop	r29
     f9e:	08 95       	ret

00000fa0 <DIO_U8GetPortVal>:

u8 DIO_U8GetPortVal(enum PORTS Copy_u8PortNo, u8* u8_Val)
{
     fa0:	df 93       	push	r29
     fa2:	cf 93       	push	r28
     fa4:	00 d0       	rcall	.+0      	; 0xfa6 <DIO_U8GetPortVal+0x6>
     fa6:	00 d0       	rcall	.+0      	; 0xfa8 <DIO_U8GetPortVal+0x8>
     fa8:	00 d0       	rcall	.+0      	; 0xfaa <DIO_U8GetPortVal+0xa>
     faa:	cd b7       	in	r28, 0x3d	; 61
     fac:	de b7       	in	r29, 0x3e	; 62
     fae:	8a 83       	std	Y+2, r24	; 0x02
     fb0:	7c 83       	std	Y+4, r23	; 0x04
     fb2:	6b 83       	std	Y+3, r22	; 0x03

	u8 Local_Status=RT_OK;
     fb4:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8PortNo<0|| Copy_u8PortNo>3)
     fb6:	8a 81       	ldd	r24, Y+2	; 0x02
     fb8:	84 30       	cpi	r24, 0x04	; 4
     fba:	18 f0       	brcs	.+6      	; 0xfc2 <DIO_U8GetPortVal+0x22>
	{
		Local_Status=RT_NOK;
     fbc:	81 e0       	ldi	r24, 0x01	; 1
     fbe:	89 83       	std	Y+1, r24	; 0x01
     fc0:	3a c0       	rjmp	.+116    	; 0x1036 <DIO_U8GetPortVal+0x96>

	}
	else
	{
		switch(Copy_u8PortNo)
     fc2:	8a 81       	ldd	r24, Y+2	; 0x02
     fc4:	28 2f       	mov	r18, r24
     fc6:	30 e0       	ldi	r19, 0x00	; 0
     fc8:	3e 83       	std	Y+6, r19	; 0x06
     fca:	2d 83       	std	Y+5, r18	; 0x05
     fcc:	8d 81       	ldd	r24, Y+5	; 0x05
     fce:	9e 81       	ldd	r25, Y+6	; 0x06
     fd0:	81 30       	cpi	r24, 0x01	; 1
     fd2:	91 05       	cpc	r25, r1
     fd4:	e1 f0       	breq	.+56     	; 0x100e <DIO_U8GetPortVal+0x6e>
     fd6:	2d 81       	ldd	r18, Y+5	; 0x05
     fd8:	3e 81       	ldd	r19, Y+6	; 0x06
     fda:	22 30       	cpi	r18, 0x02	; 2
     fdc:	31 05       	cpc	r19, r1
     fde:	2c f4       	brge	.+10     	; 0xfea <DIO_U8GetPortVal+0x4a>
     fe0:	8d 81       	ldd	r24, Y+5	; 0x05
     fe2:	9e 81       	ldd	r25, Y+6	; 0x06
     fe4:	00 97       	sbiw	r24, 0x00	; 0
     fe6:	61 f0       	breq	.+24     	; 0x1000 <DIO_U8GetPortVal+0x60>
     fe8:	26 c0       	rjmp	.+76     	; 0x1036 <DIO_U8GetPortVal+0x96>
     fea:	2d 81       	ldd	r18, Y+5	; 0x05
     fec:	3e 81       	ldd	r19, Y+6	; 0x06
     fee:	22 30       	cpi	r18, 0x02	; 2
     ff0:	31 05       	cpc	r19, r1
     ff2:	a1 f0       	breq	.+40     	; 0x101c <DIO_U8GetPortVal+0x7c>
     ff4:	8d 81       	ldd	r24, Y+5	; 0x05
     ff6:	9e 81       	ldd	r25, Y+6	; 0x06
     ff8:	83 30       	cpi	r24, 0x03	; 3
     ffa:	91 05       	cpc	r25, r1
     ffc:	b1 f0       	breq	.+44     	; 0x102a <DIO_U8GetPortVal+0x8a>
     ffe:	1b c0       	rjmp	.+54     	; 0x1036 <DIO_U8GetPortVal+0x96>
		{
		case 0:{*u8_Val=PINA_REG; break;}
    1000:	e9 e3       	ldi	r30, 0x39	; 57
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	80 81       	ld	r24, Z
    1006:	eb 81       	ldd	r30, Y+3	; 0x03
    1008:	fc 81       	ldd	r31, Y+4	; 0x04
    100a:	80 83       	st	Z, r24
    100c:	14 c0       	rjmp	.+40     	; 0x1036 <DIO_U8GetPortVal+0x96>
		case 1:{*u8_Val=PINB_REG; break;}
    100e:	e6 e3       	ldi	r30, 0x36	; 54
    1010:	f0 e0       	ldi	r31, 0x00	; 0
    1012:	80 81       	ld	r24, Z
    1014:	eb 81       	ldd	r30, Y+3	; 0x03
    1016:	fc 81       	ldd	r31, Y+4	; 0x04
    1018:	80 83       	st	Z, r24
    101a:	0d c0       	rjmp	.+26     	; 0x1036 <DIO_U8GetPortVal+0x96>
		case 2:{*u8_Val=PINC_REG; break;}
    101c:	e3 e3       	ldi	r30, 0x33	; 51
    101e:	f0 e0       	ldi	r31, 0x00	; 0
    1020:	80 81       	ld	r24, Z
    1022:	eb 81       	ldd	r30, Y+3	; 0x03
    1024:	fc 81       	ldd	r31, Y+4	; 0x04
    1026:	80 83       	st	Z, r24
    1028:	06 c0       	rjmp	.+12     	; 0x1036 <DIO_U8GetPortVal+0x96>
		case 3:{*u8_Val=PIND_REG; break;}
    102a:	e0 e3       	ldi	r30, 0x30	; 48
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	80 81       	ld	r24, Z
    1030:	eb 81       	ldd	r30, Y+3	; 0x03
    1032:	fc 81       	ldd	r31, Y+4	; 0x04
    1034:	80 83       	st	Z, r24
		}
	}
	return Local_Status;
    1036:	89 81       	ldd	r24, Y+1	; 0x01

}
    1038:	26 96       	adiw	r28, 0x06	; 6
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	f8 94       	cli
    103e:	de bf       	out	0x3e, r29	; 62
    1040:	0f be       	out	0x3f, r0	; 63
    1042:	cd bf       	out	0x3d, r28	; 61
    1044:	cf 91       	pop	r28
    1046:	df 91       	pop	r29
    1048:	08 95       	ret

0000104a <DIO_U8SetPinDir>:

u8 DIO_U8SetPinDir(enum PORTS Copy_u8PortNo , enum PINS Copy_u8PinNo,u8 Copy_u8Dir)
{	u8 Local_Status=RT_OK;
    104a:	df 93       	push	r29
    104c:	cf 93       	push	r28
    104e:	cd b7       	in	r28, 0x3d	; 61
    1050:	de b7       	in	r29, 0x3e	; 62
    1052:	28 97       	sbiw	r28, 0x08	; 8
    1054:	0f b6       	in	r0, 0x3f	; 63
    1056:	f8 94       	cli
    1058:	de bf       	out	0x3e, r29	; 62
    105a:	0f be       	out	0x3f, r0	; 63
    105c:	cd bf       	out	0x3d, r28	; 61
    105e:	8a 83       	std	Y+2, r24	; 0x02
    1060:	6b 83       	std	Y+3, r22	; 0x03
    1062:	4c 83       	std	Y+4, r20	; 0x04
    1064:	19 82       	std	Y+1, r1	; 0x01
if(Copy_u8PortNo>=0||Copy_u8PortNo<=3)
{
	if(Copy_u8PinNo>=0||Copy_u8PinNo<=7)
	{
		if(Copy_u8Dir == HIGH)
    1066:	8c 81       	ldd	r24, Y+4	; 0x04
    1068:	81 30       	cpi	r24, 0x01	; 1
    106a:	09 f0       	breq	.+2      	; 0x106e <DIO_U8SetPinDir+0x24>
    106c:	6f c0       	rjmp	.+222    	; 0x114c <DIO_U8SetPinDir+0x102>
		{
			switch(Copy_u8PortNo)
    106e:	8a 81       	ldd	r24, Y+2	; 0x02
    1070:	28 2f       	mov	r18, r24
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	38 87       	std	Y+8, r19	; 0x08
    1076:	2f 83       	std	Y+7, r18	; 0x07
    1078:	8f 81       	ldd	r24, Y+7	; 0x07
    107a:	98 85       	ldd	r25, Y+8	; 0x08
    107c:	81 30       	cpi	r24, 0x01	; 1
    107e:	91 05       	cpc	r25, r1
    1080:	49 f1       	breq	.+82     	; 0x10d4 <DIO_U8SetPinDir+0x8a>
    1082:	2f 81       	ldd	r18, Y+7	; 0x07
    1084:	38 85       	ldd	r19, Y+8	; 0x08
    1086:	22 30       	cpi	r18, 0x02	; 2
    1088:	31 05       	cpc	r19, r1
    108a:	2c f4       	brge	.+10     	; 0x1096 <DIO_U8SetPinDir+0x4c>
    108c:	8f 81       	ldd	r24, Y+7	; 0x07
    108e:	98 85       	ldd	r25, Y+8	; 0x08
    1090:	00 97       	sbiw	r24, 0x00	; 0
    1092:	61 f0       	breq	.+24     	; 0x10ac <DIO_U8SetPinDir+0x62>
    1094:	d5 c0       	rjmp	.+426    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
    1096:	2f 81       	ldd	r18, Y+7	; 0x07
    1098:	38 85       	ldd	r19, Y+8	; 0x08
    109a:	22 30       	cpi	r18, 0x02	; 2
    109c:	31 05       	cpc	r19, r1
    109e:	71 f1       	breq	.+92     	; 0x10fc <DIO_U8SetPinDir+0xb2>
    10a0:	8f 81       	ldd	r24, Y+7	; 0x07
    10a2:	98 85       	ldd	r25, Y+8	; 0x08
    10a4:	83 30       	cpi	r24, 0x03	; 3
    10a6:	91 05       	cpc	r25, r1
    10a8:	e9 f1       	breq	.+122    	; 0x1124 <DIO_U8SetPinDir+0xda>
    10aa:	ca c0       	rjmp	.+404    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
			{
			case 0:
			{
				SetBit(DDRA_REG,Copy_u8PinNo);
    10ac:	aa e3       	ldi	r26, 0x3A	; 58
    10ae:	b0 e0       	ldi	r27, 0x00	; 0
    10b0:	ea e3       	ldi	r30, 0x3A	; 58
    10b2:	f0 e0       	ldi	r31, 0x00	; 0
    10b4:	80 81       	ld	r24, Z
    10b6:	48 2f       	mov	r20, r24
    10b8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ba:	28 2f       	mov	r18, r24
    10bc:	30 e0       	ldi	r19, 0x00	; 0
    10be:	81 e0       	ldi	r24, 0x01	; 1
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	02 2e       	mov	r0, r18
    10c4:	02 c0       	rjmp	.+4      	; 0x10ca <DIO_U8SetPinDir+0x80>
    10c6:	88 0f       	add	r24, r24
    10c8:	99 1f       	adc	r25, r25
    10ca:	0a 94       	dec	r0
    10cc:	e2 f7       	brpl	.-8      	; 0x10c6 <DIO_U8SetPinDir+0x7c>
    10ce:	84 2b       	or	r24, r20
    10d0:	8c 93       	st	X, r24
    10d2:	b6 c0       	rjmp	.+364    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
				break;
			}
			case 1:
			{
				SetBit(DDRB_REG,Copy_u8PinNo);
    10d4:	a7 e3       	ldi	r26, 0x37	; 55
    10d6:	b0 e0       	ldi	r27, 0x00	; 0
    10d8:	e7 e3       	ldi	r30, 0x37	; 55
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	80 81       	ld	r24, Z
    10de:	48 2f       	mov	r20, r24
    10e0:	8b 81       	ldd	r24, Y+3	; 0x03
    10e2:	28 2f       	mov	r18, r24
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	02 2e       	mov	r0, r18
    10ec:	02 c0       	rjmp	.+4      	; 0x10f2 <DIO_U8SetPinDir+0xa8>
    10ee:	88 0f       	add	r24, r24
    10f0:	99 1f       	adc	r25, r25
    10f2:	0a 94       	dec	r0
    10f4:	e2 f7       	brpl	.-8      	; 0x10ee <DIO_U8SetPinDir+0xa4>
    10f6:	84 2b       	or	r24, r20
    10f8:	8c 93       	st	X, r24
    10fa:	a2 c0       	rjmp	.+324    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
				break;
			}
			case 2:
			{
				SetBit(DDRC_REG,Copy_u8PinNo);
    10fc:	a4 e3       	ldi	r26, 0x34	; 52
    10fe:	b0 e0       	ldi	r27, 0x00	; 0
    1100:	e4 e3       	ldi	r30, 0x34	; 52
    1102:	f0 e0       	ldi	r31, 0x00	; 0
    1104:	80 81       	ld	r24, Z
    1106:	48 2f       	mov	r20, r24
    1108:	8b 81       	ldd	r24, Y+3	; 0x03
    110a:	28 2f       	mov	r18, r24
    110c:	30 e0       	ldi	r19, 0x00	; 0
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	02 2e       	mov	r0, r18
    1114:	02 c0       	rjmp	.+4      	; 0x111a <DIO_U8SetPinDir+0xd0>
    1116:	88 0f       	add	r24, r24
    1118:	99 1f       	adc	r25, r25
    111a:	0a 94       	dec	r0
    111c:	e2 f7       	brpl	.-8      	; 0x1116 <DIO_U8SetPinDir+0xcc>
    111e:	84 2b       	or	r24, r20
    1120:	8c 93       	st	X, r24
    1122:	8e c0       	rjmp	.+284    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
				break;
			}
			case 3:
			{
				SetBit(DDRD_REG,Copy_u8PinNo);
    1124:	a1 e3       	ldi	r26, 0x31	; 49
    1126:	b0 e0       	ldi	r27, 0x00	; 0
    1128:	e1 e3       	ldi	r30, 0x31	; 49
    112a:	f0 e0       	ldi	r31, 0x00	; 0
    112c:	80 81       	ld	r24, Z
    112e:	48 2f       	mov	r20, r24
    1130:	8b 81       	ldd	r24, Y+3	; 0x03
    1132:	28 2f       	mov	r18, r24
    1134:	30 e0       	ldi	r19, 0x00	; 0
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	90 e0       	ldi	r25, 0x00	; 0
    113a:	02 2e       	mov	r0, r18
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <DIO_U8SetPinDir+0xf8>
    113e:	88 0f       	add	r24, r24
    1140:	99 1f       	adc	r25, r25
    1142:	0a 94       	dec	r0
    1144:	e2 f7       	brpl	.-8      	; 0x113e <DIO_U8SetPinDir+0xf4>
    1146:	84 2b       	or	r24, r20
    1148:	8c 93       	st	X, r24
    114a:	7a c0       	rjmp	.+244    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
				break;
			}

			}
		}
		else if(Copy_u8Dir==LOW)
    114c:	8c 81       	ldd	r24, Y+4	; 0x04
    114e:	88 23       	and	r24, r24
    1150:	09 f0       	breq	.+2      	; 0x1154 <DIO_U8SetPinDir+0x10a>
    1152:	74 c0       	rjmp	.+232    	; 0x123c <DIO_U8SetPinDir+0x1f2>
		{
			switch(Copy_u8PortNo)
    1154:	8a 81       	ldd	r24, Y+2	; 0x02
    1156:	28 2f       	mov	r18, r24
    1158:	30 e0       	ldi	r19, 0x00	; 0
    115a:	3e 83       	std	Y+6, r19	; 0x06
    115c:	2d 83       	std	Y+5, r18	; 0x05
    115e:	8d 81       	ldd	r24, Y+5	; 0x05
    1160:	9e 81       	ldd	r25, Y+6	; 0x06
    1162:	81 30       	cpi	r24, 0x01	; 1
    1164:	91 05       	cpc	r25, r1
    1166:	59 f1       	breq	.+86     	; 0x11be <DIO_U8SetPinDir+0x174>
    1168:	2d 81       	ldd	r18, Y+5	; 0x05
    116a:	3e 81       	ldd	r19, Y+6	; 0x06
    116c:	22 30       	cpi	r18, 0x02	; 2
    116e:	31 05       	cpc	r19, r1
    1170:	2c f4       	brge	.+10     	; 0x117c <DIO_U8SetPinDir+0x132>
    1172:	8d 81       	ldd	r24, Y+5	; 0x05
    1174:	9e 81       	ldd	r25, Y+6	; 0x06
    1176:	00 97       	sbiw	r24, 0x00	; 0
    1178:	69 f0       	breq	.+26     	; 0x1194 <DIO_U8SetPinDir+0x14a>
    117a:	62 c0       	rjmp	.+196    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
    117c:	2d 81       	ldd	r18, Y+5	; 0x05
    117e:	3e 81       	ldd	r19, Y+6	; 0x06
    1180:	22 30       	cpi	r18, 0x02	; 2
    1182:	31 05       	cpc	r19, r1
    1184:	89 f1       	breq	.+98     	; 0x11e8 <DIO_U8SetPinDir+0x19e>
    1186:	8d 81       	ldd	r24, Y+5	; 0x05
    1188:	9e 81       	ldd	r25, Y+6	; 0x06
    118a:	83 30       	cpi	r24, 0x03	; 3
    118c:	91 05       	cpc	r25, r1
    118e:	09 f4       	brne	.+2      	; 0x1192 <DIO_U8SetPinDir+0x148>
    1190:	40 c0       	rjmp	.+128    	; 0x1212 <DIO_U8SetPinDir+0x1c8>
    1192:	56 c0       	rjmp	.+172    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
			{
				case 0:
				{
					ClearBit(DDRA_REG,Copy_u8PinNo);
    1194:	aa e3       	ldi	r26, 0x3A	; 58
    1196:	b0 e0       	ldi	r27, 0x00	; 0
    1198:	ea e3       	ldi	r30, 0x3A	; 58
    119a:	f0 e0       	ldi	r31, 0x00	; 0
    119c:	80 81       	ld	r24, Z
    119e:	48 2f       	mov	r20, r24
    11a0:	8b 81       	ldd	r24, Y+3	; 0x03
    11a2:	28 2f       	mov	r18, r24
    11a4:	30 e0       	ldi	r19, 0x00	; 0
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	02 2e       	mov	r0, r18
    11ac:	02 c0       	rjmp	.+4      	; 0x11b2 <DIO_U8SetPinDir+0x168>
    11ae:	88 0f       	add	r24, r24
    11b0:	99 1f       	adc	r25, r25
    11b2:	0a 94       	dec	r0
    11b4:	e2 f7       	brpl	.-8      	; 0x11ae <DIO_U8SetPinDir+0x164>
    11b6:	80 95       	com	r24
    11b8:	84 23       	and	r24, r20
    11ba:	8c 93       	st	X, r24
    11bc:	41 c0       	rjmp	.+130    	; 0x1240 <DIO_U8SetPinDir+0x1f6>
					break;
				}
				case 1:
				{
					ClearBit(DDRB_REG,Copy_u8PinNo);
    11be:	a7 e3       	ldi	r26, 0x37	; 55
    11c0:	b0 e0       	ldi	r27, 0x00	; 0
    11c2:	e7 e3       	ldi	r30, 0x37	; 55
    11c4:	f0 e0       	ldi	r31, 0x00	; 0
    11c6:	80 81       	ld	r24, Z
    11c8:	48 2f       	mov	r20, r24
    11ca:	8b 81       	ldd	r24, Y+3	; 0x03
    11cc:	28 2f       	mov	r18, r24
    11ce:	30 e0       	ldi	r19, 0x00	; 0
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	90 e0       	ldi	r25, 0x00	; 0
    11d4:	02 2e       	mov	r0, r18
    11d6:	02 c0       	rjmp	.+4      	; 0x11dc <DIO_U8SetPinDir+0x192>
    11d8:	88 0f       	add	r24, r24
    11da:	99 1f       	adc	r25, r25
    11dc:	0a 94       	dec	r0
    11de:	e2 f7       	brpl	.-8      	; 0x11d8 <DIO_U8SetPinDir+0x18e>
    11e0:	80 95       	com	r24
    11e2:	84 23       	and	r24, r20
    11e4:	8c 93       	st	X, r24
    11e6:	2c c0       	rjmp	.+88     	; 0x1240 <DIO_U8SetPinDir+0x1f6>
					break;
				}
				case 2:
				{
					ClearBit(DDRC_REG,Copy_u8PinNo);
    11e8:	a4 e3       	ldi	r26, 0x34	; 52
    11ea:	b0 e0       	ldi	r27, 0x00	; 0
    11ec:	e4 e3       	ldi	r30, 0x34	; 52
    11ee:	f0 e0       	ldi	r31, 0x00	; 0
    11f0:	80 81       	ld	r24, Z
    11f2:	48 2f       	mov	r20, r24
    11f4:	8b 81       	ldd	r24, Y+3	; 0x03
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	02 2e       	mov	r0, r18
    1200:	02 c0       	rjmp	.+4      	; 0x1206 <DIO_U8SetPinDir+0x1bc>
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	0a 94       	dec	r0
    1208:	e2 f7       	brpl	.-8      	; 0x1202 <DIO_U8SetPinDir+0x1b8>
    120a:	80 95       	com	r24
    120c:	84 23       	and	r24, r20
    120e:	8c 93       	st	X, r24
    1210:	17 c0       	rjmp	.+46     	; 0x1240 <DIO_U8SetPinDir+0x1f6>
					break;
				}
				case 3:
				{
					ClearBit(DDRD_REG,Copy_u8PinNo);
    1212:	a1 e3       	ldi	r26, 0x31	; 49
    1214:	b0 e0       	ldi	r27, 0x00	; 0
    1216:	e1 e3       	ldi	r30, 0x31	; 49
    1218:	f0 e0       	ldi	r31, 0x00	; 0
    121a:	80 81       	ld	r24, Z
    121c:	48 2f       	mov	r20, r24
    121e:	8b 81       	ldd	r24, Y+3	; 0x03
    1220:	28 2f       	mov	r18, r24
    1222:	30 e0       	ldi	r19, 0x00	; 0
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	02 2e       	mov	r0, r18
    122a:	02 c0       	rjmp	.+4      	; 0x1230 <DIO_U8SetPinDir+0x1e6>
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	0a 94       	dec	r0
    1232:	e2 f7       	brpl	.-8      	; 0x122c <DIO_U8SetPinDir+0x1e2>
    1234:	80 95       	com	r24
    1236:	84 23       	and	r24, r20
    1238:	8c 93       	st	X, r24
    123a:	02 c0       	rjmp	.+4      	; 0x1240 <DIO_U8SetPinDir+0x1f6>

			}
		}
		else
		{
			Local_Status=RT_NOK;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	89 83       	std	Y+1, r24	; 0x01
{
	Local_Status=RT_NOK;
}


	return Local_Status;
    1240:	89 81       	ldd	r24, Y+1	; 0x01

}
    1242:	28 96       	adiw	r28, 0x08	; 8
    1244:	0f b6       	in	r0, 0x3f	; 63
    1246:	f8 94       	cli
    1248:	de bf       	out	0x3e, r29	; 62
    124a:	0f be       	out	0x3f, r0	; 63
    124c:	cd bf       	out	0x3d, r28	; 61
    124e:	cf 91       	pop	r28
    1250:	df 91       	pop	r29
    1252:	08 95       	ret

00001254 <DIO_U8SetPinVal>:

u8 DIO_U8SetPinVal(enum PORTS Copy_u8PortNo,enum PINS  Copy_u8PinNo,u8 Copy_Val)

{
    1254:	df 93       	push	r29
    1256:	cf 93       	push	r28
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
    125c:	28 97       	sbiw	r28, 0x08	; 8
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	de bf       	out	0x3e, r29	; 62
    1264:	0f be       	out	0x3f, r0	; 63
    1266:	cd bf       	out	0x3d, r28	; 61
    1268:	8a 83       	std	Y+2, r24	; 0x02
    126a:	6b 83       	std	Y+3, r22	; 0x03
    126c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_Status=RT_OK;
    126e:	19 82       	std	Y+1, r1	; 0x01
if(Copy_u8PortNo>=0||Copy_u8PortNo<=3)
{
	if(Copy_u8PinNo>=0||Copy_u8PinNo<=7)
	{
		if(Copy_Val == HIGH)
    1270:	8c 81       	ldd	r24, Y+4	; 0x04
    1272:	81 30       	cpi	r24, 0x01	; 1
    1274:	09 f0       	breq	.+2      	; 0x1278 <DIO_U8SetPinVal+0x24>
    1276:	6f c0       	rjmp	.+222    	; 0x1356 <DIO_U8SetPinVal+0x102>
		{
			switch(Copy_u8PortNo)
    1278:	8a 81       	ldd	r24, Y+2	; 0x02
    127a:	28 2f       	mov	r18, r24
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	38 87       	std	Y+8, r19	; 0x08
    1280:	2f 83       	std	Y+7, r18	; 0x07
    1282:	8f 81       	ldd	r24, Y+7	; 0x07
    1284:	98 85       	ldd	r25, Y+8	; 0x08
    1286:	81 30       	cpi	r24, 0x01	; 1
    1288:	91 05       	cpc	r25, r1
    128a:	49 f1       	breq	.+82     	; 0x12de <DIO_U8SetPinVal+0x8a>
    128c:	2f 81       	ldd	r18, Y+7	; 0x07
    128e:	38 85       	ldd	r19, Y+8	; 0x08
    1290:	22 30       	cpi	r18, 0x02	; 2
    1292:	31 05       	cpc	r19, r1
    1294:	2c f4       	brge	.+10     	; 0x12a0 <DIO_U8SetPinVal+0x4c>
    1296:	8f 81       	ldd	r24, Y+7	; 0x07
    1298:	98 85       	ldd	r25, Y+8	; 0x08
    129a:	00 97       	sbiw	r24, 0x00	; 0
    129c:	61 f0       	breq	.+24     	; 0x12b6 <DIO_U8SetPinVal+0x62>
    129e:	d5 c0       	rjmp	.+426    	; 0x144a <DIO_U8SetPinVal+0x1f6>
    12a0:	2f 81       	ldd	r18, Y+7	; 0x07
    12a2:	38 85       	ldd	r19, Y+8	; 0x08
    12a4:	22 30       	cpi	r18, 0x02	; 2
    12a6:	31 05       	cpc	r19, r1
    12a8:	71 f1       	breq	.+92     	; 0x1306 <DIO_U8SetPinVal+0xb2>
    12aa:	8f 81       	ldd	r24, Y+7	; 0x07
    12ac:	98 85       	ldd	r25, Y+8	; 0x08
    12ae:	83 30       	cpi	r24, 0x03	; 3
    12b0:	91 05       	cpc	r25, r1
    12b2:	e9 f1       	breq	.+122    	; 0x132e <DIO_U8SetPinVal+0xda>
    12b4:	ca c0       	rjmp	.+404    	; 0x144a <DIO_U8SetPinVal+0x1f6>
			{
			case 0:
			{
				SetBit(PORTA_REG,Copy_u8PinNo);
    12b6:	ab e3       	ldi	r26, 0x3B	; 59
    12b8:	b0 e0       	ldi	r27, 0x00	; 0
    12ba:	eb e3       	ldi	r30, 0x3B	; 59
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	80 81       	ld	r24, Z
    12c0:	48 2f       	mov	r20, r24
    12c2:	8b 81       	ldd	r24, Y+3	; 0x03
    12c4:	28 2f       	mov	r18, r24
    12c6:	30 e0       	ldi	r19, 0x00	; 0
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	02 2e       	mov	r0, r18
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <DIO_U8SetPinVal+0x80>
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	0a 94       	dec	r0
    12d6:	e2 f7       	brpl	.-8      	; 0x12d0 <DIO_U8SetPinVal+0x7c>
    12d8:	84 2b       	or	r24, r20
    12da:	8c 93       	st	X, r24
    12dc:	b6 c0       	rjmp	.+364    	; 0x144a <DIO_U8SetPinVal+0x1f6>
				break;
			}
			case 1:
			{
				SetBit(PORTB_REG,Copy_u8PinNo);
    12de:	a8 e3       	ldi	r26, 0x38	; 56
    12e0:	b0 e0       	ldi	r27, 0x00	; 0
    12e2:	e8 e3       	ldi	r30, 0x38	; 56
    12e4:	f0 e0       	ldi	r31, 0x00	; 0
    12e6:	80 81       	ld	r24, Z
    12e8:	48 2f       	mov	r20, r24
    12ea:	8b 81       	ldd	r24, Y+3	; 0x03
    12ec:	28 2f       	mov	r18, r24
    12ee:	30 e0       	ldi	r19, 0x00	; 0
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	02 2e       	mov	r0, r18
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <DIO_U8SetPinVal+0xa8>
    12f8:	88 0f       	add	r24, r24
    12fa:	99 1f       	adc	r25, r25
    12fc:	0a 94       	dec	r0
    12fe:	e2 f7       	brpl	.-8      	; 0x12f8 <DIO_U8SetPinVal+0xa4>
    1300:	84 2b       	or	r24, r20
    1302:	8c 93       	st	X, r24
    1304:	a2 c0       	rjmp	.+324    	; 0x144a <DIO_U8SetPinVal+0x1f6>
				break;
			}
			case 2:
			{
				SetBit(PORTC_REG,Copy_u8PinNo);
    1306:	a5 e3       	ldi	r26, 0x35	; 53
    1308:	b0 e0       	ldi	r27, 0x00	; 0
    130a:	e5 e3       	ldi	r30, 0x35	; 53
    130c:	f0 e0       	ldi	r31, 0x00	; 0
    130e:	80 81       	ld	r24, Z
    1310:	48 2f       	mov	r20, r24
    1312:	8b 81       	ldd	r24, Y+3	; 0x03
    1314:	28 2f       	mov	r18, r24
    1316:	30 e0       	ldi	r19, 0x00	; 0
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	02 2e       	mov	r0, r18
    131e:	02 c0       	rjmp	.+4      	; 0x1324 <DIO_U8SetPinVal+0xd0>
    1320:	88 0f       	add	r24, r24
    1322:	99 1f       	adc	r25, r25
    1324:	0a 94       	dec	r0
    1326:	e2 f7       	brpl	.-8      	; 0x1320 <DIO_U8SetPinVal+0xcc>
    1328:	84 2b       	or	r24, r20
    132a:	8c 93       	st	X, r24
    132c:	8e c0       	rjmp	.+284    	; 0x144a <DIO_U8SetPinVal+0x1f6>
				break;
			}
			case 3:
			{
				SetBit(PORTD_REG,Copy_u8PinNo);
    132e:	a2 e3       	ldi	r26, 0x32	; 50
    1330:	b0 e0       	ldi	r27, 0x00	; 0
    1332:	e2 e3       	ldi	r30, 0x32	; 50
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	80 81       	ld	r24, Z
    1338:	48 2f       	mov	r20, r24
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	28 2f       	mov	r18, r24
    133e:	30 e0       	ldi	r19, 0x00	; 0
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	02 2e       	mov	r0, r18
    1346:	02 c0       	rjmp	.+4      	; 0x134c <DIO_U8SetPinVal+0xf8>
    1348:	88 0f       	add	r24, r24
    134a:	99 1f       	adc	r25, r25
    134c:	0a 94       	dec	r0
    134e:	e2 f7       	brpl	.-8      	; 0x1348 <DIO_U8SetPinVal+0xf4>
    1350:	84 2b       	or	r24, r20
    1352:	8c 93       	st	X, r24
    1354:	7a c0       	rjmp	.+244    	; 0x144a <DIO_U8SetPinVal+0x1f6>
				break;
			}

			}
		}
		else if(Copy_Val==LOW)
    1356:	8c 81       	ldd	r24, Y+4	; 0x04
    1358:	88 23       	and	r24, r24
    135a:	09 f0       	breq	.+2      	; 0x135e <DIO_U8SetPinVal+0x10a>
    135c:	74 c0       	rjmp	.+232    	; 0x1446 <DIO_U8SetPinVal+0x1f2>
		{
			switch(Copy_u8PortNo)
    135e:	8a 81       	ldd	r24, Y+2	; 0x02
    1360:	28 2f       	mov	r18, r24
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	3e 83       	std	Y+6, r19	; 0x06
    1366:	2d 83       	std	Y+5, r18	; 0x05
    1368:	8d 81       	ldd	r24, Y+5	; 0x05
    136a:	9e 81       	ldd	r25, Y+6	; 0x06
    136c:	81 30       	cpi	r24, 0x01	; 1
    136e:	91 05       	cpc	r25, r1
    1370:	59 f1       	breq	.+86     	; 0x13c8 <DIO_U8SetPinVal+0x174>
    1372:	2d 81       	ldd	r18, Y+5	; 0x05
    1374:	3e 81       	ldd	r19, Y+6	; 0x06
    1376:	22 30       	cpi	r18, 0x02	; 2
    1378:	31 05       	cpc	r19, r1
    137a:	2c f4       	brge	.+10     	; 0x1386 <DIO_U8SetPinVal+0x132>
    137c:	8d 81       	ldd	r24, Y+5	; 0x05
    137e:	9e 81       	ldd	r25, Y+6	; 0x06
    1380:	00 97       	sbiw	r24, 0x00	; 0
    1382:	69 f0       	breq	.+26     	; 0x139e <DIO_U8SetPinVal+0x14a>
    1384:	62 c0       	rjmp	.+196    	; 0x144a <DIO_U8SetPinVal+0x1f6>
    1386:	2d 81       	ldd	r18, Y+5	; 0x05
    1388:	3e 81       	ldd	r19, Y+6	; 0x06
    138a:	22 30       	cpi	r18, 0x02	; 2
    138c:	31 05       	cpc	r19, r1
    138e:	89 f1       	breq	.+98     	; 0x13f2 <DIO_U8SetPinVal+0x19e>
    1390:	8d 81       	ldd	r24, Y+5	; 0x05
    1392:	9e 81       	ldd	r25, Y+6	; 0x06
    1394:	83 30       	cpi	r24, 0x03	; 3
    1396:	91 05       	cpc	r25, r1
    1398:	09 f4       	brne	.+2      	; 0x139c <DIO_U8SetPinVal+0x148>
    139a:	40 c0       	rjmp	.+128    	; 0x141c <DIO_U8SetPinVal+0x1c8>
    139c:	56 c0       	rjmp	.+172    	; 0x144a <DIO_U8SetPinVal+0x1f6>
			{
				case 0:
				{
					ClearBit(PORTA_REG,Copy_u8PinNo);
    139e:	ab e3       	ldi	r26, 0x3B	; 59
    13a0:	b0 e0       	ldi	r27, 0x00	; 0
    13a2:	eb e3       	ldi	r30, 0x3B	; 59
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	80 81       	ld	r24, Z
    13a8:	48 2f       	mov	r20, r24
    13aa:	8b 81       	ldd	r24, Y+3	; 0x03
    13ac:	28 2f       	mov	r18, r24
    13ae:	30 e0       	ldi	r19, 0x00	; 0
    13b0:	81 e0       	ldi	r24, 0x01	; 1
    13b2:	90 e0       	ldi	r25, 0x00	; 0
    13b4:	02 2e       	mov	r0, r18
    13b6:	02 c0       	rjmp	.+4      	; 0x13bc <DIO_U8SetPinVal+0x168>
    13b8:	88 0f       	add	r24, r24
    13ba:	99 1f       	adc	r25, r25
    13bc:	0a 94       	dec	r0
    13be:	e2 f7       	brpl	.-8      	; 0x13b8 <DIO_U8SetPinVal+0x164>
    13c0:	80 95       	com	r24
    13c2:	84 23       	and	r24, r20
    13c4:	8c 93       	st	X, r24
    13c6:	41 c0       	rjmp	.+130    	; 0x144a <DIO_U8SetPinVal+0x1f6>
					break;
				}
				case 1:
				{
					ClearBit(PORTB_REG,Copy_u8PinNo);
    13c8:	a8 e3       	ldi	r26, 0x38	; 56
    13ca:	b0 e0       	ldi	r27, 0x00	; 0
    13cc:	e8 e3       	ldi	r30, 0x38	; 56
    13ce:	f0 e0       	ldi	r31, 0x00	; 0
    13d0:	80 81       	ld	r24, Z
    13d2:	48 2f       	mov	r20, r24
    13d4:	8b 81       	ldd	r24, Y+3	; 0x03
    13d6:	28 2f       	mov	r18, r24
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	81 e0       	ldi	r24, 0x01	; 1
    13dc:	90 e0       	ldi	r25, 0x00	; 0
    13de:	02 2e       	mov	r0, r18
    13e0:	02 c0       	rjmp	.+4      	; 0x13e6 <DIO_U8SetPinVal+0x192>
    13e2:	88 0f       	add	r24, r24
    13e4:	99 1f       	adc	r25, r25
    13e6:	0a 94       	dec	r0
    13e8:	e2 f7       	brpl	.-8      	; 0x13e2 <DIO_U8SetPinVal+0x18e>
    13ea:	80 95       	com	r24
    13ec:	84 23       	and	r24, r20
    13ee:	8c 93       	st	X, r24
    13f0:	2c c0       	rjmp	.+88     	; 0x144a <DIO_U8SetPinVal+0x1f6>
					break;
				}
				case 2:
				{
					ClearBit(PORTC_REG,Copy_u8PinNo);
    13f2:	a5 e3       	ldi	r26, 0x35	; 53
    13f4:	b0 e0       	ldi	r27, 0x00	; 0
    13f6:	e5 e3       	ldi	r30, 0x35	; 53
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	80 81       	ld	r24, Z
    13fc:	48 2f       	mov	r20, r24
    13fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1400:	28 2f       	mov	r18, r24
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	02 2e       	mov	r0, r18
    140a:	02 c0       	rjmp	.+4      	; 0x1410 <DIO_U8SetPinVal+0x1bc>
    140c:	88 0f       	add	r24, r24
    140e:	99 1f       	adc	r25, r25
    1410:	0a 94       	dec	r0
    1412:	e2 f7       	brpl	.-8      	; 0x140c <DIO_U8SetPinVal+0x1b8>
    1414:	80 95       	com	r24
    1416:	84 23       	and	r24, r20
    1418:	8c 93       	st	X, r24
    141a:	17 c0       	rjmp	.+46     	; 0x144a <DIO_U8SetPinVal+0x1f6>
					break;
				}
				case 3:
				{
					ClearBit(PORTD_REG,Copy_u8PinNo);
    141c:	a2 e3       	ldi	r26, 0x32	; 50
    141e:	b0 e0       	ldi	r27, 0x00	; 0
    1420:	e2 e3       	ldi	r30, 0x32	; 50
    1422:	f0 e0       	ldi	r31, 0x00	; 0
    1424:	80 81       	ld	r24, Z
    1426:	48 2f       	mov	r20, r24
    1428:	8b 81       	ldd	r24, Y+3	; 0x03
    142a:	28 2f       	mov	r18, r24
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	81 e0       	ldi	r24, 0x01	; 1
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	02 2e       	mov	r0, r18
    1434:	02 c0       	rjmp	.+4      	; 0x143a <DIO_U8SetPinVal+0x1e6>
    1436:	88 0f       	add	r24, r24
    1438:	99 1f       	adc	r25, r25
    143a:	0a 94       	dec	r0
    143c:	e2 f7       	brpl	.-8      	; 0x1436 <DIO_U8SetPinVal+0x1e2>
    143e:	80 95       	com	r24
    1440:	84 23       	and	r24, r20
    1442:	8c 93       	st	X, r24
    1444:	02 c0       	rjmp	.+4      	; 0x144a <DIO_U8SetPinVal+0x1f6>

			}
		}
		else
		{
			Local_Status=RT_NOK;
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	89 83       	std	Y+1, r24	; 0x01
{
	Local_Status=RT_NOK;
}


	return Local_Status;
    144a:	89 81       	ldd	r24, Y+1	; 0x01
}
    144c:	28 96       	adiw	r28, 0x08	; 8
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	de bf       	out	0x3e, r29	; 62
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	cd bf       	out	0x3d, r28	; 61
    1458:	cf 91       	pop	r28
    145a:	df 91       	pop	r29
    145c:	08 95       	ret

0000145e <DIO_U8GetPinVal>:

u8 DIO_U8GetPinVal(enum PORTS Copy_u8PortNo,enum PINS  Copy_u8PinNo, u8* u8_Val)
{
    145e:	df 93       	push	r29
    1460:	cf 93       	push	r28
    1462:	cd b7       	in	r28, 0x3d	; 61
    1464:	de b7       	in	r29, 0x3e	; 62
    1466:	27 97       	sbiw	r28, 0x07	; 7
    1468:	0f b6       	in	r0, 0x3f	; 63
    146a:	f8 94       	cli
    146c:	de bf       	out	0x3e, r29	; 62
    146e:	0f be       	out	0x3f, r0	; 63
    1470:	cd bf       	out	0x3d, r28	; 61
    1472:	8a 83       	std	Y+2, r24	; 0x02
    1474:	6b 83       	std	Y+3, r22	; 0x03
    1476:	5d 83       	std	Y+5, r21	; 0x05
    1478:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_Status=RT_OK;
    147a:	19 82       	std	Y+1, r1	; 0x01
	if(Copy_u8PortNo>=0||Copy_u8PortNo<=3)
	{
		if(Copy_u8PinNo>=0||Copy_u8PinNo<=7)
		{

				switch(Copy_u8PortNo)
    147c:	8a 81       	ldd	r24, Y+2	; 0x02
    147e:	28 2f       	mov	r18, r24
    1480:	30 e0       	ldi	r19, 0x00	; 0
    1482:	3f 83       	std	Y+7, r19	; 0x07
    1484:	2e 83       	std	Y+6, r18	; 0x06
    1486:	4e 81       	ldd	r20, Y+6	; 0x06
    1488:	5f 81       	ldd	r21, Y+7	; 0x07
    148a:	41 30       	cpi	r20, 0x01	; 1
    148c:	51 05       	cpc	r21, r1
    148e:	59 f1       	breq	.+86     	; 0x14e6 <DIO_U8GetPinVal+0x88>
    1490:	8e 81       	ldd	r24, Y+6	; 0x06
    1492:	9f 81       	ldd	r25, Y+7	; 0x07
    1494:	82 30       	cpi	r24, 0x02	; 2
    1496:	91 05       	cpc	r25, r1
    1498:	34 f4       	brge	.+12     	; 0x14a6 <DIO_U8GetPinVal+0x48>
    149a:	2e 81       	ldd	r18, Y+6	; 0x06
    149c:	3f 81       	ldd	r19, Y+7	; 0x07
    149e:	21 15       	cp	r18, r1
    14a0:	31 05       	cpc	r19, r1
    14a2:	69 f0       	breq	.+26     	; 0x14be <DIO_U8GetPinVal+0x60>
    14a4:	5b c0       	rjmp	.+182    	; 0x155c <DIO_U8GetPinVal+0xfe>
    14a6:	4e 81       	ldd	r20, Y+6	; 0x06
    14a8:	5f 81       	ldd	r21, Y+7	; 0x07
    14aa:	42 30       	cpi	r20, 0x02	; 2
    14ac:	51 05       	cpc	r21, r1
    14ae:	79 f1       	breq	.+94     	; 0x150e <DIO_U8GetPinVal+0xb0>
    14b0:	8e 81       	ldd	r24, Y+6	; 0x06
    14b2:	9f 81       	ldd	r25, Y+7	; 0x07
    14b4:	83 30       	cpi	r24, 0x03	; 3
    14b6:	91 05       	cpc	r25, r1
    14b8:	09 f4       	brne	.+2      	; 0x14bc <DIO_U8GetPinVal+0x5e>
    14ba:	3d c0       	rjmp	.+122    	; 0x1536 <DIO_U8GetPinVal+0xd8>
    14bc:	4f c0       	rjmp	.+158    	; 0x155c <DIO_U8GetPinVal+0xfe>
				{
				case 0:
				{
					*u8_Val=GetBit(PINA_REG,Copy_u8PinNo);
    14be:	e9 e3       	ldi	r30, 0x39	; 57
    14c0:	f0 e0       	ldi	r31, 0x00	; 0
    14c2:	80 81       	ld	r24, Z
    14c4:	28 2f       	mov	r18, r24
    14c6:	30 e0       	ldi	r19, 0x00	; 0
    14c8:	8b 81       	ldd	r24, Y+3	; 0x03
    14ca:	88 2f       	mov	r24, r24
    14cc:	90 e0       	ldi	r25, 0x00	; 0
    14ce:	a9 01       	movw	r20, r18
    14d0:	02 c0       	rjmp	.+4      	; 0x14d6 <DIO_U8GetPinVal+0x78>
    14d2:	55 95       	asr	r21
    14d4:	47 95       	ror	r20
    14d6:	8a 95       	dec	r24
    14d8:	e2 f7       	brpl	.-8      	; 0x14d2 <DIO_U8GetPinVal+0x74>
    14da:	ca 01       	movw	r24, r20
    14dc:	81 70       	andi	r24, 0x01	; 1
    14de:	ec 81       	ldd	r30, Y+4	; 0x04
    14e0:	fd 81       	ldd	r31, Y+5	; 0x05
    14e2:	80 83       	st	Z, r24
    14e4:	3b c0       	rjmp	.+118    	; 0x155c <DIO_U8GetPinVal+0xfe>
					break;
				}
				case 1:
				{
					*u8_Val=GetBit(PINB_REG,Copy_u8PinNo);
    14e6:	e6 e3       	ldi	r30, 0x36	; 54
    14e8:	f0 e0       	ldi	r31, 0x00	; 0
    14ea:	80 81       	ld	r24, Z
    14ec:	28 2f       	mov	r18, r24
    14ee:	30 e0       	ldi	r19, 0x00	; 0
    14f0:	8b 81       	ldd	r24, Y+3	; 0x03
    14f2:	88 2f       	mov	r24, r24
    14f4:	90 e0       	ldi	r25, 0x00	; 0
    14f6:	a9 01       	movw	r20, r18
    14f8:	02 c0       	rjmp	.+4      	; 0x14fe <DIO_U8GetPinVal+0xa0>
    14fa:	55 95       	asr	r21
    14fc:	47 95       	ror	r20
    14fe:	8a 95       	dec	r24
    1500:	e2 f7       	brpl	.-8      	; 0x14fa <DIO_U8GetPinVal+0x9c>
    1502:	ca 01       	movw	r24, r20
    1504:	81 70       	andi	r24, 0x01	; 1
    1506:	ec 81       	ldd	r30, Y+4	; 0x04
    1508:	fd 81       	ldd	r31, Y+5	; 0x05
    150a:	80 83       	st	Z, r24
    150c:	27 c0       	rjmp	.+78     	; 0x155c <DIO_U8GetPinVal+0xfe>
					break;
				}
				case 2:
				{
					*u8_Val=GetBit(PINC_REG,Copy_u8PinNo);
    150e:	e3 e3       	ldi	r30, 0x33	; 51
    1510:	f0 e0       	ldi	r31, 0x00	; 0
    1512:	80 81       	ld	r24, Z
    1514:	28 2f       	mov	r18, r24
    1516:	30 e0       	ldi	r19, 0x00	; 0
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	88 2f       	mov	r24, r24
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	a9 01       	movw	r20, r18
    1520:	02 c0       	rjmp	.+4      	; 0x1526 <DIO_U8GetPinVal+0xc8>
    1522:	55 95       	asr	r21
    1524:	47 95       	ror	r20
    1526:	8a 95       	dec	r24
    1528:	e2 f7       	brpl	.-8      	; 0x1522 <DIO_U8GetPinVal+0xc4>
    152a:	ca 01       	movw	r24, r20
    152c:	81 70       	andi	r24, 0x01	; 1
    152e:	ec 81       	ldd	r30, Y+4	; 0x04
    1530:	fd 81       	ldd	r31, Y+5	; 0x05
    1532:	80 83       	st	Z, r24
    1534:	13 c0       	rjmp	.+38     	; 0x155c <DIO_U8GetPinVal+0xfe>
					break;
				}
				case 3:
				{
					*u8_Val=GetBit(PIND_REG,Copy_u8PinNo);
    1536:	e0 e3       	ldi	r30, 0x30	; 48
    1538:	f0 e0       	ldi	r31, 0x00	; 0
    153a:	80 81       	ld	r24, Z
    153c:	28 2f       	mov	r18, r24
    153e:	30 e0       	ldi	r19, 0x00	; 0
    1540:	8b 81       	ldd	r24, Y+3	; 0x03
    1542:	88 2f       	mov	r24, r24
    1544:	90 e0       	ldi	r25, 0x00	; 0
    1546:	a9 01       	movw	r20, r18
    1548:	02 c0       	rjmp	.+4      	; 0x154e <DIO_U8GetPinVal+0xf0>
    154a:	55 95       	asr	r21
    154c:	47 95       	ror	r20
    154e:	8a 95       	dec	r24
    1550:	e2 f7       	brpl	.-8      	; 0x154a <DIO_U8GetPinVal+0xec>
    1552:	ca 01       	movw	r24, r20
    1554:	81 70       	andi	r24, 0x01	; 1
    1556:	ec 81       	ldd	r30, Y+4	; 0x04
    1558:	fd 81       	ldd	r31, Y+5	; 0x05
    155a:	80 83       	st	Z, r24
	{
		Local_Status=RT_NOK;
	}


		return Local_Status;
    155c:	89 81       	ldd	r24, Y+1	; 0x01
}
    155e:	27 96       	adiw	r28, 0x07	; 7
    1560:	0f b6       	in	r0, 0x3f	; 63
    1562:	f8 94       	cli
    1564:	de bf       	out	0x3e, r29	; 62
    1566:	0f be       	out	0x3f, r0	; 63
    1568:	cd bf       	out	0x3d, r28	; 61
    156a:	cf 91       	pop	r28
    156c:	df 91       	pop	r29
    156e:	08 95       	ret

00001570 <LCD_VoidSendCommand>:

u8 Global_u8Clear=0;
/*if we select send command*/
# if(LCD_MODE==BIT_8)
void LCD_VoidSendCommand(u8 Copy_u8Command)
{
    1570:	df 93       	push	r29
    1572:	cf 93       	push	r28
    1574:	cd b7       	in	r28, 0x3d	; 61
    1576:	de b7       	in	r29, 0x3e	; 62
    1578:	2f 97       	sbiw	r28, 0x0f	; 15
    157a:	0f b6       	in	r0, 0x3f	; 63
    157c:	f8 94       	cli
    157e:	de bf       	out	0x3e, r29	; 62
    1580:	0f be       	out	0x3f, r0	; 63
    1582:	cd bf       	out	0x3d, r28	; 61
    1584:	8f 87       	std	Y+15, r24	; 0x0f
	/*for function set: RS:command,R/W:write */
		DIO_U8SetPinVal(LCD_Config_PORT,LCD_RS_PIN,LOW);
    1586:	83 e0       	ldi	r24, 0x03	; 3
    1588:	60 e0       	ldi	r22, 0x00	; 0
    158a:	40 e0       	ldi	r20, 0x00	; 0
    158c:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
		DIO_U8SetPinVal(LCD_Config_PORT,LCD_R_W_PIN,LOW);
    1590:	83 e0       	ldi	r24, 0x03	; 3
    1592:	61 e0       	ldi	r22, 0x01	; 1
    1594:	40 e0       	ldi	r20, 0x00	; 0
    1596:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
		DIO_U8SetPortVal(LCD_DATA_PORT,Copy_u8Command);
    159a:	82 e0       	ldi	r24, 0x02	; 2
    159c:	6f 85       	ldd	r22, Y+15	; 0x0f
    159e:	0e 94 85 07 	call	0xf0a	; 0xf0a <DIO_U8SetPortVal>


	/*making enable pulse high for 2mile sec only*/
	DIO_U8SetPinVal(LCD_Config_PORT,LCD_EN_PIN,HIGH);
    15a2:	83 e0       	ldi	r24, 0x03	; 3
    15a4:	62 e0       	ldi	r22, 0x02	; 2
    15a6:	41 e0       	ldi	r20, 0x01	; 1
    15a8:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	a0 e0       	ldi	r26, 0x00	; 0
    15b2:	b0 e4       	ldi	r27, 0x40	; 64
    15b4:	8b 87       	std	Y+11, r24	; 0x0b
    15b6:	9c 87       	std	Y+12, r25	; 0x0c
    15b8:	ad 87       	std	Y+13, r26	; 0x0d
    15ba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    15bc:	6b 85       	ldd	r22, Y+11	; 0x0b
    15be:	7c 85       	ldd	r23, Y+12	; 0x0c
    15c0:	8d 85       	ldd	r24, Y+13	; 0x0d
    15c2:	9e 85       	ldd	r25, Y+14	; 0x0e
    15c4:	20 e0       	ldi	r18, 0x00	; 0
    15c6:	30 e0       	ldi	r19, 0x00	; 0
    15c8:	4a ef       	ldi	r20, 0xFA	; 250
    15ca:	54 e4       	ldi	r21, 0x44	; 68
    15cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15d0:	dc 01       	movw	r26, r24
    15d2:	cb 01       	movw	r24, r22
    15d4:	8f 83       	std	Y+7, r24	; 0x07
    15d6:	98 87       	std	Y+8, r25	; 0x08
    15d8:	a9 87       	std	Y+9, r26	; 0x09
    15da:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    15dc:	6f 81       	ldd	r22, Y+7	; 0x07
    15de:	78 85       	ldd	r23, Y+8	; 0x08
    15e0:	89 85       	ldd	r24, Y+9	; 0x09
    15e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    15e4:	20 e0       	ldi	r18, 0x00	; 0
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	40 e8       	ldi	r20, 0x80	; 128
    15ea:	5f e3       	ldi	r21, 0x3F	; 63
    15ec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    15f0:	88 23       	and	r24, r24
    15f2:	2c f4       	brge	.+10     	; 0x15fe <LCD_VoidSendCommand+0x8e>
		__ticks = 1;
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	9e 83       	std	Y+6, r25	; 0x06
    15fa:	8d 83       	std	Y+5, r24	; 0x05
    15fc:	3f c0       	rjmp	.+126    	; 0x167c <LCD_VoidSendCommand+0x10c>
	else if (__tmp > 65535)
    15fe:	6f 81       	ldd	r22, Y+7	; 0x07
    1600:	78 85       	ldd	r23, Y+8	; 0x08
    1602:	89 85       	ldd	r24, Y+9	; 0x09
    1604:	9a 85       	ldd	r25, Y+10	; 0x0a
    1606:	20 e0       	ldi	r18, 0x00	; 0
    1608:	3f ef       	ldi	r19, 0xFF	; 255
    160a:	4f e7       	ldi	r20, 0x7F	; 127
    160c:	57 e4       	ldi	r21, 0x47	; 71
    160e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1612:	18 16       	cp	r1, r24
    1614:	4c f5       	brge	.+82     	; 0x1668 <LCD_VoidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1616:	6b 85       	ldd	r22, Y+11	; 0x0b
    1618:	7c 85       	ldd	r23, Y+12	; 0x0c
    161a:	8d 85       	ldd	r24, Y+13	; 0x0d
    161c:	9e 85       	ldd	r25, Y+14	; 0x0e
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	40 e2       	ldi	r20, 0x20	; 32
    1624:	51 e4       	ldi	r21, 0x41	; 65
    1626:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    162a:	dc 01       	movw	r26, r24
    162c:	cb 01       	movw	r24, r22
    162e:	bc 01       	movw	r22, r24
    1630:	cd 01       	movw	r24, r26
    1632:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1636:	dc 01       	movw	r26, r24
    1638:	cb 01       	movw	r24, r22
    163a:	9e 83       	std	Y+6, r25	; 0x06
    163c:	8d 83       	std	Y+5, r24	; 0x05
    163e:	0f c0       	rjmp	.+30     	; 0x165e <LCD_VoidSendCommand+0xee>
    1640:	88 ec       	ldi	r24, 0xC8	; 200
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	9c 83       	std	Y+4, r25	; 0x04
    1646:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1648:	8b 81       	ldd	r24, Y+3	; 0x03
    164a:	9c 81       	ldd	r25, Y+4	; 0x04
    164c:	01 97       	sbiw	r24, 0x01	; 1
    164e:	f1 f7       	brne	.-4      	; 0x164c <LCD_VoidSendCommand+0xdc>
    1650:	9c 83       	std	Y+4, r25	; 0x04
    1652:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1654:	8d 81       	ldd	r24, Y+5	; 0x05
    1656:	9e 81       	ldd	r25, Y+6	; 0x06
    1658:	01 97       	sbiw	r24, 0x01	; 1
    165a:	9e 83       	std	Y+6, r25	; 0x06
    165c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    165e:	8d 81       	ldd	r24, Y+5	; 0x05
    1660:	9e 81       	ldd	r25, Y+6	; 0x06
    1662:	00 97       	sbiw	r24, 0x00	; 0
    1664:	69 f7       	brne	.-38     	; 0x1640 <LCD_VoidSendCommand+0xd0>
    1666:	14 c0       	rjmp	.+40     	; 0x1690 <LCD_VoidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1668:	6f 81       	ldd	r22, Y+7	; 0x07
    166a:	78 85       	ldd	r23, Y+8	; 0x08
    166c:	89 85       	ldd	r24, Y+9	; 0x09
    166e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1670:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1674:	dc 01       	movw	r26, r24
    1676:	cb 01       	movw	r24, r22
    1678:	9e 83       	std	Y+6, r25	; 0x06
    167a:	8d 83       	std	Y+5, r24	; 0x05
    167c:	8d 81       	ldd	r24, Y+5	; 0x05
    167e:	9e 81       	ldd	r25, Y+6	; 0x06
    1680:	9a 83       	std	Y+2, r25	; 0x02
    1682:	89 83       	std	Y+1, r24	; 0x01
    1684:	89 81       	ldd	r24, Y+1	; 0x01
    1686:	9a 81       	ldd	r25, Y+2	; 0x02
    1688:	01 97       	sbiw	r24, 0x01	; 1
    168a:	f1 f7       	brne	.-4      	; 0x1688 <LCD_VoidSendCommand+0x118>
    168c:	9a 83       	std	Y+2, r25	; 0x02
    168e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_U8SetPinVal(LCD_Config_PORT,LCD_EN_PIN,LOW);
    1690:	83 e0       	ldi	r24, 0x03	; 3
    1692:	62 e0       	ldi	r22, 0x02	; 2
    1694:	40 e0       	ldi	r20, 0x00	; 0
    1696:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>

}
    169a:	2f 96       	adiw	r28, 0x0f	; 15
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	de bf       	out	0x3e, r29	; 62
    16a2:	0f be       	out	0x3f, r0	; 63
    16a4:	cd bf       	out	0x3d, r28	; 61
    16a6:	cf 91       	pop	r28
    16a8:	df 91       	pop	r29
    16aa:	08 95       	ret

000016ac <LCD_VoidSendData>:

/* if we select send data*/
void LCD_VoidSendData(u8 Copy_u8Data)
{
    16ac:	df 93       	push	r29
    16ae:	cf 93       	push	r28
    16b0:	cd b7       	in	r28, 0x3d	; 61
    16b2:	de b7       	in	r29, 0x3e	; 62
    16b4:	2f 97       	sbiw	r28, 0x0f	; 15
    16b6:	0f b6       	in	r0, 0x3f	; 63
    16b8:	f8 94       	cli
    16ba:	de bf       	out	0x3e, r29	; 62
    16bc:	0f be       	out	0x3f, r0	; 63
    16be:	cd bf       	out	0x3d, r28	; 61
    16c0:	8f 87       	std	Y+15, r24	; 0x0f
	static u8 Local_EnterFunction=0;
	Local_EnterFunction++;
    16c2:	80 91 85 01 	lds	r24, 0x0185
    16c6:	8f 5f       	subi	r24, 0xFF	; 255
    16c8:	80 93 85 01 	sts	0x0185, r24
	if(Global_u8Clear==1)
    16cc:	80 91 84 01 	lds	r24, 0x0184
    16d0:	81 30       	cpi	r24, 0x01	; 1
    16d2:	21 f4       	brne	.+8      	; 0x16dc <LCD_VoidSendData+0x30>
	{
		Local_EnterFunction=0;
    16d4:	10 92 85 01 	sts	0x0185, r1
		Global_u8Clear=0;
    16d8:	10 92 84 01 	sts	0x0184, r1

	}

	if(Local_EnterFunction==16)
    16dc:	80 91 85 01 	lds	r24, 0x0185
    16e0:	80 31       	cpi	r24, 0x10	; 16
    16e2:	21 f4       	brne	.+8      	; 0x16ec <LCD_VoidSendData+0x40>
	{
		LCD_VoidGoToPos(1,0);
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	60 e0       	ldi	r22, 0x00	; 0
    16e8:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <LCD_VoidGoToPos>
	}
	       /*for function set:
	        * RS:command
	        * R/W:write
	       */
	        DIO_U8SetPinVal(LCD_Config_PORT,LCD_RS_PIN,HIGH);
    16ec:	83 e0       	ldi	r24, 0x03	; 3
    16ee:	60 e0       	ldi	r22, 0x00	; 0
    16f0:	41 e0       	ldi	r20, 0x01	; 1
    16f2:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
			DIO_U8SetPinVal(LCD_Config_PORT,LCD_R_W_PIN,LOW);
    16f6:	83 e0       	ldi	r24, 0x03	; 3
    16f8:	61 e0       	ldi	r22, 0x01	; 1
    16fa:	40 e0       	ldi	r20, 0x00	; 0
    16fc:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
			DIO_U8SetPortVal(LCD_DATA_PORT,Copy_u8Data);
    1700:	82 e0       	ldi	r24, 0x02	; 2
    1702:	6f 85       	ldd	r22, Y+15	; 0x0f
    1704:	0e 94 85 07 	call	0xf0a	; 0xf0a <DIO_U8SetPortVal>


		/*making enable pulse high for 2mile sec only*/
		DIO_U8SetPinVal(LCD_Config_PORT,LCD_EN_PIN,HIGH);
    1708:	83 e0       	ldi	r24, 0x03	; 3
    170a:	62 e0       	ldi	r22, 0x02	; 2
    170c:	41 e0       	ldi	r20, 0x01	; 1
    170e:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>
    1712:	80 e0       	ldi	r24, 0x00	; 0
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	a0 e0       	ldi	r26, 0x00	; 0
    1718:	b0 e4       	ldi	r27, 0x40	; 64
    171a:	8b 87       	std	Y+11, r24	; 0x0b
    171c:	9c 87       	std	Y+12, r25	; 0x0c
    171e:	ad 87       	std	Y+13, r26	; 0x0d
    1720:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1722:	6b 85       	ldd	r22, Y+11	; 0x0b
    1724:	7c 85       	ldd	r23, Y+12	; 0x0c
    1726:	8d 85       	ldd	r24, Y+13	; 0x0d
    1728:	9e 85       	ldd	r25, Y+14	; 0x0e
    172a:	20 e0       	ldi	r18, 0x00	; 0
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	4a ef       	ldi	r20, 0xFA	; 250
    1730:	54 e4       	ldi	r21, 0x44	; 68
    1732:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1736:	dc 01       	movw	r26, r24
    1738:	cb 01       	movw	r24, r22
    173a:	8f 83       	std	Y+7, r24	; 0x07
    173c:	98 87       	std	Y+8, r25	; 0x08
    173e:	a9 87       	std	Y+9, r26	; 0x09
    1740:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1742:	6f 81       	ldd	r22, Y+7	; 0x07
    1744:	78 85       	ldd	r23, Y+8	; 0x08
    1746:	89 85       	ldd	r24, Y+9	; 0x09
    1748:	9a 85       	ldd	r25, Y+10	; 0x0a
    174a:	20 e0       	ldi	r18, 0x00	; 0
    174c:	30 e0       	ldi	r19, 0x00	; 0
    174e:	40 e8       	ldi	r20, 0x80	; 128
    1750:	5f e3       	ldi	r21, 0x3F	; 63
    1752:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1756:	88 23       	and	r24, r24
    1758:	2c f4       	brge	.+10     	; 0x1764 <LCD_VoidSendData+0xb8>
		__ticks = 1;
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	9e 83       	std	Y+6, r25	; 0x06
    1760:	8d 83       	std	Y+5, r24	; 0x05
    1762:	3f c0       	rjmp	.+126    	; 0x17e2 <LCD_VoidSendData+0x136>
	else if (__tmp > 65535)
    1764:	6f 81       	ldd	r22, Y+7	; 0x07
    1766:	78 85       	ldd	r23, Y+8	; 0x08
    1768:	89 85       	ldd	r24, Y+9	; 0x09
    176a:	9a 85       	ldd	r25, Y+10	; 0x0a
    176c:	20 e0       	ldi	r18, 0x00	; 0
    176e:	3f ef       	ldi	r19, 0xFF	; 255
    1770:	4f e7       	ldi	r20, 0x7F	; 127
    1772:	57 e4       	ldi	r21, 0x47	; 71
    1774:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1778:	18 16       	cp	r1, r24
    177a:	4c f5       	brge	.+82     	; 0x17ce <LCD_VoidSendData+0x122>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    177c:	6b 85       	ldd	r22, Y+11	; 0x0b
    177e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1780:	8d 85       	ldd	r24, Y+13	; 0x0d
    1782:	9e 85       	ldd	r25, Y+14	; 0x0e
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	40 e2       	ldi	r20, 0x20	; 32
    178a:	51 e4       	ldi	r21, 0x41	; 65
    178c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1790:	dc 01       	movw	r26, r24
    1792:	cb 01       	movw	r24, r22
    1794:	bc 01       	movw	r22, r24
    1796:	cd 01       	movw	r24, r26
    1798:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    179c:	dc 01       	movw	r26, r24
    179e:	cb 01       	movw	r24, r22
    17a0:	9e 83       	std	Y+6, r25	; 0x06
    17a2:	8d 83       	std	Y+5, r24	; 0x05
    17a4:	0f c0       	rjmp	.+30     	; 0x17c4 <LCD_VoidSendData+0x118>
    17a6:	88 ec       	ldi	r24, 0xC8	; 200
    17a8:	90 e0       	ldi	r25, 0x00	; 0
    17aa:	9c 83       	std	Y+4, r25	; 0x04
    17ac:	8b 83       	std	Y+3, r24	; 0x03
    17ae:	8b 81       	ldd	r24, Y+3	; 0x03
    17b0:	9c 81       	ldd	r25, Y+4	; 0x04
    17b2:	01 97       	sbiw	r24, 0x01	; 1
    17b4:	f1 f7       	brne	.-4      	; 0x17b2 <LCD_VoidSendData+0x106>
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17ba:	8d 81       	ldd	r24, Y+5	; 0x05
    17bc:	9e 81       	ldd	r25, Y+6	; 0x06
    17be:	01 97       	sbiw	r24, 0x01	; 1
    17c0:	9e 83       	std	Y+6, r25	; 0x06
    17c2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17c4:	8d 81       	ldd	r24, Y+5	; 0x05
    17c6:	9e 81       	ldd	r25, Y+6	; 0x06
    17c8:	00 97       	sbiw	r24, 0x00	; 0
    17ca:	69 f7       	brne	.-38     	; 0x17a6 <LCD_VoidSendData+0xfa>
    17cc:	14 c0       	rjmp	.+40     	; 0x17f6 <LCD_VoidSendData+0x14a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    17ce:	6f 81       	ldd	r22, Y+7	; 0x07
    17d0:	78 85       	ldd	r23, Y+8	; 0x08
    17d2:	89 85       	ldd	r24, Y+9	; 0x09
    17d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    17d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    17da:	dc 01       	movw	r26, r24
    17dc:	cb 01       	movw	r24, r22
    17de:	9e 83       	std	Y+6, r25	; 0x06
    17e0:	8d 83       	std	Y+5, r24	; 0x05
    17e2:	8d 81       	ldd	r24, Y+5	; 0x05
    17e4:	9e 81       	ldd	r25, Y+6	; 0x06
    17e6:	9a 83       	std	Y+2, r25	; 0x02
    17e8:	89 83       	std	Y+1, r24	; 0x01
    17ea:	89 81       	ldd	r24, Y+1	; 0x01
    17ec:	9a 81       	ldd	r25, Y+2	; 0x02
    17ee:	01 97       	sbiw	r24, 0x01	; 1
    17f0:	f1 f7       	brne	.-4      	; 0x17ee <LCD_VoidSendData+0x142>
    17f2:	9a 83       	std	Y+2, r25	; 0x02
    17f4:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(2);
		DIO_U8SetPinVal(LCD_Config_PORT,LCD_EN_PIN,LOW);
    17f6:	83 e0       	ldi	r24, 0x03	; 3
    17f8:	62 e0       	ldi	r22, 0x02	; 2
    17fa:	40 e0       	ldi	r20, 0x00	; 0
    17fc:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_U8SetPinVal>



}
    1800:	2f 96       	adiw	r28, 0x0f	; 15
    1802:	0f b6       	in	r0, 0x3f	; 63
    1804:	f8 94       	cli
    1806:	de bf       	out	0x3e, r29	; 62
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	cd bf       	out	0x3d, r28	; 61
    180c:	cf 91       	pop	r28
    180e:	df 91       	pop	r29
    1810:	08 95       	ret

00001812 <LCD_VoidInit>:



/*to initialize the LCD*/
void LCD_VoidInit(void)
{
    1812:	df 93       	push	r29
    1814:	cf 93       	push	r28
    1816:	cd b7       	in	r28, 0x3d	; 61
    1818:	de b7       	in	r29, 0x3e	; 62
    181a:	a6 97       	sbiw	r28, 0x26	; 38
    181c:	0f b6       	in	r0, 0x3f	; 63
    181e:	f8 94       	cli
    1820:	de bf       	out	0x3e, r29	; 62
    1822:	0f be       	out	0x3f, r0	; 63
    1824:	cd bf       	out	0x3d, r28	; 61
    1826:	80 e0       	ldi	r24, 0x00	; 0
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	a0 e2       	ldi	r26, 0x20	; 32
    182c:	b2 e4       	ldi	r27, 0x42	; 66
    182e:	8b a3       	std	Y+35, r24	; 0x23
    1830:	9c a3       	std	Y+36, r25	; 0x24
    1832:	ad a3       	std	Y+37, r26	; 0x25
    1834:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1836:	6b a1       	ldd	r22, Y+35	; 0x23
    1838:	7c a1       	ldd	r23, Y+36	; 0x24
    183a:	8d a1       	ldd	r24, Y+37	; 0x25
    183c:	9e a1       	ldd	r25, Y+38	; 0x26
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	4a ef       	ldi	r20, 0xFA	; 250
    1844:	54 e4       	ldi	r21, 0x44	; 68
    1846:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    184a:	dc 01       	movw	r26, r24
    184c:	cb 01       	movw	r24, r22
    184e:	8f 8f       	std	Y+31, r24	; 0x1f
    1850:	98 a3       	std	Y+32, r25	; 0x20
    1852:	a9 a3       	std	Y+33, r26	; 0x21
    1854:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    1856:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1858:	78 a1       	ldd	r23, Y+32	; 0x20
    185a:	89 a1       	ldd	r24, Y+33	; 0x21
    185c:	9a a1       	ldd	r25, Y+34	; 0x22
    185e:	20 e0       	ldi	r18, 0x00	; 0
    1860:	30 e0       	ldi	r19, 0x00	; 0
    1862:	40 e8       	ldi	r20, 0x80	; 128
    1864:	5f e3       	ldi	r21, 0x3F	; 63
    1866:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    186a:	88 23       	and	r24, r24
    186c:	2c f4       	brge	.+10     	; 0x1878 <LCD_VoidInit+0x66>
		__ticks = 1;
    186e:	81 e0       	ldi	r24, 0x01	; 1
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	9e 8f       	std	Y+30, r25	; 0x1e
    1874:	8d 8f       	std	Y+29, r24	; 0x1d
    1876:	3f c0       	rjmp	.+126    	; 0x18f6 <LCD_VoidInit+0xe4>
	else if (__tmp > 65535)
    1878:	6f 8d       	ldd	r22, Y+31	; 0x1f
    187a:	78 a1       	ldd	r23, Y+32	; 0x20
    187c:	89 a1       	ldd	r24, Y+33	; 0x21
    187e:	9a a1       	ldd	r25, Y+34	; 0x22
    1880:	20 e0       	ldi	r18, 0x00	; 0
    1882:	3f ef       	ldi	r19, 0xFF	; 255
    1884:	4f e7       	ldi	r20, 0x7F	; 127
    1886:	57 e4       	ldi	r21, 0x47	; 71
    1888:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    188c:	18 16       	cp	r1, r24
    188e:	4c f5       	brge	.+82     	; 0x18e2 <LCD_VoidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1890:	6b a1       	ldd	r22, Y+35	; 0x23
    1892:	7c a1       	ldd	r23, Y+36	; 0x24
    1894:	8d a1       	ldd	r24, Y+37	; 0x25
    1896:	9e a1       	ldd	r25, Y+38	; 0x26
    1898:	20 e0       	ldi	r18, 0x00	; 0
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	40 e2       	ldi	r20, 0x20	; 32
    189e:	51 e4       	ldi	r21, 0x41	; 65
    18a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18a4:	dc 01       	movw	r26, r24
    18a6:	cb 01       	movw	r24, r22
    18a8:	bc 01       	movw	r22, r24
    18aa:	cd 01       	movw	r24, r26
    18ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18b0:	dc 01       	movw	r26, r24
    18b2:	cb 01       	movw	r24, r22
    18b4:	9e 8f       	std	Y+30, r25	; 0x1e
    18b6:	8d 8f       	std	Y+29, r24	; 0x1d
    18b8:	0f c0       	rjmp	.+30     	; 0x18d8 <LCD_VoidInit+0xc6>
    18ba:	88 ec       	ldi	r24, 0xC8	; 200
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	9c 8f       	std	Y+28, r25	; 0x1c
    18c0:	8b 8f       	std	Y+27, r24	; 0x1b
    18c2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18c4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18c6:	01 97       	sbiw	r24, 0x01	; 1
    18c8:	f1 f7       	brne	.-4      	; 0x18c6 <LCD_VoidInit+0xb4>
    18ca:	9c 8f       	std	Y+28, r25	; 0x1c
    18cc:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18ce:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18d0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18d2:	01 97       	sbiw	r24, 0x01	; 1
    18d4:	9e 8f       	std	Y+30, r25	; 0x1e
    18d6:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18d8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18da:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18dc:	00 97       	sbiw	r24, 0x00	; 0
    18de:	69 f7       	brne	.-38     	; 0x18ba <LCD_VoidInit+0xa8>
    18e0:	14 c0       	rjmp	.+40     	; 0x190a <LCD_VoidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18e2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18e4:	78 a1       	ldd	r23, Y+32	; 0x20
    18e6:	89 a1       	ldd	r24, Y+33	; 0x21
    18e8:	9a a1       	ldd	r25, Y+34	; 0x22
    18ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18ee:	dc 01       	movw	r26, r24
    18f0:	cb 01       	movw	r24, r22
    18f2:	9e 8f       	std	Y+30, r25	; 0x1e
    18f4:	8d 8f       	std	Y+29, r24	; 0x1d
    18f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    18f8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    18fa:	9a 8f       	std	Y+26, r25	; 0x1a
    18fc:	89 8f       	std	Y+25, r24	; 0x19
    18fe:	89 8d       	ldd	r24, Y+25	; 0x19
    1900:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1902:	01 97       	sbiw	r24, 0x01	; 1
    1904:	f1 f7       	brne	.-4      	; 0x1902 <LCD_VoidInit+0xf0>
    1906:	9a 8f       	std	Y+26, r25	; 0x1a
    1908:	89 8f       	std	Y+25, r24	; 0x19
		LCD_VoidSendCommand(0b00110000);

	}
#elif NUM_LINES ==LINE2
	{
		LCD_VoidSendCommand(0b00111000);
    190a:	88 e3       	ldi	r24, 0x38	; 56
    190c:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
    1910:	80 e0       	ldi	r24, 0x00	; 0
    1912:	90 e0       	ldi	r25, 0x00	; 0
    1914:	a8 e4       	ldi	r26, 0x48	; 72
    1916:	b2 e4       	ldi	r27, 0x42	; 66
    1918:	8d 8b       	std	Y+21, r24	; 0x15
    191a:	9e 8b       	std	Y+22, r25	; 0x16
    191c:	af 8b       	std	Y+23, r26	; 0x17
    191e:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1920:	6d 89       	ldd	r22, Y+21	; 0x15
    1922:	7e 89       	ldd	r23, Y+22	; 0x16
    1924:	8f 89       	ldd	r24, Y+23	; 0x17
    1926:	98 8d       	ldd	r25, Y+24	; 0x18
    1928:	2b ea       	ldi	r18, 0xAB	; 171
    192a:	3a ea       	ldi	r19, 0xAA	; 170
    192c:	4a e2       	ldi	r20, 0x2A	; 42
    192e:	50 e4       	ldi	r21, 0x40	; 64
    1930:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1934:	dc 01       	movw	r26, r24
    1936:	cb 01       	movw	r24, r22
    1938:	89 8b       	std	Y+17, r24	; 0x11
    193a:	9a 8b       	std	Y+18, r25	; 0x12
    193c:	ab 8b       	std	Y+19, r26	; 0x13
    193e:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1940:	69 89       	ldd	r22, Y+17	; 0x11
    1942:	7a 89       	ldd	r23, Y+18	; 0x12
    1944:	8b 89       	ldd	r24, Y+19	; 0x13
    1946:	9c 89       	ldd	r25, Y+20	; 0x14
    1948:	20 e0       	ldi	r18, 0x00	; 0
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	40 e8       	ldi	r20, 0x80	; 128
    194e:	5f e3       	ldi	r21, 0x3F	; 63
    1950:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1954:	88 23       	and	r24, r24
    1956:	1c f4       	brge	.+6      	; 0x195e <LCD_VoidInit+0x14c>
		__ticks = 1;
    1958:	81 e0       	ldi	r24, 0x01	; 1
    195a:	88 8b       	std	Y+16, r24	; 0x10
    195c:	91 c0       	rjmp	.+290    	; 0x1a80 <LCD_VoidInit+0x26e>
	else if (__tmp > 255)
    195e:	69 89       	ldd	r22, Y+17	; 0x11
    1960:	7a 89       	ldd	r23, Y+18	; 0x12
    1962:	8b 89       	ldd	r24, Y+19	; 0x13
    1964:	9c 89       	ldd	r25, Y+20	; 0x14
    1966:	20 e0       	ldi	r18, 0x00	; 0
    1968:	30 e0       	ldi	r19, 0x00	; 0
    196a:	4f e7       	ldi	r20, 0x7F	; 127
    196c:	53 e4       	ldi	r21, 0x43	; 67
    196e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1972:	18 16       	cp	r1, r24
    1974:	0c f0       	brlt	.+2      	; 0x1978 <LCD_VoidInit+0x166>
    1976:	7b c0       	rjmp	.+246    	; 0x1a6e <LCD_VoidInit+0x25c>
	{
		_delay_ms(__us / 1000.0);
    1978:	6d 89       	ldd	r22, Y+21	; 0x15
    197a:	7e 89       	ldd	r23, Y+22	; 0x16
    197c:	8f 89       	ldd	r24, Y+23	; 0x17
    197e:	98 8d       	ldd	r25, Y+24	; 0x18
    1980:	20 e0       	ldi	r18, 0x00	; 0
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	4a e7       	ldi	r20, 0x7A	; 122
    1986:	54 e4       	ldi	r21, 0x44	; 68
    1988:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    198c:	dc 01       	movw	r26, r24
    198e:	cb 01       	movw	r24, r22
    1990:	8c 87       	std	Y+12, r24	; 0x0c
    1992:	9d 87       	std	Y+13, r25	; 0x0d
    1994:	ae 87       	std	Y+14, r26	; 0x0e
    1996:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1998:	6c 85       	ldd	r22, Y+12	; 0x0c
    199a:	7d 85       	ldd	r23, Y+13	; 0x0d
    199c:	8e 85       	ldd	r24, Y+14	; 0x0e
    199e:	9f 85       	ldd	r25, Y+15	; 0x0f
    19a0:	20 e0       	ldi	r18, 0x00	; 0
    19a2:	30 e0       	ldi	r19, 0x00	; 0
    19a4:	4a ef       	ldi	r20, 0xFA	; 250
    19a6:	54 e4       	ldi	r21, 0x44	; 68
    19a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19ac:	dc 01       	movw	r26, r24
    19ae:	cb 01       	movw	r24, r22
    19b0:	88 87       	std	Y+8, r24	; 0x08
    19b2:	99 87       	std	Y+9, r25	; 0x09
    19b4:	aa 87       	std	Y+10, r26	; 0x0a
    19b6:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    19b8:	68 85       	ldd	r22, Y+8	; 0x08
    19ba:	79 85       	ldd	r23, Y+9	; 0x09
    19bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    19be:	9b 85       	ldd	r25, Y+11	; 0x0b
    19c0:	20 e0       	ldi	r18, 0x00	; 0
    19c2:	30 e0       	ldi	r19, 0x00	; 0
    19c4:	40 e8       	ldi	r20, 0x80	; 128
    19c6:	5f e3       	ldi	r21, 0x3F	; 63
    19c8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    19cc:	88 23       	and	r24, r24
    19ce:	2c f4       	brge	.+10     	; 0x19da <LCD_VoidInit+0x1c8>
		__ticks = 1;
    19d0:	81 e0       	ldi	r24, 0x01	; 1
    19d2:	90 e0       	ldi	r25, 0x00	; 0
    19d4:	9f 83       	std	Y+7, r25	; 0x07
    19d6:	8e 83       	std	Y+6, r24	; 0x06
    19d8:	3f c0       	rjmp	.+126    	; 0x1a58 <LCD_VoidInit+0x246>
	else if (__tmp > 65535)
    19da:	68 85       	ldd	r22, Y+8	; 0x08
    19dc:	79 85       	ldd	r23, Y+9	; 0x09
    19de:	8a 85       	ldd	r24, Y+10	; 0x0a
    19e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    19e2:	20 e0       	ldi	r18, 0x00	; 0
    19e4:	3f ef       	ldi	r19, 0xFF	; 255
    19e6:	4f e7       	ldi	r20, 0x7F	; 127
    19e8:	57 e4       	ldi	r21, 0x47	; 71
    19ea:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    19ee:	18 16       	cp	r1, r24
    19f0:	4c f5       	brge	.+82     	; 0x1a44 <LCD_VoidInit+0x232>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19f2:	6c 85       	ldd	r22, Y+12	; 0x0c
    19f4:	7d 85       	ldd	r23, Y+13	; 0x0d
    19f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    19f8:	9f 85       	ldd	r25, Y+15	; 0x0f
    19fa:	20 e0       	ldi	r18, 0x00	; 0
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	40 e2       	ldi	r20, 0x20	; 32
    1a00:	51 e4       	ldi	r21, 0x41	; 65
    1a02:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a06:	dc 01       	movw	r26, r24
    1a08:	cb 01       	movw	r24, r22
    1a0a:	bc 01       	movw	r22, r24
    1a0c:	cd 01       	movw	r24, r26
    1a0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a12:	dc 01       	movw	r26, r24
    1a14:	cb 01       	movw	r24, r22
    1a16:	9f 83       	std	Y+7, r25	; 0x07
    1a18:	8e 83       	std	Y+6, r24	; 0x06
    1a1a:	0f c0       	rjmp	.+30     	; 0x1a3a <LCD_VoidInit+0x228>
    1a1c:	88 ec       	ldi	r24, 0xC8	; 200
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	9d 83       	std	Y+5, r25	; 0x05
    1a22:	8c 83       	std	Y+4, r24	; 0x04
    1a24:	8c 81       	ldd	r24, Y+4	; 0x04
    1a26:	9d 81       	ldd	r25, Y+5	; 0x05
    1a28:	01 97       	sbiw	r24, 0x01	; 1
    1a2a:	f1 f7       	brne	.-4      	; 0x1a28 <LCD_VoidInit+0x216>
    1a2c:	9d 83       	std	Y+5, r25	; 0x05
    1a2e:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a30:	8e 81       	ldd	r24, Y+6	; 0x06
    1a32:	9f 81       	ldd	r25, Y+7	; 0x07
    1a34:	01 97       	sbiw	r24, 0x01	; 1
    1a36:	9f 83       	std	Y+7, r25	; 0x07
    1a38:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a3a:	8e 81       	ldd	r24, Y+6	; 0x06
    1a3c:	9f 81       	ldd	r25, Y+7	; 0x07
    1a3e:	00 97       	sbiw	r24, 0x00	; 0
    1a40:	69 f7       	brne	.-38     	; 0x1a1c <LCD_VoidInit+0x20a>
    1a42:	24 c0       	rjmp	.+72     	; 0x1a8c <LCD_VoidInit+0x27a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a44:	68 85       	ldd	r22, Y+8	; 0x08
    1a46:	79 85       	ldd	r23, Y+9	; 0x09
    1a48:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a4c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a50:	dc 01       	movw	r26, r24
    1a52:	cb 01       	movw	r24, r22
    1a54:	9f 83       	std	Y+7, r25	; 0x07
    1a56:	8e 83       	std	Y+6, r24	; 0x06
    1a58:	8e 81       	ldd	r24, Y+6	; 0x06
    1a5a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a5c:	9b 83       	std	Y+3, r25	; 0x03
    1a5e:	8a 83       	std	Y+2, r24	; 0x02
    1a60:	8a 81       	ldd	r24, Y+2	; 0x02
    1a62:	9b 81       	ldd	r25, Y+3	; 0x03
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <LCD_VoidInit+0x252>
    1a68:	9b 83       	std	Y+3, r25	; 0x03
    1a6a:	8a 83       	std	Y+2, r24	; 0x02
    1a6c:	0f c0       	rjmp	.+30     	; 0x1a8c <LCD_VoidInit+0x27a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1a6e:	69 89       	ldd	r22, Y+17	; 0x11
    1a70:	7a 89       	ldd	r23, Y+18	; 0x12
    1a72:	8b 89       	ldd	r24, Y+19	; 0x13
    1a74:	9c 89       	ldd	r25, Y+20	; 0x14
    1a76:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a7a:	dc 01       	movw	r26, r24
    1a7c:	cb 01       	movw	r24, r22
    1a7e:	88 8b       	std	Y+16, r24	; 0x10
    1a80:	88 89       	ldd	r24, Y+16	; 0x10
    1a82:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1a84:	89 81       	ldd	r24, Y+1	; 0x01
    1a86:	8a 95       	dec	r24
    1a88:	f1 f7       	brne	.-4      	; 0x1a86 <LCD_VoidInit+0x274>
    1a8a:	89 83       	std	Y+1, r24	; 0x01
	}
#endif

	_delay_us(50);
/*set ON/OFF Control |  Display :ON, Cursur:OFF ,Blink:OFF*/
	LCD_VoidSendCommand(0b00001100);
    1a8c:	8c e0       	ldi	r24, 0x0C	; 12
    1a8e:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>

	/* Display Clear */
	LCD_VoidSendCommand(0x01);
    1a92:	81 e0       	ldi	r24, 0x01	; 1
    1a94:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1a98:	a6 96       	adiw	r28, 0x26	; 38
    1a9a:	0f b6       	in	r0, 0x3f	; 63
    1a9c:	f8 94       	cli
    1a9e:	de bf       	out	0x3e, r29	; 62
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	cd bf       	out	0x3d, r28	; 61
    1aa4:	cf 91       	pop	r28
    1aa6:	df 91       	pop	r29
    1aa8:	08 95       	ret

00001aaa <LCD_VoidGoToPos>:



/*To go to defined position in the LCD */
void LCD_VoidGoToPos(u8 Copy_u8XPos,u8 Copy_u8YPos)
{
    1aaa:	df 93       	push	r29
    1aac:	cf 93       	push	r28
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <LCD_VoidGoToPos+0x6>
    1ab0:	0f 92       	push	r0
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
    1ab6:	8a 83       	std	Y+2, r24	; 0x02
    1ab8:	6b 83       	std	Y+3, r22	; 0x03
u8 Local_PositionAddress;
/*if the position in line1 the address is from  0 to 0x40 which is Y position */
	if(Copy_u8XPos==0)
    1aba:	8a 81       	ldd	r24, Y+2	; 0x02
    1abc:	88 23       	and	r24, r24
    1abe:	19 f4       	brne	.+6      	; 0x1ac6 <LCD_VoidGoToPos+0x1c>
	{
		Local_PositionAddress=Copy_u8YPos;
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	89 83       	std	Y+1, r24	; 0x01
    1ac4:	06 c0       	rjmp	.+12     	; 0x1ad2 <LCD_VoidGoToPos+0x28>

	}
	/*if the position in line2 the address is from  0x41 to 0x67 which is yposition+0x40 */
	else if(Copy_u8XPos==1)
    1ac6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac8:	81 30       	cpi	r24, 0x01	; 1
    1aca:	19 f4       	brne	.+6      	; 0x1ad2 <LCD_VoidGoToPos+0x28>
		{
			Local_PositionAddress=Copy_u8YPos+0x40;
    1acc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ace:	80 5c       	subi	r24, 0xC0	; 192
    1ad0:	89 83       	std	Y+1, r24	; 0x01

		}
	/*we set the register DDRAM with its command which in d.s the 8th bit is 1 and the rest of bits is address*/

	LCD_VoidSendCommand(1<<7 | Local_PositionAddress);
    1ad2:	89 81       	ldd	r24, Y+1	; 0x01
    1ad4:	80 68       	ori	r24, 0x80	; 128
    1ad6:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1ada:	0f 90       	pop	r0
    1adc:	0f 90       	pop	r0
    1ade:	0f 90       	pop	r0
    1ae0:	cf 91       	pop	r28
    1ae2:	df 91       	pop	r29
    1ae4:	08 95       	ret

00001ae6 <LCD_VoidClearDisplay>:


/*To clear the LCD*/
void LCD_VoidClearDisplay(void)
{
    1ae6:	df 93       	push	r29
    1ae8:	cf 93       	push	r28
    1aea:	cd b7       	in	r28, 0x3d	; 61
    1aec:	de b7       	in	r29, 0x3e	; 62
	 Global_u8Clear=1;
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	80 93 84 01 	sts	0x0184, r24
	LCD_VoidSendCommand(1);
    1af4:	81 e0       	ldi	r24, 0x01	; 1
    1af6:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1afa:	cf 91       	pop	r28
    1afc:	df 91       	pop	r29
    1afe:	08 95       	ret

00001b00 <LCD_VoidCursorON>:
void LCD_VoidCursorON(void)
{
    1b00:	df 93       	push	r29
    1b02:	cf 93       	push	r28
    1b04:	cd b7       	in	r28, 0x3d	; 61
    1b06:	de b7       	in	r29, 0x3e	; 62
	LCD_VoidSendCommand(SOLID_CURSOR);
    1b08:	8e e0       	ldi	r24, 0x0E	; 14
    1b0a:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1b0e:	cf 91       	pop	r28
    1b10:	df 91       	pop	r29
    1b12:	08 95       	ret

00001b14 <LCD_VoidCursorOFF>:
void LCD_VoidCursorOFF()
{
    1b14:	df 93       	push	r29
    1b16:	cf 93       	push	r28
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
	LCD_VoidSendCommand(CURSOR_OFF);
    1b1c:	8c e0       	ldi	r24, 0x0C	; 12
    1b1e:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1b22:	cf 91       	pop	r28
    1b24:	df 91       	pop	r29
    1b26:	08 95       	ret

00001b28 <LCD_VoidBlinkingCursorON>:
void LCD_VoidBlinkingCursorON(void)
{
    1b28:	df 93       	push	r29
    1b2a:	cf 93       	push	r28
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
	LCD_VoidSendCommand(BLINK_CURSOR);
    1b30:	8f e0       	ldi	r24, 0x0F	; 15
    1b32:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1b36:	cf 91       	pop	r28
    1b38:	df 91       	pop	r29
    1b3a:	08 95       	ret

00001b3c <LCD_VoidDisplayON>:

void LCD_VoidDisplayON(void)
{
    1b3c:	df 93       	push	r29
    1b3e:	cf 93       	push	r28
    1b40:	cd b7       	in	r28, 0x3d	; 61
    1b42:	de b7       	in	r29, 0x3e	; 62
	LCD_VoidSendCommand(DISPLAY_ON);
    1b44:	8c e0       	ldi	r24, 0x0C	; 12
    1b46:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1b4a:	cf 91       	pop	r28
    1b4c:	df 91       	pop	r29
    1b4e:	08 95       	ret

00001b50 <LCD_VoidDisplayOFF>:
void LCD_VoidDisplayOFF(void)
{
    1b50:	df 93       	push	r29
    1b52:	cf 93       	push	r28
    1b54:	cd b7       	in	r28, 0x3d	; 61
    1b56:	de b7       	in	r29, 0x3e	; 62
	LCD_VoidSendCommand(DISPLAY_OFF);
    1b58:	88 e0       	ldi	r24, 0x08	; 8
    1b5a:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>
}
    1b5e:	cf 91       	pop	r28
    1b60:	df 91       	pop	r29
    1b62:	08 95       	ret

00001b64 <LCD_VoidShiftLeft>:


/*to shift the words left from defined position*/
void LCD_VoidShiftLeft(u8 Copy_u8ShiftNumber,u8 Copy_u8XPos,u8 Copy_u8YPos)
{
    1b64:	df 93       	push	r29
    1b66:	cf 93       	push	r28
    1b68:	00 d0       	rcall	.+0      	; 0x1b6a <LCD_VoidShiftLeft+0x6>
    1b6a:	00 d0       	rcall	.+0      	; 0x1b6c <LCD_VoidShiftLeft+0x8>
    1b6c:	cd b7       	in	r28, 0x3d	; 61
    1b6e:	de b7       	in	r29, 0x3e	; 62
    1b70:	8a 83       	std	Y+2, r24	; 0x02
    1b72:	6b 83       	std	Y+3, r22	; 0x03
    1b74:	4c 83       	std	Y+4, r20	; 0x04
	s8 Local_ShiftIterator=0;
    1b76:	19 82       	std	Y+1, r1	; 0x01
	for(Local_ShiftIterator=Copy_u8YPos ; Local_ShiftIterator>Copy_u8YPos-Copy_u8ShiftNumber ;Local_ShiftIterator--)
    1b78:	8c 81       	ldd	r24, Y+4	; 0x04
    1b7a:	89 83       	std	Y+1, r24	; 0x01
    1b7c:	0b c0       	rjmp	.+22     	; 0x1b94 <LCD_VoidShiftLeft+0x30>
	{
		LCD_VoidGoToPos(Copy_u8XPos,Local_ShiftIterator);
    1b7e:	99 81       	ldd	r25, Y+1	; 0x01
    1b80:	8b 81       	ldd	r24, Y+3	; 0x03
    1b82:	69 2f       	mov	r22, r25
    1b84:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <LCD_VoidGoToPos>
		LCD_VoidSendData(' ');
    1b88:	80 e2       	ldi	r24, 0x20	; 32
    1b8a:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>

/*to shift the words left from defined position*/
void LCD_VoidShiftLeft(u8 Copy_u8ShiftNumber,u8 Copy_u8XPos,u8 Copy_u8YPos)
{
	s8 Local_ShiftIterator=0;
	for(Local_ShiftIterator=Copy_u8YPos ; Local_ShiftIterator>Copy_u8YPos-Copy_u8ShiftNumber ;Local_ShiftIterator--)
    1b8e:	89 81       	ldd	r24, Y+1	; 0x01
    1b90:	81 50       	subi	r24, 0x01	; 1
    1b92:	89 83       	std	Y+1, r24	; 0x01
    1b94:	89 81       	ldd	r24, Y+1	; 0x01
    1b96:	48 2f       	mov	r20, r24
    1b98:	55 27       	eor	r21, r21
    1b9a:	47 fd       	sbrc	r20, 7
    1b9c:	50 95       	com	r21
    1b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba0:	28 2f       	mov	r18, r24
    1ba2:	30 e0       	ldi	r19, 0x00	; 0
    1ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba6:	88 2f       	mov	r24, r24
    1ba8:	90 e0       	ldi	r25, 0x00	; 0
    1baa:	b9 01       	movw	r22, r18
    1bac:	68 1b       	sub	r22, r24
    1bae:	79 0b       	sbc	r23, r25
    1bb0:	cb 01       	movw	r24, r22
    1bb2:	84 17       	cp	r24, r20
    1bb4:	95 07       	cpc	r25, r21
    1bb6:	1c f3       	brlt	.-58     	; 0x1b7e <LCD_VoidShiftLeft+0x1a>
	{
		LCD_VoidGoToPos(Copy_u8XPos,Local_ShiftIterator);
		LCD_VoidSendData(' ');
	}
}
    1bb8:	0f 90       	pop	r0
    1bba:	0f 90       	pop	r0
    1bbc:	0f 90       	pop	r0
    1bbe:	0f 90       	pop	r0
    1bc0:	cf 91       	pop	r28
    1bc2:	df 91       	pop	r29
    1bc4:	08 95       	ret

00001bc6 <LCD_VoidShiftRight>:
/*to shift the words Right from defined position*/
void LCD_VoidShiftRight(u8 Copy_u8ShiftNumber,u8 Copy_u8XPos,u8 Copy_u8YPos)
{
    1bc6:	df 93       	push	r29
    1bc8:	cf 93       	push	r28
    1bca:	00 d0       	rcall	.+0      	; 0x1bcc <LCD_VoidShiftRight+0x6>
    1bcc:	00 d0       	rcall	.+0      	; 0x1bce <LCD_VoidShiftRight+0x8>
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	8a 83       	std	Y+2, r24	; 0x02
    1bd4:	6b 83       	std	Y+3, r22	; 0x03
    1bd6:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_ShiftIterator=0;
    1bd8:	19 82       	std	Y+1, r1	; 0x01
	for(Local_ShiftIterator=Copy_u8YPos ; Local_ShiftIterator<Copy_u8YPos+Copy_u8ShiftNumber ;Local_ShiftIterator++)
    1bda:	8c 81       	ldd	r24, Y+4	; 0x04
    1bdc:	89 83       	std	Y+1, r24	; 0x01
    1bde:	0a c0       	rjmp	.+20     	; 0x1bf4 <LCD_VoidShiftRight+0x2e>
	{
		LCD_VoidGoToPos(Copy_u8XPos,Local_ShiftIterator);
    1be0:	8b 81       	ldd	r24, Y+3	; 0x03
    1be2:	69 81       	ldd	r22, Y+1	; 0x01
    1be4:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <LCD_VoidGoToPos>
		LCD_VoidSendData(' ');
    1be8:	80 e2       	ldi	r24, 0x20	; 32
    1bea:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>
}
/*to shift the words Right from defined position*/
void LCD_VoidShiftRight(u8 Copy_u8ShiftNumber,u8 Copy_u8XPos,u8 Copy_u8YPos)
{
	u8 Local_ShiftIterator=0;
	for(Local_ShiftIterator=Copy_u8YPos ; Local_ShiftIterator<Copy_u8YPos+Copy_u8ShiftNumber ;Local_ShiftIterator++)
    1bee:	89 81       	ldd	r24, Y+1	; 0x01
    1bf0:	8f 5f       	subi	r24, 0xFF	; 255
    1bf2:	89 83       	std	Y+1, r24	; 0x01
    1bf4:	89 81       	ldd	r24, Y+1	; 0x01
    1bf6:	48 2f       	mov	r20, r24
    1bf8:	50 e0       	ldi	r21, 0x00	; 0
    1bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    1bfc:	28 2f       	mov	r18, r24
    1bfe:	30 e0       	ldi	r19, 0x00	; 0
    1c00:	8a 81       	ldd	r24, Y+2	; 0x02
    1c02:	88 2f       	mov	r24, r24
    1c04:	90 e0       	ldi	r25, 0x00	; 0
    1c06:	82 0f       	add	r24, r18
    1c08:	93 1f       	adc	r25, r19
    1c0a:	48 17       	cp	r20, r24
    1c0c:	59 07       	cpc	r21, r25
    1c0e:	44 f3       	brlt	.-48     	; 0x1be0 <LCD_VoidShiftRight+0x1a>
	{
		LCD_VoidGoToPos(Copy_u8XPos,Local_ShiftIterator);
		LCD_VoidSendData(' ');
	}
}
    1c10:	0f 90       	pop	r0
    1c12:	0f 90       	pop	r0
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
    1c18:	cf 91       	pop	r28
    1c1a:	df 91       	pop	r29
    1c1c:	08 95       	ret

00001c1e <LCD_VoidSendNumber>:
/*to convert ascii char to integer*/

void LCD_VoidSendNumber(u32 Copy_u32Char)
{
    1c1e:	df 93       	push	r29
    1c20:	cf 93       	push	r28
    1c22:	cd b7       	in	r28, 0x3d	; 61
    1c24:	de b7       	in	r29, 0x3e	; 62
    1c26:	68 97       	sbiw	r28, 0x18	; 24
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	f8 94       	cli
    1c2c:	de bf       	out	0x3e, r29	; 62
    1c2e:	0f be       	out	0x3f, r0	; 63
    1c30:	cd bf       	out	0x3d, r28	; 61
    1c32:	98 8f       	std	Y+24, r25	; 0x18
    1c34:	8f 8b       	std	Y+23, r24	; 0x17
u8 Local_Char_Converted[16];
u32  Local_Temp=Copy_u32Char;
    1c36:	8f 89       	ldd	r24, Y+23	; 0x17
    1c38:	98 8d       	ldd	r25, Y+24	; 0x18
    1c3a:	9e 83       	std	Y+6, r25	; 0x06
    1c3c:	8d 83       	std	Y+5, r24	; 0x05
u8 Counter=0;
    1c3e:	1c 82       	std	Y+4, r1	; 0x04
    1c40:	0d c0       	rjmp	.+26     	; 0x1c5c <LCD_VoidSendNumber+0x3e>
while(Local_Temp>=1)
{
    Counter++;
    1c42:	8c 81       	ldd	r24, Y+4	; 0x04
    1c44:	8f 5f       	subi	r24, 0xFF	; 255
    1c46:	8c 83       	std	Y+4, r24	; 0x04
    Local_Temp/=10;
    1c48:	8d 81       	ldd	r24, Y+5	; 0x05
    1c4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c4c:	2a e0       	ldi	r18, 0x0A	; 10
    1c4e:	30 e0       	ldi	r19, 0x00	; 0
    1c50:	b9 01       	movw	r22, r18
    1c52:	0e 94 91 22 	call	0x4522	; 0x4522 <__udivmodhi4>
    1c56:	cb 01       	movw	r24, r22
    1c58:	9e 83       	std	Y+6, r25	; 0x06
    1c5a:	8d 83       	std	Y+5, r24	; 0x05
void LCD_VoidSendNumber(u32 Copy_u32Char)
{
u8 Local_Char_Converted[16];
u32  Local_Temp=Copy_u32Char;
u8 Counter=0;
while(Local_Temp>=1)
    1c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c5e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c60:	00 97       	sbiw	r24, 0x00	; 0
    1c62:	79 f7       	brne	.-34     	; 0x1c42 <LCD_VoidSendNumber+0x24>
{
    Counter++;
    Local_Temp/=10;
}
Local_Temp=Copy_u32Char;
    1c64:	8f 89       	ldd	r24, Y+23	; 0x17
    1c66:	98 8d       	ldd	r25, Y+24	; 0x18
    1c68:	9e 83       	std	Y+6, r25	; 0x06
    1c6a:	8d 83       	std	Y+5, r24	; 0x05

	for(u8 i=0;i<Counter;i++)
    1c6c:	1b 82       	std	Y+3, r1	; 0x03
    1c6e:	1e c0       	rjmp	.+60     	; 0x1cac <LCD_VoidSendNumber+0x8e>
		{

			Local_Char_Converted[i]=Local_Temp%10+'0';
    1c70:	8b 81       	ldd	r24, Y+3	; 0x03
    1c72:	e8 2f       	mov	r30, r24
    1c74:	f0 e0       	ldi	r31, 0x00	; 0
    1c76:	8d 81       	ldd	r24, Y+5	; 0x05
    1c78:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7a:	2a e0       	ldi	r18, 0x0A	; 10
    1c7c:	30 e0       	ldi	r19, 0x00	; 0
    1c7e:	b9 01       	movw	r22, r18
    1c80:	0e 94 91 22 	call	0x4522	; 0x4522 <__udivmodhi4>
    1c84:	28 2f       	mov	r18, r24
    1c86:	20 5d       	subi	r18, 0xD0	; 208
    1c88:	ce 01       	movw	r24, r28
    1c8a:	07 96       	adiw	r24, 0x07	; 7
    1c8c:	e8 0f       	add	r30, r24
    1c8e:	f9 1f       	adc	r31, r25
    1c90:	20 83       	st	Z, r18

			Local_Temp/=10;
    1c92:	8d 81       	ldd	r24, Y+5	; 0x05
    1c94:	9e 81       	ldd	r25, Y+6	; 0x06
    1c96:	2a e0       	ldi	r18, 0x0A	; 10
    1c98:	30 e0       	ldi	r19, 0x00	; 0
    1c9a:	b9 01       	movw	r22, r18
    1c9c:	0e 94 91 22 	call	0x4522	; 0x4522 <__udivmodhi4>
    1ca0:	cb 01       	movw	r24, r22
    1ca2:	9e 83       	std	Y+6, r25	; 0x06
    1ca4:	8d 83       	std	Y+5, r24	; 0x05
    Counter++;
    Local_Temp/=10;
}
Local_Temp=Copy_u32Char;

	for(u8 i=0;i<Counter;i++)
    1ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca8:	8f 5f       	subi	r24, 0xFF	; 255
    1caa:	8b 83       	std	Y+3, r24	; 0x03
    1cac:	9b 81       	ldd	r25, Y+3	; 0x03
    1cae:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb0:	98 17       	cp	r25, r24
    1cb2:	f0 f2       	brcs	.-68     	; 0x1c70 <LCD_VoidSendNumber+0x52>
			Local_Char_Converted[i]=Local_Temp%10+'0';

			Local_Temp/=10;
		}

	for (int i = Counter-1; i >=0 ; i--)
    1cb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cb6:	88 2f       	mov	r24, r24
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	01 97       	sbiw	r24, 0x01	; 1
    1cbc:	9a 83       	std	Y+2, r25	; 0x02
    1cbe:	89 83       	std	Y+1, r24	; 0x01
    1cc0:	0f c0       	rjmp	.+30     	; 0x1ce0 <LCD_VoidSendNumber+0xc2>
		{
			LCD_VoidSendData(Local_Char_Converted[i]);
    1cc2:	29 81       	ldd	r18, Y+1	; 0x01
    1cc4:	3a 81       	ldd	r19, Y+2	; 0x02
    1cc6:	ce 01       	movw	r24, r28
    1cc8:	07 96       	adiw	r24, 0x07	; 7
    1cca:	fc 01       	movw	r30, r24
    1ccc:	e2 0f       	add	r30, r18
    1cce:	f3 1f       	adc	r31, r19
    1cd0:	80 81       	ld	r24, Z
    1cd2:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>
			Local_Char_Converted[i]=Local_Temp%10+'0';

			Local_Temp/=10;
		}

	for (int i = Counter-1; i >=0 ; i--)
    1cd6:	89 81       	ldd	r24, Y+1	; 0x01
    1cd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1cda:	01 97       	sbiw	r24, 0x01	; 1
    1cdc:	9a 83       	std	Y+2, r25	; 0x02
    1cde:	89 83       	std	Y+1, r24	; 0x01
    1ce0:	89 81       	ldd	r24, Y+1	; 0x01
    1ce2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce4:	99 23       	and	r25, r25
    1ce6:	6c f7       	brge	.-38     	; 0x1cc2 <LCD_VoidSendNumber+0xa4>
		{
			LCD_VoidSendData(Local_Char_Converted[i]);
		}


}
    1ce8:	68 96       	adiw	r28, 0x18	; 24
    1cea:	0f b6       	in	r0, 0x3f	; 63
    1cec:	f8 94       	cli
    1cee:	de bf       	out	0x3e, r29	; 62
    1cf0:	0f be       	out	0x3f, r0	; 63
    1cf2:	cd bf       	out	0x3d, r28	; 61
    1cf4:	cf 91       	pop	r28
    1cf6:	df 91       	pop	r29
    1cf8:	08 95       	ret

00001cfa <LCD_VoidSendString>:


void LCD_VoidSendString( const u8* Copy_PtString)
{u8 Local_Counter=0;
    1cfa:	df 93       	push	r29
    1cfc:	cf 93       	push	r28
    1cfe:	00 d0       	rcall	.+0      	; 0x1d00 <LCD_VoidSendString+0x6>
    1d00:	0f 92       	push	r0
    1d02:	cd b7       	in	r28, 0x3d	; 61
    1d04:	de b7       	in	r29, 0x3e	; 62
    1d06:	9b 83       	std	Y+3, r25	; 0x03
    1d08:	8a 83       	std	Y+2, r24	; 0x02
    1d0a:	19 82       	std	Y+1, r1	; 0x01
    1d0c:	0e c0       	rjmp	.+28     	; 0x1d2a <LCD_VoidSendString+0x30>

    while(Copy_PtString[Local_Counter]!='\0')
    {

    	LCD_VoidSendData(Copy_PtString[Local_Counter]);
    1d0e:	89 81       	ldd	r24, Y+1	; 0x01
    1d10:	28 2f       	mov	r18, r24
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	8a 81       	ldd	r24, Y+2	; 0x02
    1d16:	9b 81       	ldd	r25, Y+3	; 0x03
    1d18:	fc 01       	movw	r30, r24
    1d1a:	e2 0f       	add	r30, r18
    1d1c:	f3 1f       	adc	r31, r19
    1d1e:	80 81       	ld	r24, Z
    1d20:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>
    	Local_Counter++;
    1d24:	89 81       	ldd	r24, Y+1	; 0x01
    1d26:	8f 5f       	subi	r24, 0xFF	; 255
    1d28:	89 83       	std	Y+1, r24	; 0x01


void LCD_VoidSendString( const u8* Copy_PtString)
{u8 Local_Counter=0;

    while(Copy_PtString[Local_Counter]!='\0')
    1d2a:	89 81       	ldd	r24, Y+1	; 0x01
    1d2c:	28 2f       	mov	r18, r24
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	8a 81       	ldd	r24, Y+2	; 0x02
    1d32:	9b 81       	ldd	r25, Y+3	; 0x03
    1d34:	fc 01       	movw	r30, r24
    1d36:	e2 0f       	add	r30, r18
    1d38:	f3 1f       	adc	r31, r19
    1d3a:	80 81       	ld	r24, Z
    1d3c:	88 23       	and	r24, r24
    1d3e:	39 f7       	brne	.-50     	; 0x1d0e <LCD_VoidSendString+0x14>

    	LCD_VoidSendData(Copy_PtString[Local_Counter]);
    	Local_Counter++;
    }

}
    1d40:	0f 90       	pop	r0
    1d42:	0f 90       	pop	r0
    1d44:	0f 90       	pop	r0
    1d46:	cf 91       	pop	r28
    1d48:	df 91       	pop	r29
    1d4a:	08 95       	ret

00001d4c <LCD_VoidCreateSpecialChar>:


void LCD_VoidCreateSpecialChar(const u8 *Copy_PcDataPattern,u8 Copy_u8BlockNo,u8 Copy_u8XPos,u8 Copy_u8YPos)

{
    1d4c:	df 93       	push	r29
    1d4e:	cf 93       	push	r28
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
    1d54:	27 97       	sbiw	r28, 0x07	; 7
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	de bf       	out	0x3e, r29	; 62
    1d5c:	0f be       	out	0x3f, r0	; 63
    1d5e:	cd bf       	out	0x3d, r28	; 61
    1d60:	9c 83       	std	Y+4, r25	; 0x04
    1d62:	8b 83       	std	Y+3, r24	; 0x03
    1d64:	6d 83       	std	Y+5, r22	; 0x05
    1d66:	4e 83       	std	Y+6, r20	; 0x06
    1d68:	2f 83       	std	Y+7, r18	; 0x07
	/*calculating the address of CGRAM which is 64 byte for 8 locations */
u8 Local_u8CGRAMAddress=8*Copy_u8BlockNo;
    1d6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d6c:	88 2f       	mov	r24, r24
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	88 0f       	add	r24, r24
    1d72:	99 1f       	adc	r25, r25
    1d74:	88 0f       	add	r24, r24
    1d76:	99 1f       	adc	r25, r25
    1d78:	88 0f       	add	r24, r24
    1d7a:	99 1f       	adc	r25, r25
    1d7c:	8a 83       	std	Y+2, r24	; 0x02

/*for counting in for loop*/
u8 Local_u8Iterator=0;
    1d7e:	19 82       	std	Y+1, r1	; 0x01

/*Send CGRAM Address as command to LCD ,Setting bit 6,clearing bit 7 */
LCD_VoidSendCommand(1<<6 |Local_u8CGRAMAddress);
    1d80:	8a 81       	ldd	r24, Y+2	; 0x02
    1d82:	80 64       	ori	r24, 0x40	; 64
    1d84:	0e 94 b8 0a 	call	0x1570	; 0x1570 <LCD_VoidSendCommand>

/*Send Data(our pattern) in CGRAM in the address chosen above*/
 for(Local_u8Iterator=0;Local_u8Iterator<8;Local_u8Iterator++)
    1d88:	19 82       	std	Y+1, r1	; 0x01
    1d8a:	0e c0       	rjmp	.+28     	; 0x1da8 <LCD_VoidCreateSpecialChar+0x5c>
	{
	 LCD_VoidSendData(Copy_PcDataPattern[Local_u8Iterator]);
    1d8c:	89 81       	ldd	r24, Y+1	; 0x01
    1d8e:	28 2f       	mov	r18, r24
    1d90:	30 e0       	ldi	r19, 0x00	; 0
    1d92:	8b 81       	ldd	r24, Y+3	; 0x03
    1d94:	9c 81       	ldd	r25, Y+4	; 0x04
    1d96:	fc 01       	movw	r30, r24
    1d98:	e2 0f       	add	r30, r18
    1d9a:	f3 1f       	adc	r31, r19
    1d9c:	80 81       	ld	r24, Z
    1d9e:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>

/*Send CGRAM Address as command to LCD ,Setting bit 6,clearing bit 7 */
LCD_VoidSendCommand(1<<6 |Local_u8CGRAMAddress);

/*Send Data(our pattern) in CGRAM in the address chosen above*/
 for(Local_u8Iterator=0;Local_u8Iterator<8;Local_u8Iterator++)
    1da2:	89 81       	ldd	r24, Y+1	; 0x01
    1da4:	8f 5f       	subi	r24, 0xFF	; 255
    1da6:	89 83       	std	Y+1, r24	; 0x01
    1da8:	89 81       	ldd	r24, Y+1	; 0x01
    1daa:	88 30       	cpi	r24, 0x08	; 8
    1dac:	78 f3       	brcs	.-34     	; 0x1d8c <LCD_VoidCreateSpecialChar+0x40>
	{
	 LCD_VoidSendData(Copy_PcDataPattern[Local_u8Iterator]);
	}
 /*choose the position in LCD display*/
 LCD_VoidGoToPos(Copy_u8XPos, Copy_u8YPos);
    1dae:	8e 81       	ldd	r24, Y+6	; 0x06
    1db0:	6f 81       	ldd	r22, Y+7	; 0x07
    1db2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <LCD_VoidGoToPos>

 /*Sending data to display LCD which were written in GCRAM ,it take the location of address and take the whole block from Copy_u8BlockNo*8 to Copy_u8BlockNo*8+8*/
 LCD_VoidSendData(Copy_u8BlockNo);
    1db6:	8d 81       	ldd	r24, Y+5	; 0x05
    1db8:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>
}
    1dbc:	27 96       	adiw	r28, 0x07	; 7
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	cf 91       	pop	r28
    1dca:	df 91       	pop	r29
    1dcc:	08 95       	ret

00001dce <LCD_VoidSendFloatNumber>:

void LCD_VoidSendFloatNumber(f64 Copy_f64Data)
{
    1dce:	df 93       	push	r29
    1dd0:	cf 93       	push	r28
    1dd2:	00 d0       	rcall	.+0      	; 0x1dd4 <LCD_VoidSendFloatNumber+0x6>
    1dd4:	00 d0       	rcall	.+0      	; 0x1dd6 <LCD_VoidSendFloatNumber+0x8>
    1dd6:	00 d0       	rcall	.+0      	; 0x1dd8 <LCD_VoidSendFloatNumber+0xa>
    1dd8:	cd b7       	in	r28, 0x3d	; 61
    1dda:	de b7       	in	r29, 0x3e	; 62
    1ddc:	6b 83       	std	Y+3, r22	; 0x03
    1dde:	7c 83       	std	Y+4, r23	; 0x04
    1de0:	8d 83       	std	Y+5, r24	; 0x05
    1de2:	9e 83       	std	Y+6, r25	; 0x06

	u32 DecimalNum=100000*(Copy_f64Data-(u32)Copy_f64Data);
    1de4:	6b 81       	ldd	r22, Y+3	; 0x03
    1de6:	7c 81       	ldd	r23, Y+4	; 0x04
    1de8:	8d 81       	ldd	r24, Y+5	; 0x05
    1dea:	9e 81       	ldd	r25, Y+6	; 0x06
    1dec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1df0:	dc 01       	movw	r26, r24
    1df2:	cb 01       	movw	r24, r22
    1df4:	cc 01       	movw	r24, r24
    1df6:	a0 e0       	ldi	r26, 0x00	; 0
    1df8:	b0 e0       	ldi	r27, 0x00	; 0
    1dfa:	bc 01       	movw	r22, r24
    1dfc:	cd 01       	movw	r24, r26
    1dfe:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1e02:	9b 01       	movw	r18, r22
    1e04:	ac 01       	movw	r20, r24
    1e06:	6b 81       	ldd	r22, Y+3	; 0x03
    1e08:	7c 81       	ldd	r23, Y+4	; 0x04
    1e0a:	8d 81       	ldd	r24, Y+5	; 0x05
    1e0c:	9e 81       	ldd	r25, Y+6	; 0x06
    1e0e:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    1e12:	dc 01       	movw	r26, r24
    1e14:	cb 01       	movw	r24, r22
    1e16:	bc 01       	movw	r22, r24
    1e18:	cd 01       	movw	r24, r26
    1e1a:	20 e0       	ldi	r18, 0x00	; 0
    1e1c:	30 e5       	ldi	r19, 0x50	; 80
    1e1e:	43 ec       	ldi	r20, 0xC3	; 195
    1e20:	57 e4       	ldi	r21, 0x47	; 71
    1e22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e26:	dc 01       	movw	r26, r24
    1e28:	cb 01       	movw	r24, r22
    1e2a:	bc 01       	movw	r22, r24
    1e2c:	cd 01       	movw	r24, r26
    1e2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e32:	dc 01       	movw	r26, r24
    1e34:	cb 01       	movw	r24, r22
    1e36:	9a 83       	std	Y+2, r25	; 0x02
    1e38:	89 83       	std	Y+1, r24	; 0x01
	LCD_VoidSendNumber(Copy_f64Data);
    1e3a:	6b 81       	ldd	r22, Y+3	; 0x03
    1e3c:	7c 81       	ldd	r23, Y+4	; 0x04
    1e3e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e40:	9e 81       	ldd	r25, Y+6	; 0x06
    1e42:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e46:	dc 01       	movw	r26, r24
    1e48:	cb 01       	movw	r24, r22
    1e4a:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <LCD_VoidSendNumber>
	LCD_VoidSendData('.');
    1e4e:	8e e2       	ldi	r24, 0x2E	; 46
    1e50:	0e 94 56 0b 	call	0x16ac	; 0x16ac <LCD_VoidSendData>
	LCD_VoidSendNumber(DecimalNum);
    1e54:	89 81       	ldd	r24, Y+1	; 0x01
    1e56:	9a 81       	ldd	r25, Y+2	; 0x02
    1e58:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <LCD_VoidSendNumber>



}
    1e5c:	26 96       	adiw	r28, 0x06	; 6
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	f8 94       	cli
    1e62:	de bf       	out	0x3e, r29	; 62
    1e64:	0f be       	out	0x3f, r0	; 63
    1e66:	cd bf       	out	0x3d, r28	; 61
    1e68:	cf 91       	pop	r28
    1e6a:	df 91       	pop	r29
    1e6c:	08 95       	ret

00001e6e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1e6e:	df 93       	push	r29
    1e70:	cf 93       	push	r28
    1e72:	cd b7       	in	r28, 0x3d	; 61
    1e74:	de b7       	in	r29, 0x3e	; 62
    1e76:	27 97       	sbiw	r28, 0x07	; 7
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	de bf       	out	0x3e, r29	; 62
    1e7e:	0f be       	out	0x3f, r0	; 63
    1e80:	cd bf       	out	0x3d, r28	; 61
    1e82:	9d 83       	std	Y+5, r25	; 0x05
    1e84:	8c 83       	std	Y+4, r24	; 0x04
    1e86:	6e 83       	std	Y+6, r22	; 0x06
    1e88:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1e8a:	8a e1       	ldi	r24, 0x1A	; 26
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	0e 94 0f 12 	call	0x241e	; 0x241e <pvPortMalloc>
    1e92:	9a 83       	std	Y+2, r25	; 0x02
    1e94:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1e96:	89 81       	ldd	r24, Y+1	; 0x01
    1e98:	9a 81       	ldd	r25, Y+2	; 0x02
    1e9a:	00 97       	sbiw	r24, 0x00	; 0
    1e9c:	09 f4       	brne	.+2      	; 0x1ea0 <xCoRoutineCreate+0x32>
    1e9e:	6f c0       	rjmp	.+222    	; 0x1f7e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1ea0:	80 91 86 01 	lds	r24, 0x0186
    1ea4:	90 91 87 01 	lds	r25, 0x0187
    1ea8:	00 97       	sbiw	r24, 0x00	; 0
    1eaa:	41 f4       	brne	.+16     	; 0x1ebc <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1eac:	89 81       	ldd	r24, Y+1	; 0x01
    1eae:	9a 81       	ldd	r25, Y+2	; 0x02
    1eb0:	90 93 87 01 	sts	0x0187, r25
    1eb4:	80 93 86 01 	sts	0x0186, r24
			prvInitialiseCoRoutineLists();
    1eb8:	0e 94 9e 11 	call	0x233c	; 0x233c <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1ebc:	8e 81       	ldd	r24, Y+6	; 0x06
    1ebe:	82 30       	cpi	r24, 0x02	; 2
    1ec0:	10 f0       	brcs	.+4      	; 0x1ec6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eca:	11 8e       	std	Z+25, r1	; 0x19
    1ecc:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1ece:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ed4:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eda:	8f 81       	ldd	r24, Y+7	; 0x07
    1edc:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1ede:	e9 81       	ldd	r30, Y+1	; 0x01
    1ee0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ee2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ee4:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee6:	91 83       	std	Z+1, r25	; 0x01
    1ee8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1eea:	89 81       	ldd	r24, Y+1	; 0x01
    1eec:	9a 81       	ldd	r25, Y+2	; 0x02
    1eee:	02 96       	adiw	r24, 0x02	; 2
    1ef0:	0e 94 a5 12 	call	0x254a	; 0x254a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1ef4:	89 81       	ldd	r24, Y+1	; 0x01
    1ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef8:	0c 96       	adiw	r24, 0x0c	; 12
    1efa:	0e 94 a5 12 	call	0x254a	; 0x254a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1efe:	e9 81       	ldd	r30, Y+1	; 0x01
    1f00:	fa 81       	ldd	r31, Y+2	; 0x02
    1f02:	89 81       	ldd	r24, Y+1	; 0x01
    1f04:	9a 81       	ldd	r25, Y+2	; 0x02
    1f06:	91 87       	std	Z+9, r25	; 0x09
    1f08:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0e:	89 81       	ldd	r24, Y+1	; 0x01
    1f10:	9a 81       	ldd	r25, Y+2	; 0x02
    1f12:	93 8b       	std	Z+19, r25	; 0x13
    1f14:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1f16:	8e 81       	ldd	r24, Y+6	; 0x06
    1f18:	28 2f       	mov	r18, r24
    1f1a:	30 e0       	ldi	r19, 0x00	; 0
    1f1c:	85 e0       	ldi	r24, 0x05	; 5
    1f1e:	90 e0       	ldi	r25, 0x00	; 0
    1f20:	82 1b       	sub	r24, r18
    1f22:	93 0b       	sbc	r25, r19
    1f24:	e9 81       	ldd	r30, Y+1	; 0x01
    1f26:	fa 81       	ldd	r31, Y+2	; 0x02
    1f28:	95 87       	std	Z+13, r25	; 0x0d
    1f2a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f30:	96 89       	ldd	r25, Z+22	; 0x16
    1f32:	80 91 88 01 	lds	r24, 0x0188
    1f36:	89 17       	cp	r24, r25
    1f38:	28 f4       	brcc	.+10     	; 0x1f44 <xCoRoutineCreate+0xd6>
    1f3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3e:	86 89       	ldd	r24, Z+22	; 0x16
    1f40:	80 93 88 01 	sts	0x0188, r24
    1f44:	e9 81       	ldd	r30, Y+1	; 0x01
    1f46:	fa 81       	ldd	r31, Y+2	; 0x02
    1f48:	86 89       	ldd	r24, Z+22	; 0x16
    1f4a:	28 2f       	mov	r18, r24
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	c9 01       	movw	r24, r18
    1f50:	88 0f       	add	r24, r24
    1f52:	99 1f       	adc	r25, r25
    1f54:	88 0f       	add	r24, r24
    1f56:	99 1f       	adc	r25, r25
    1f58:	88 0f       	add	r24, r24
    1f5a:	99 1f       	adc	r25, r25
    1f5c:	82 0f       	add	r24, r18
    1f5e:	93 1f       	adc	r25, r19
    1f60:	ac 01       	movw	r20, r24
    1f62:	41 57       	subi	r20, 0x71	; 113
    1f64:	5e 4f       	sbci	r21, 0xFE	; 254
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6a:	9c 01       	movw	r18, r24
    1f6c:	2e 5f       	subi	r18, 0xFE	; 254
    1f6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f70:	ca 01       	movw	r24, r20
    1f72:	b9 01       	movw	r22, r18
    1f74:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>

		xReturn = pdPASS;
    1f78:	81 e0       	ldi	r24, 0x01	; 1
    1f7a:	8b 83       	std	Y+3, r24	; 0x03
    1f7c:	02 c0       	rjmp	.+4      	; 0x1f82 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f7e:	8f ef       	ldi	r24, 0xFF	; 255
    1f80:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1f82:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1f84:	27 96       	adiw	r28, 0x07	; 7
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	cf 91       	pop	r28
    1f92:	df 91       	pop	r29
    1f94:	08 95       	ret

00001f96 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1f96:	df 93       	push	r29
    1f98:	cf 93       	push	r28
    1f9a:	00 d0       	rcall	.+0      	; 0x1f9c <vCoRoutineAddToDelayedList+0x6>
    1f9c:	00 d0       	rcall	.+0      	; 0x1f9e <vCoRoutineAddToDelayedList+0x8>
    1f9e:	00 d0       	rcall	.+0      	; 0x1fa0 <vCoRoutineAddToDelayedList+0xa>
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	9c 83       	std	Y+4, r25	; 0x04
    1fa6:	8b 83       	std	Y+3, r24	; 0x03
    1fa8:	7e 83       	std	Y+6, r23	; 0x06
    1faa:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1fac:	20 91 89 01 	lds	r18, 0x0189
    1fb0:	30 91 8a 01 	lds	r19, 0x018A
    1fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb8:	82 0f       	add	r24, r18
    1fba:	93 1f       	adc	r25, r19
    1fbc:	9a 83       	std	Y+2, r25	; 0x02
    1fbe:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1fc0:	80 91 86 01 	lds	r24, 0x0186
    1fc4:	90 91 87 01 	lds	r25, 0x0187
    1fc8:	02 96       	adiw	r24, 0x02	; 2
    1fca:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1fce:	e0 91 86 01 	lds	r30, 0x0186
    1fd2:	f0 91 87 01 	lds	r31, 0x0187
    1fd6:	89 81       	ldd	r24, Y+1	; 0x01
    1fd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fda:	93 83       	std	Z+3, r25	; 0x03
    1fdc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1fde:	20 91 89 01 	lds	r18, 0x0189
    1fe2:	30 91 8a 01 	lds	r19, 0x018A
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fea:	82 17       	cp	r24, r18
    1fec:	93 07       	cpc	r25, r19
    1fee:	70 f4       	brcc	.+28     	; 0x200c <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ff0:	80 91 b5 01 	lds	r24, 0x01B5
    1ff4:	90 91 b6 01 	lds	r25, 0x01B6
    1ff8:	20 91 86 01 	lds	r18, 0x0186
    1ffc:	30 91 87 01 	lds	r19, 0x0187
    2000:	2e 5f       	subi	r18, 0xFE	; 254
    2002:	3f 4f       	sbci	r19, 0xFF	; 255
    2004:	b9 01       	movw	r22, r18
    2006:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>
    200a:	0d c0       	rjmp	.+26     	; 0x2026 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    200c:	80 91 b3 01 	lds	r24, 0x01B3
    2010:	90 91 b4 01 	lds	r25, 0x01B4
    2014:	20 91 86 01 	lds	r18, 0x0186
    2018:	30 91 87 01 	lds	r19, 0x0187
    201c:	2e 5f       	subi	r18, 0xFE	; 254
    201e:	3f 4f       	sbci	r19, 0xFF	; 255
    2020:	b9 01       	movw	r22, r18
    2022:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>
	}

	if( pxEventList )
    2026:	8d 81       	ldd	r24, Y+5	; 0x05
    2028:	9e 81       	ldd	r25, Y+6	; 0x06
    202a:	00 97       	sbiw	r24, 0x00	; 0
    202c:	61 f0       	breq	.+24     	; 0x2046 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    202e:	80 91 86 01 	lds	r24, 0x0186
    2032:	90 91 87 01 	lds	r25, 0x0187
    2036:	9c 01       	movw	r18, r24
    2038:	24 5f       	subi	r18, 0xF4	; 244
    203a:	3f 4f       	sbci	r19, 0xFF	; 255
    203c:	8d 81       	ldd	r24, Y+5	; 0x05
    203e:	9e 81       	ldd	r25, Y+6	; 0x06
    2040:	b9 01       	movw	r22, r18
    2042:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>
	}
}
    2046:	26 96       	adiw	r28, 0x06	; 6
    2048:	0f b6       	in	r0, 0x3f	; 63
    204a:	f8 94       	cli
    204c:	de bf       	out	0x3e, r29	; 62
    204e:	0f be       	out	0x3f, r0	; 63
    2050:	cd bf       	out	0x3d, r28	; 61
    2052:	cf 91       	pop	r28
    2054:	df 91       	pop	r29
    2056:	08 95       	ret

00002058 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2058:	df 93       	push	r29
    205a:	cf 93       	push	r28
    205c:	00 d0       	rcall	.+0      	; 0x205e <prvCheckPendingReadyList+0x6>
    205e:	cd b7       	in	r28, 0x3d	; 61
    2060:	de b7       	in	r29, 0x3e	; 62
    2062:	3a c0       	rjmp	.+116    	; 0x20d8 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2064:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2066:	e0 91 bc 01 	lds	r30, 0x01BC
    206a:	f0 91 bd 01 	lds	r31, 0x01BD
    206e:	86 81       	ldd	r24, Z+6	; 0x06
    2070:	97 81       	ldd	r25, Z+7	; 0x07
    2072:	9a 83       	std	Y+2, r25	; 0x02
    2074:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	9a 81       	ldd	r25, Y+2	; 0x02
    207a:	0c 96       	adiw	r24, 0x0c	; 12
    207c:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2080:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2082:	89 81       	ldd	r24, Y+1	; 0x01
    2084:	9a 81       	ldd	r25, Y+2	; 0x02
    2086:	02 96       	adiw	r24, 0x02	; 2
    2088:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    208c:	e9 81       	ldd	r30, Y+1	; 0x01
    208e:	fa 81       	ldd	r31, Y+2	; 0x02
    2090:	96 89       	ldd	r25, Z+22	; 0x16
    2092:	80 91 88 01 	lds	r24, 0x0188
    2096:	89 17       	cp	r24, r25
    2098:	28 f4       	brcc	.+10     	; 0x20a4 <prvCheckPendingReadyList+0x4c>
    209a:	e9 81       	ldd	r30, Y+1	; 0x01
    209c:	fa 81       	ldd	r31, Y+2	; 0x02
    209e:	86 89       	ldd	r24, Z+22	; 0x16
    20a0:	80 93 88 01 	sts	0x0188, r24
    20a4:	e9 81       	ldd	r30, Y+1	; 0x01
    20a6:	fa 81       	ldd	r31, Y+2	; 0x02
    20a8:	86 89       	ldd	r24, Z+22	; 0x16
    20aa:	28 2f       	mov	r18, r24
    20ac:	30 e0       	ldi	r19, 0x00	; 0
    20ae:	c9 01       	movw	r24, r18
    20b0:	88 0f       	add	r24, r24
    20b2:	99 1f       	adc	r25, r25
    20b4:	88 0f       	add	r24, r24
    20b6:	99 1f       	adc	r25, r25
    20b8:	88 0f       	add	r24, r24
    20ba:	99 1f       	adc	r25, r25
    20bc:	82 0f       	add	r24, r18
    20be:	93 1f       	adc	r25, r19
    20c0:	ac 01       	movw	r20, r24
    20c2:	41 57       	subi	r20, 0x71	; 113
    20c4:	5e 4f       	sbci	r21, 0xFE	; 254
    20c6:	89 81       	ldd	r24, Y+1	; 0x01
    20c8:	9a 81       	ldd	r25, Y+2	; 0x02
    20ca:	9c 01       	movw	r18, r24
    20cc:	2e 5f       	subi	r18, 0xFE	; 254
    20ce:	3f 4f       	sbci	r19, 0xFF	; 255
    20d0:	ca 01       	movw	r24, r20
    20d2:	b9 01       	movw	r22, r18
    20d4:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    20d8:	80 91 b7 01 	lds	r24, 0x01B7
    20dc:	88 23       	and	r24, r24
    20de:	09 f0       	breq	.+2      	; 0x20e2 <prvCheckPendingReadyList+0x8a>
    20e0:	c1 cf       	rjmp	.-126    	; 0x2064 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    20e2:	0f 90       	pop	r0
    20e4:	0f 90       	pop	r0
    20e6:	cf 91       	pop	r28
    20e8:	df 91       	pop	r29
    20ea:	08 95       	ret

000020ec <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    20ec:	df 93       	push	r29
    20ee:	cf 93       	push	r28
    20f0:	00 d0       	rcall	.+0      	; 0x20f2 <prvCheckDelayedList+0x6>
    20f2:	00 d0       	rcall	.+0      	; 0x20f4 <prvCheckDelayedList+0x8>
    20f4:	cd b7       	in	r28, 0x3d	; 61
    20f6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    20f8:	0e 94 78 1e 	call	0x3cf0	; 0x3cf0 <xTaskGetTickCount>
    20fc:	20 91 8b 01 	lds	r18, 0x018B
    2100:	30 91 8c 01 	lds	r19, 0x018C
    2104:	82 1b       	sub	r24, r18
    2106:	93 0b       	sbc	r25, r19
    2108:	90 93 8e 01 	sts	0x018E, r25
    210c:	80 93 8d 01 	sts	0x018D, r24
    2110:	85 c0       	rjmp	.+266    	; 0x221c <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2112:	80 91 89 01 	lds	r24, 0x0189
    2116:	90 91 8a 01 	lds	r25, 0x018A
    211a:	01 96       	adiw	r24, 0x01	; 1
    211c:	90 93 8a 01 	sts	0x018A, r25
    2120:	80 93 89 01 	sts	0x0189, r24
		xPassedTicks--;
    2124:	80 91 8d 01 	lds	r24, 0x018D
    2128:	90 91 8e 01 	lds	r25, 0x018E
    212c:	01 97       	sbiw	r24, 0x01	; 1
    212e:	90 93 8e 01 	sts	0x018E, r25
    2132:	80 93 8d 01 	sts	0x018D, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2136:	80 91 89 01 	lds	r24, 0x0189
    213a:	90 91 8a 01 	lds	r25, 0x018A
    213e:	00 97       	sbiw	r24, 0x00	; 0
    2140:	09 f0       	breq	.+2      	; 0x2144 <prvCheckDelayedList+0x58>
    2142:	64 c0       	rjmp	.+200    	; 0x220c <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2144:	80 91 b3 01 	lds	r24, 0x01B3
    2148:	90 91 b4 01 	lds	r25, 0x01B4
    214c:	9a 83       	std	Y+2, r25	; 0x02
    214e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2150:	80 91 b5 01 	lds	r24, 0x01B5
    2154:	90 91 b6 01 	lds	r25, 0x01B6
    2158:	90 93 b4 01 	sts	0x01B4, r25
    215c:	80 93 b3 01 	sts	0x01B3, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2160:	89 81       	ldd	r24, Y+1	; 0x01
    2162:	9a 81       	ldd	r25, Y+2	; 0x02
    2164:	90 93 b6 01 	sts	0x01B6, r25
    2168:	80 93 b5 01 	sts	0x01B5, r24
    216c:	4f c0       	rjmp	.+158    	; 0x220c <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    216e:	e0 91 b3 01 	lds	r30, 0x01B3
    2172:	f0 91 b4 01 	lds	r31, 0x01B4
    2176:	05 80       	ldd	r0, Z+5	; 0x05
    2178:	f6 81       	ldd	r31, Z+6	; 0x06
    217a:	e0 2d       	mov	r30, r0
    217c:	86 81       	ldd	r24, Z+6	; 0x06
    217e:	97 81       	ldd	r25, Z+7	; 0x07
    2180:	9c 83       	std	Y+4, r25	; 0x04
    2182:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2184:	eb 81       	ldd	r30, Y+3	; 0x03
    2186:	fc 81       	ldd	r31, Y+4	; 0x04
    2188:	22 81       	ldd	r18, Z+2	; 0x02
    218a:	33 81       	ldd	r19, Z+3	; 0x03
    218c:	80 91 89 01 	lds	r24, 0x0189
    2190:	90 91 8a 01 	lds	r25, 0x018A
    2194:	82 17       	cp	r24, r18
    2196:	93 07       	cpc	r25, r19
    2198:	08 f4       	brcc	.+2      	; 0x219c <prvCheckDelayedList+0xb0>
    219a:	40 c0       	rjmp	.+128    	; 0x221c <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    219c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    219e:	8b 81       	ldd	r24, Y+3	; 0x03
    21a0:	9c 81       	ldd	r25, Y+4	; 0x04
    21a2:	02 96       	adiw	r24, 0x02	; 2
    21a4:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    21a8:	eb 81       	ldd	r30, Y+3	; 0x03
    21aa:	fc 81       	ldd	r31, Y+4	; 0x04
    21ac:	84 89       	ldd	r24, Z+20	; 0x14
    21ae:	95 89       	ldd	r25, Z+21	; 0x15
    21b0:	00 97       	sbiw	r24, 0x00	; 0
    21b2:	29 f0       	breq	.+10     	; 0x21be <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    21b4:	8b 81       	ldd	r24, Y+3	; 0x03
    21b6:	9c 81       	ldd	r25, Y+4	; 0x04
    21b8:	0c 96       	adiw	r24, 0x0c	; 12
    21ba:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    21be:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    21c0:	eb 81       	ldd	r30, Y+3	; 0x03
    21c2:	fc 81       	ldd	r31, Y+4	; 0x04
    21c4:	96 89       	ldd	r25, Z+22	; 0x16
    21c6:	80 91 88 01 	lds	r24, 0x0188
    21ca:	89 17       	cp	r24, r25
    21cc:	28 f4       	brcc	.+10     	; 0x21d8 <prvCheckDelayedList+0xec>
    21ce:	eb 81       	ldd	r30, Y+3	; 0x03
    21d0:	fc 81       	ldd	r31, Y+4	; 0x04
    21d2:	86 89       	ldd	r24, Z+22	; 0x16
    21d4:	80 93 88 01 	sts	0x0188, r24
    21d8:	eb 81       	ldd	r30, Y+3	; 0x03
    21da:	fc 81       	ldd	r31, Y+4	; 0x04
    21dc:	86 89       	ldd	r24, Z+22	; 0x16
    21de:	28 2f       	mov	r18, r24
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	c9 01       	movw	r24, r18
    21e4:	88 0f       	add	r24, r24
    21e6:	99 1f       	adc	r25, r25
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	88 0f       	add	r24, r24
    21ee:	99 1f       	adc	r25, r25
    21f0:	82 0f       	add	r24, r18
    21f2:	93 1f       	adc	r25, r19
    21f4:	ac 01       	movw	r20, r24
    21f6:	41 57       	subi	r20, 0x71	; 113
    21f8:	5e 4f       	sbci	r21, 0xFE	; 254
    21fa:	8b 81       	ldd	r24, Y+3	; 0x03
    21fc:	9c 81       	ldd	r25, Y+4	; 0x04
    21fe:	9c 01       	movw	r18, r24
    2200:	2e 5f       	subi	r18, 0xFE	; 254
    2202:	3f 4f       	sbci	r19, 0xFF	; 255
    2204:	ca 01       	movw	r24, r20
    2206:	b9 01       	movw	r22, r18
    2208:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    220c:	e0 91 b3 01 	lds	r30, 0x01B3
    2210:	f0 91 b4 01 	lds	r31, 0x01B4
    2214:	80 81       	ld	r24, Z
    2216:	88 23       	and	r24, r24
    2218:	09 f0       	breq	.+2      	; 0x221c <prvCheckDelayedList+0x130>
    221a:	a9 cf       	rjmp	.-174    	; 0x216e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    221c:	80 91 8d 01 	lds	r24, 0x018D
    2220:	90 91 8e 01 	lds	r25, 0x018E
    2224:	00 97       	sbiw	r24, 0x00	; 0
    2226:	09 f0       	breq	.+2      	; 0x222a <prvCheckDelayedList+0x13e>
    2228:	74 cf       	rjmp	.-280    	; 0x2112 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    222a:	80 91 89 01 	lds	r24, 0x0189
    222e:	90 91 8a 01 	lds	r25, 0x018A
    2232:	90 93 8c 01 	sts	0x018C, r25
    2236:	80 93 8b 01 	sts	0x018B, r24
}
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	0f 90       	pop	r0
    2240:	0f 90       	pop	r0
    2242:	cf 91       	pop	r28
    2244:	df 91       	pop	r29
    2246:	08 95       	ret

00002248 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2248:	df 93       	push	r29
    224a:	cf 93       	push	r28
    224c:	00 d0       	rcall	.+0      	; 0x224e <vCoRoutineSchedule+0x6>
    224e:	cd b7       	in	r28, 0x3d	; 61
    2250:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2252:	0e 94 2c 10 	call	0x2058	; 0x2058 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2256:	0e 94 76 10 	call	0x20ec	; 0x20ec <prvCheckDelayedList>
    225a:	0a c0       	rjmp	.+20     	; 0x2270 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    225c:	80 91 88 01 	lds	r24, 0x0188
    2260:	88 23       	and	r24, r24
    2262:	09 f4       	brne	.+2      	; 0x2266 <vCoRoutineSchedule+0x1e>
    2264:	66 c0       	rjmp	.+204    	; 0x2332 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2266:	80 91 88 01 	lds	r24, 0x0188
    226a:	81 50       	subi	r24, 0x01	; 1
    226c:	80 93 88 01 	sts	0x0188, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2270:	80 91 88 01 	lds	r24, 0x0188
    2274:	28 2f       	mov	r18, r24
    2276:	30 e0       	ldi	r19, 0x00	; 0
    2278:	c9 01       	movw	r24, r18
    227a:	88 0f       	add	r24, r24
    227c:	99 1f       	adc	r25, r25
    227e:	88 0f       	add	r24, r24
    2280:	99 1f       	adc	r25, r25
    2282:	88 0f       	add	r24, r24
    2284:	99 1f       	adc	r25, r25
    2286:	82 0f       	add	r24, r18
    2288:	93 1f       	adc	r25, r19
    228a:	fc 01       	movw	r30, r24
    228c:	e1 57       	subi	r30, 0x71	; 113
    228e:	fe 4f       	sbci	r31, 0xFE	; 254
    2290:	80 81       	ld	r24, Z
    2292:	88 23       	and	r24, r24
    2294:	19 f3       	breq	.-58     	; 0x225c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2296:	80 91 88 01 	lds	r24, 0x0188
    229a:	28 2f       	mov	r18, r24
    229c:	30 e0       	ldi	r19, 0x00	; 0
    229e:	c9 01       	movw	r24, r18
    22a0:	88 0f       	add	r24, r24
    22a2:	99 1f       	adc	r25, r25
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	88 0f       	add	r24, r24
    22aa:	99 1f       	adc	r25, r25
    22ac:	82 0f       	add	r24, r18
    22ae:	93 1f       	adc	r25, r19
    22b0:	81 57       	subi	r24, 0x71	; 113
    22b2:	9e 4f       	sbci	r25, 0xFE	; 254
    22b4:	9a 83       	std	Y+2, r25	; 0x02
    22b6:	89 83       	std	Y+1, r24	; 0x01
    22b8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ba:	fa 81       	ldd	r31, Y+2	; 0x02
    22bc:	01 80       	ldd	r0, Z+1	; 0x01
    22be:	f2 81       	ldd	r31, Z+2	; 0x02
    22c0:	e0 2d       	mov	r30, r0
    22c2:	82 81       	ldd	r24, Z+2	; 0x02
    22c4:	93 81       	ldd	r25, Z+3	; 0x03
    22c6:	e9 81       	ldd	r30, Y+1	; 0x01
    22c8:	fa 81       	ldd	r31, Y+2	; 0x02
    22ca:	92 83       	std	Z+2, r25	; 0x02
    22cc:	81 83       	std	Z+1, r24	; 0x01
    22ce:	e9 81       	ldd	r30, Y+1	; 0x01
    22d0:	fa 81       	ldd	r31, Y+2	; 0x02
    22d2:	21 81       	ldd	r18, Z+1	; 0x01
    22d4:	32 81       	ldd	r19, Z+2	; 0x02
    22d6:	89 81       	ldd	r24, Y+1	; 0x01
    22d8:	9a 81       	ldd	r25, Y+2	; 0x02
    22da:	03 96       	adiw	r24, 0x03	; 3
    22dc:	28 17       	cp	r18, r24
    22de:	39 07       	cpc	r19, r25
    22e0:	59 f4       	brne	.+22     	; 0x22f8 <vCoRoutineSchedule+0xb0>
    22e2:	e9 81       	ldd	r30, Y+1	; 0x01
    22e4:	fa 81       	ldd	r31, Y+2	; 0x02
    22e6:	01 80       	ldd	r0, Z+1	; 0x01
    22e8:	f2 81       	ldd	r31, Z+2	; 0x02
    22ea:	e0 2d       	mov	r30, r0
    22ec:	82 81       	ldd	r24, Z+2	; 0x02
    22ee:	93 81       	ldd	r25, Z+3	; 0x03
    22f0:	e9 81       	ldd	r30, Y+1	; 0x01
    22f2:	fa 81       	ldd	r31, Y+2	; 0x02
    22f4:	92 83       	std	Z+2, r25	; 0x02
    22f6:	81 83       	std	Z+1, r24	; 0x01
    22f8:	e9 81       	ldd	r30, Y+1	; 0x01
    22fa:	fa 81       	ldd	r31, Y+2	; 0x02
    22fc:	01 80       	ldd	r0, Z+1	; 0x01
    22fe:	f2 81       	ldd	r31, Z+2	; 0x02
    2300:	e0 2d       	mov	r30, r0
    2302:	86 81       	ldd	r24, Z+6	; 0x06
    2304:	97 81       	ldd	r25, Z+7	; 0x07
    2306:	90 93 87 01 	sts	0x0187, r25
    230a:	80 93 86 01 	sts	0x0186, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    230e:	e0 91 86 01 	lds	r30, 0x0186
    2312:	f0 91 87 01 	lds	r31, 0x0187
    2316:	40 81       	ld	r20, Z
    2318:	51 81       	ldd	r21, Z+1	; 0x01
    231a:	80 91 86 01 	lds	r24, 0x0186
    231e:	90 91 87 01 	lds	r25, 0x0187
    2322:	e0 91 86 01 	lds	r30, 0x0186
    2326:	f0 91 87 01 	lds	r31, 0x0187
    232a:	27 89       	ldd	r18, Z+23	; 0x17
    232c:	62 2f       	mov	r22, r18
    232e:	fa 01       	movw	r30, r20
    2330:	09 95       	icall

	return;
}
    2332:	0f 90       	pop	r0
    2334:	0f 90       	pop	r0
    2336:	cf 91       	pop	r28
    2338:	df 91       	pop	r29
    233a:	08 95       	ret

0000233c <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    233c:	df 93       	push	r29
    233e:	cf 93       	push	r28
    2340:	0f 92       	push	r0
    2342:	cd b7       	in	r28, 0x3d	; 61
    2344:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2346:	19 82       	std	Y+1, r1	; 0x01
    2348:	13 c0       	rjmp	.+38     	; 0x2370 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    234a:	89 81       	ldd	r24, Y+1	; 0x01
    234c:	28 2f       	mov	r18, r24
    234e:	30 e0       	ldi	r19, 0x00	; 0
    2350:	c9 01       	movw	r24, r18
    2352:	88 0f       	add	r24, r24
    2354:	99 1f       	adc	r25, r25
    2356:	88 0f       	add	r24, r24
    2358:	99 1f       	adc	r25, r25
    235a:	88 0f       	add	r24, r24
    235c:	99 1f       	adc	r25, r25
    235e:	82 0f       	add	r24, r18
    2360:	93 1f       	adc	r25, r19
    2362:	81 57       	subi	r24, 0x71	; 113
    2364:	9e 4f       	sbci	r25, 0xFE	; 254
    2366:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    236a:	89 81       	ldd	r24, Y+1	; 0x01
    236c:	8f 5f       	subi	r24, 0xFF	; 255
    236e:	89 83       	std	Y+1, r24	; 0x01
    2370:	89 81       	ldd	r24, Y+1	; 0x01
    2372:	82 30       	cpi	r24, 0x02	; 2
    2374:	50 f3       	brcs	.-44     	; 0x234a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2376:	81 ea       	ldi	r24, 0xA1	; 161
    2378:	91 e0       	ldi	r25, 0x01	; 1
    237a:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    237e:	8a ea       	ldi	r24, 0xAA	; 170
    2380:	91 e0       	ldi	r25, 0x01	; 1
    2382:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2386:	87 eb       	ldi	r24, 0xB7	; 183
    2388:	91 e0       	ldi	r25, 0x01	; 1
    238a:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    238e:	81 ea       	ldi	r24, 0xA1	; 161
    2390:	91 e0       	ldi	r25, 0x01	; 1
    2392:	90 93 b4 01 	sts	0x01B4, r25
    2396:	80 93 b3 01 	sts	0x01B3, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    239a:	8a ea       	ldi	r24, 0xAA	; 170
    239c:	91 e0       	ldi	r25, 0x01	; 1
    239e:	90 93 b6 01 	sts	0x01B6, r25
    23a2:	80 93 b5 01 	sts	0x01B5, r24
}
    23a6:	0f 90       	pop	r0
    23a8:	cf 91       	pop	r28
    23aa:	df 91       	pop	r29
    23ac:	08 95       	ret

000023ae <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    23ae:	df 93       	push	r29
    23b0:	cf 93       	push	r28
    23b2:	00 d0       	rcall	.+0      	; 0x23b4 <xCoRoutineRemoveFromEventList+0x6>
    23b4:	00 d0       	rcall	.+0      	; 0x23b6 <xCoRoutineRemoveFromEventList+0x8>
    23b6:	0f 92       	push	r0
    23b8:	cd b7       	in	r28, 0x3d	; 61
    23ba:	de b7       	in	r29, 0x3e	; 62
    23bc:	9d 83       	std	Y+5, r25	; 0x05
    23be:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    23c0:	ec 81       	ldd	r30, Y+4	; 0x04
    23c2:	fd 81       	ldd	r31, Y+5	; 0x05
    23c4:	05 80       	ldd	r0, Z+5	; 0x05
    23c6:	f6 81       	ldd	r31, Z+6	; 0x06
    23c8:	e0 2d       	mov	r30, r0
    23ca:	86 81       	ldd	r24, Z+6	; 0x06
    23cc:	97 81       	ldd	r25, Z+7	; 0x07
    23ce:	9b 83       	std	Y+3, r25	; 0x03
    23d0:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    23d2:	8a 81       	ldd	r24, Y+2	; 0x02
    23d4:	9b 81       	ldd	r25, Y+3	; 0x03
    23d6:	0c 96       	adiw	r24, 0x0c	; 12
    23d8:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    23dc:	8a 81       	ldd	r24, Y+2	; 0x02
    23de:	9b 81       	ldd	r25, Y+3	; 0x03
    23e0:	9c 01       	movw	r18, r24
    23e2:	24 5f       	subi	r18, 0xF4	; 244
    23e4:	3f 4f       	sbci	r19, 0xFF	; 255
    23e6:	87 eb       	ldi	r24, 0xB7	; 183
    23e8:	91 e0       	ldi	r25, 0x01	; 1
    23ea:	b9 01       	movw	r22, r18
    23ec:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    23f0:	ea 81       	ldd	r30, Y+2	; 0x02
    23f2:	fb 81       	ldd	r31, Y+3	; 0x03
    23f4:	96 89       	ldd	r25, Z+22	; 0x16
    23f6:	e0 91 86 01 	lds	r30, 0x0186
    23fa:	f0 91 87 01 	lds	r31, 0x0187
    23fe:	86 89       	ldd	r24, Z+22	; 0x16
    2400:	98 17       	cp	r25, r24
    2402:	18 f0       	brcs	.+6      	; 0x240a <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2404:	81 e0       	ldi	r24, 0x01	; 1
    2406:	89 83       	std	Y+1, r24	; 0x01
    2408:	01 c0       	rjmp	.+2      	; 0x240c <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    240a:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    240c:	89 81       	ldd	r24, Y+1	; 0x01
}
    240e:	0f 90       	pop	r0
    2410:	0f 90       	pop	r0
    2412:	0f 90       	pop	r0
    2414:	0f 90       	pop	r0
    2416:	0f 90       	pop	r0
    2418:	cf 91       	pop	r28
    241a:	df 91       	pop	r29
    241c:	08 95       	ret

0000241e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    241e:	df 93       	push	r29
    2420:	cf 93       	push	r28
    2422:	00 d0       	rcall	.+0      	; 0x2424 <pvPortMalloc+0x6>
    2424:	00 d0       	rcall	.+0      	; 0x2426 <pvPortMalloc+0x8>
    2426:	cd b7       	in	r28, 0x3d	; 61
    2428:	de b7       	in	r29, 0x3e	; 62
    242a:	9c 83       	std	Y+4, r25	; 0x04
    242c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    242e:	1a 82       	std	Y+2, r1	; 0x02
    2430:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2432:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2436:	80 91 c0 01 	lds	r24, 0x01C0
    243a:	90 91 c1 01 	lds	r25, 0x01C1
    243e:	2b 81       	ldd	r18, Y+3	; 0x03
    2440:	3c 81       	ldd	r19, Y+4	; 0x04
    2442:	82 0f       	add	r24, r18
    2444:	93 1f       	adc	r25, r19
    2446:	22 e0       	ldi	r18, 0x02	; 2
    2448:	88 35       	cpi	r24, 0x58	; 88
    244a:	92 07       	cpc	r25, r18
    244c:	18 f5       	brcc	.+70     	; 0x2494 <pvPortMalloc+0x76>
    244e:	20 91 c0 01 	lds	r18, 0x01C0
    2452:	30 91 c1 01 	lds	r19, 0x01C1
    2456:	8b 81       	ldd	r24, Y+3	; 0x03
    2458:	9c 81       	ldd	r25, Y+4	; 0x04
    245a:	28 0f       	add	r18, r24
    245c:	39 1f       	adc	r19, r25
    245e:	80 91 c0 01 	lds	r24, 0x01C0
    2462:	90 91 c1 01 	lds	r25, 0x01C1
    2466:	82 17       	cp	r24, r18
    2468:	93 07       	cpc	r25, r19
    246a:	a0 f4       	brcc	.+40     	; 0x2494 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    246c:	80 91 c0 01 	lds	r24, 0x01C0
    2470:	90 91 c1 01 	lds	r25, 0x01C1
    2474:	8e 53       	subi	r24, 0x3E	; 62
    2476:	9e 4f       	sbci	r25, 0xFE	; 254
    2478:	9a 83       	std	Y+2, r25	; 0x02
    247a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    247c:	20 91 c0 01 	lds	r18, 0x01C0
    2480:	30 91 c1 01 	lds	r19, 0x01C1
    2484:	8b 81       	ldd	r24, Y+3	; 0x03
    2486:	9c 81       	ldd	r25, Y+4	; 0x04
    2488:	82 0f       	add	r24, r18
    248a:	93 1f       	adc	r25, r19
    248c:	90 93 c1 01 	sts	0x01C1, r25
    2490:	80 93 c0 01 	sts	0x01C0, r24
		}	
	}
	xTaskResumeAll();
    2494:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2498:	89 81       	ldd	r24, Y+1	; 0x01
    249a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    249c:	0f 90       	pop	r0
    249e:	0f 90       	pop	r0
    24a0:	0f 90       	pop	r0
    24a2:	0f 90       	pop	r0
    24a4:	cf 91       	pop	r28
    24a6:	df 91       	pop	r29
    24a8:	08 95       	ret

000024aa <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    24aa:	df 93       	push	r29
    24ac:	cf 93       	push	r28
    24ae:	00 d0       	rcall	.+0      	; 0x24b0 <vPortFree+0x6>
    24b0:	cd b7       	in	r28, 0x3d	; 61
    24b2:	de b7       	in	r29, 0x3e	; 62
    24b4:	9a 83       	std	Y+2, r25	; 0x02
    24b6:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    24b8:	0f 90       	pop	r0
    24ba:	0f 90       	pop	r0
    24bc:	cf 91       	pop	r28
    24be:	df 91       	pop	r29
    24c0:	08 95       	ret

000024c2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    24c2:	df 93       	push	r29
    24c4:	cf 93       	push	r28
    24c6:	cd b7       	in	r28, 0x3d	; 61
    24c8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    24ca:	10 92 c1 01 	sts	0x01C1, r1
    24ce:	10 92 c0 01 	sts	0x01C0, r1
}
    24d2:	cf 91       	pop	r28
    24d4:	df 91       	pop	r29
    24d6:	08 95       	ret

000024d8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    24d8:	df 93       	push	r29
    24da:	cf 93       	push	r28
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    24e0:	20 91 c0 01 	lds	r18, 0x01C0
    24e4:	30 91 c1 01 	lds	r19, 0x01C1
    24e8:	88 e5       	ldi	r24, 0x58	; 88
    24ea:	92 e0       	ldi	r25, 0x02	; 2
    24ec:	82 1b       	sub	r24, r18
    24ee:	93 0b       	sbc	r25, r19
}
    24f0:	cf 91       	pop	r28
    24f2:	df 91       	pop	r29
    24f4:	08 95       	ret

000024f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    24f6:	df 93       	push	r29
    24f8:	cf 93       	push	r28
    24fa:	00 d0       	rcall	.+0      	; 0x24fc <vListInitialise+0x6>
    24fc:	cd b7       	in	r28, 0x3d	; 61
    24fe:	de b7       	in	r29, 0x3e	; 62
    2500:	9a 83       	std	Y+2, r25	; 0x02
    2502:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2504:	89 81       	ldd	r24, Y+1	; 0x01
    2506:	9a 81       	ldd	r25, Y+2	; 0x02
    2508:	03 96       	adiw	r24, 0x03	; 3
    250a:	e9 81       	ldd	r30, Y+1	; 0x01
    250c:	fa 81       	ldd	r31, Y+2	; 0x02
    250e:	92 83       	std	Z+2, r25	; 0x02
    2510:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2512:	e9 81       	ldd	r30, Y+1	; 0x01
    2514:	fa 81       	ldd	r31, Y+2	; 0x02
    2516:	8f ef       	ldi	r24, 0xFF	; 255
    2518:	9f ef       	ldi	r25, 0xFF	; 255
    251a:	94 83       	std	Z+4, r25	; 0x04
    251c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    251e:	89 81       	ldd	r24, Y+1	; 0x01
    2520:	9a 81       	ldd	r25, Y+2	; 0x02
    2522:	03 96       	adiw	r24, 0x03	; 3
    2524:	e9 81       	ldd	r30, Y+1	; 0x01
    2526:	fa 81       	ldd	r31, Y+2	; 0x02
    2528:	96 83       	std	Z+6, r25	; 0x06
    252a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    252c:	89 81       	ldd	r24, Y+1	; 0x01
    252e:	9a 81       	ldd	r25, Y+2	; 0x02
    2530:	03 96       	adiw	r24, 0x03	; 3
    2532:	e9 81       	ldd	r30, Y+1	; 0x01
    2534:	fa 81       	ldd	r31, Y+2	; 0x02
    2536:	90 87       	std	Z+8, r25	; 0x08
    2538:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    253a:	e9 81       	ldd	r30, Y+1	; 0x01
    253c:	fa 81       	ldd	r31, Y+2	; 0x02
    253e:	10 82       	st	Z, r1
}
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	cf 91       	pop	r28
    2546:	df 91       	pop	r29
    2548:	08 95       	ret

0000254a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    254a:	df 93       	push	r29
    254c:	cf 93       	push	r28
    254e:	00 d0       	rcall	.+0      	; 0x2550 <vListInitialiseItem+0x6>
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	9a 83       	std	Y+2, r25	; 0x02
    2556:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2558:	e9 81       	ldd	r30, Y+1	; 0x01
    255a:	fa 81       	ldd	r31, Y+2	; 0x02
    255c:	11 86       	std	Z+9, r1	; 0x09
    255e:	10 86       	std	Z+8, r1	; 0x08
}
    2560:	0f 90       	pop	r0
    2562:	0f 90       	pop	r0
    2564:	cf 91       	pop	r28
    2566:	df 91       	pop	r29
    2568:	08 95       	ret

0000256a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    256a:	df 93       	push	r29
    256c:	cf 93       	push	r28
    256e:	00 d0       	rcall	.+0      	; 0x2570 <vListInsertEnd+0x6>
    2570:	00 d0       	rcall	.+0      	; 0x2572 <vListInsertEnd+0x8>
    2572:	00 d0       	rcall	.+0      	; 0x2574 <vListInsertEnd+0xa>
    2574:	cd b7       	in	r28, 0x3d	; 61
    2576:	de b7       	in	r29, 0x3e	; 62
    2578:	9c 83       	std	Y+4, r25	; 0x04
    257a:	8b 83       	std	Y+3, r24	; 0x03
    257c:	7e 83       	std	Y+6, r23	; 0x06
    257e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2580:	eb 81       	ldd	r30, Y+3	; 0x03
    2582:	fc 81       	ldd	r31, Y+4	; 0x04
    2584:	81 81       	ldd	r24, Z+1	; 0x01
    2586:	92 81       	ldd	r25, Z+2	; 0x02
    2588:	9a 83       	std	Y+2, r25	; 0x02
    258a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    258c:	e9 81       	ldd	r30, Y+1	; 0x01
    258e:	fa 81       	ldd	r31, Y+2	; 0x02
    2590:	82 81       	ldd	r24, Z+2	; 0x02
    2592:	93 81       	ldd	r25, Z+3	; 0x03
    2594:	ed 81       	ldd	r30, Y+5	; 0x05
    2596:	fe 81       	ldd	r31, Y+6	; 0x06
    2598:	93 83       	std	Z+3, r25	; 0x03
    259a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    259c:	eb 81       	ldd	r30, Y+3	; 0x03
    259e:	fc 81       	ldd	r31, Y+4	; 0x04
    25a0:	81 81       	ldd	r24, Z+1	; 0x01
    25a2:	92 81       	ldd	r25, Z+2	; 0x02
    25a4:	ed 81       	ldd	r30, Y+5	; 0x05
    25a6:	fe 81       	ldd	r31, Y+6	; 0x06
    25a8:	95 83       	std	Z+5, r25	; 0x05
    25aa:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    25ac:	e9 81       	ldd	r30, Y+1	; 0x01
    25ae:	fa 81       	ldd	r31, Y+2	; 0x02
    25b0:	02 80       	ldd	r0, Z+2	; 0x02
    25b2:	f3 81       	ldd	r31, Z+3	; 0x03
    25b4:	e0 2d       	mov	r30, r0
    25b6:	8d 81       	ldd	r24, Y+5	; 0x05
    25b8:	9e 81       	ldd	r25, Y+6	; 0x06
    25ba:	95 83       	std	Z+5, r25	; 0x05
    25bc:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    25be:	8d 81       	ldd	r24, Y+5	; 0x05
    25c0:	9e 81       	ldd	r25, Y+6	; 0x06
    25c2:	e9 81       	ldd	r30, Y+1	; 0x01
    25c4:	fa 81       	ldd	r31, Y+2	; 0x02
    25c6:	93 83       	std	Z+3, r25	; 0x03
    25c8:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    25ca:	8d 81       	ldd	r24, Y+5	; 0x05
    25cc:	9e 81       	ldd	r25, Y+6	; 0x06
    25ce:	eb 81       	ldd	r30, Y+3	; 0x03
    25d0:	fc 81       	ldd	r31, Y+4	; 0x04
    25d2:	92 83       	std	Z+2, r25	; 0x02
    25d4:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    25d6:	ed 81       	ldd	r30, Y+5	; 0x05
    25d8:	fe 81       	ldd	r31, Y+6	; 0x06
    25da:	8b 81       	ldd	r24, Y+3	; 0x03
    25dc:	9c 81       	ldd	r25, Y+4	; 0x04
    25de:	91 87       	std	Z+9, r25	; 0x09
    25e0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    25e2:	eb 81       	ldd	r30, Y+3	; 0x03
    25e4:	fc 81       	ldd	r31, Y+4	; 0x04
    25e6:	80 81       	ld	r24, Z
    25e8:	8f 5f       	subi	r24, 0xFF	; 255
    25ea:	eb 81       	ldd	r30, Y+3	; 0x03
    25ec:	fc 81       	ldd	r31, Y+4	; 0x04
    25ee:	80 83       	st	Z, r24
}
    25f0:	26 96       	adiw	r28, 0x06	; 6
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	de bf       	out	0x3e, r29	; 62
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	cd bf       	out	0x3d, r28	; 61
    25fc:	cf 91       	pop	r28
    25fe:	df 91       	pop	r29
    2600:	08 95       	ret

00002602 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2602:	df 93       	push	r29
    2604:	cf 93       	push	r28
    2606:	cd b7       	in	r28, 0x3d	; 61
    2608:	de b7       	in	r29, 0x3e	; 62
    260a:	28 97       	sbiw	r28, 0x08	; 8
    260c:	0f b6       	in	r0, 0x3f	; 63
    260e:	f8 94       	cli
    2610:	de bf       	out	0x3e, r29	; 62
    2612:	0f be       	out	0x3f, r0	; 63
    2614:	cd bf       	out	0x3d, r28	; 61
    2616:	9e 83       	std	Y+6, r25	; 0x06
    2618:	8d 83       	std	Y+5, r24	; 0x05
    261a:	78 87       	std	Y+8, r23	; 0x08
    261c:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    261e:	ef 81       	ldd	r30, Y+7	; 0x07
    2620:	f8 85       	ldd	r31, Y+8	; 0x08
    2622:	80 81       	ld	r24, Z
    2624:	91 81       	ldd	r25, Z+1	; 0x01
    2626:	9a 83       	std	Y+2, r25	; 0x02
    2628:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	9a 81       	ldd	r25, Y+2	; 0x02
    262e:	2f ef       	ldi	r18, 0xFF	; 255
    2630:	8f 3f       	cpi	r24, 0xFF	; 255
    2632:	92 07       	cpc	r25, r18
    2634:	39 f4       	brne	.+14     	; 0x2644 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2636:	ed 81       	ldd	r30, Y+5	; 0x05
    2638:	fe 81       	ldd	r31, Y+6	; 0x06
    263a:	87 81       	ldd	r24, Z+7	; 0x07
    263c:	90 85       	ldd	r25, Z+8	; 0x08
    263e:	9c 83       	std	Y+4, r25	; 0x04
    2640:	8b 83       	std	Y+3, r24	; 0x03
    2642:	18 c0       	rjmp	.+48     	; 0x2674 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2644:	8d 81       	ldd	r24, Y+5	; 0x05
    2646:	9e 81       	ldd	r25, Y+6	; 0x06
    2648:	03 96       	adiw	r24, 0x03	; 3
    264a:	9c 83       	std	Y+4, r25	; 0x04
    264c:	8b 83       	std	Y+3, r24	; 0x03
    264e:	06 c0       	rjmp	.+12     	; 0x265c <vListInsert+0x5a>
    2650:	eb 81       	ldd	r30, Y+3	; 0x03
    2652:	fc 81       	ldd	r31, Y+4	; 0x04
    2654:	82 81       	ldd	r24, Z+2	; 0x02
    2656:	93 81       	ldd	r25, Z+3	; 0x03
    2658:	9c 83       	std	Y+4, r25	; 0x04
    265a:	8b 83       	std	Y+3, r24	; 0x03
    265c:	eb 81       	ldd	r30, Y+3	; 0x03
    265e:	fc 81       	ldd	r31, Y+4	; 0x04
    2660:	02 80       	ldd	r0, Z+2	; 0x02
    2662:	f3 81       	ldd	r31, Z+3	; 0x03
    2664:	e0 2d       	mov	r30, r0
    2666:	20 81       	ld	r18, Z
    2668:	31 81       	ldd	r19, Z+1	; 0x01
    266a:	89 81       	ldd	r24, Y+1	; 0x01
    266c:	9a 81       	ldd	r25, Y+2	; 0x02
    266e:	82 17       	cp	r24, r18
    2670:	93 07       	cpc	r25, r19
    2672:	70 f7       	brcc	.-36     	; 0x2650 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2674:	eb 81       	ldd	r30, Y+3	; 0x03
    2676:	fc 81       	ldd	r31, Y+4	; 0x04
    2678:	82 81       	ldd	r24, Z+2	; 0x02
    267a:	93 81       	ldd	r25, Z+3	; 0x03
    267c:	ef 81       	ldd	r30, Y+7	; 0x07
    267e:	f8 85       	ldd	r31, Y+8	; 0x08
    2680:	93 83       	std	Z+3, r25	; 0x03
    2682:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2684:	ef 81       	ldd	r30, Y+7	; 0x07
    2686:	f8 85       	ldd	r31, Y+8	; 0x08
    2688:	02 80       	ldd	r0, Z+2	; 0x02
    268a:	f3 81       	ldd	r31, Z+3	; 0x03
    268c:	e0 2d       	mov	r30, r0
    268e:	8f 81       	ldd	r24, Y+7	; 0x07
    2690:	98 85       	ldd	r25, Y+8	; 0x08
    2692:	95 83       	std	Z+5, r25	; 0x05
    2694:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2696:	ef 81       	ldd	r30, Y+7	; 0x07
    2698:	f8 85       	ldd	r31, Y+8	; 0x08
    269a:	8b 81       	ldd	r24, Y+3	; 0x03
    269c:	9c 81       	ldd	r25, Y+4	; 0x04
    269e:	95 83       	std	Z+5, r25	; 0x05
    26a0:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    26a2:	8f 81       	ldd	r24, Y+7	; 0x07
    26a4:	98 85       	ldd	r25, Y+8	; 0x08
    26a6:	eb 81       	ldd	r30, Y+3	; 0x03
    26a8:	fc 81       	ldd	r31, Y+4	; 0x04
    26aa:	93 83       	std	Z+3, r25	; 0x03
    26ac:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    26ae:	ef 81       	ldd	r30, Y+7	; 0x07
    26b0:	f8 85       	ldd	r31, Y+8	; 0x08
    26b2:	8d 81       	ldd	r24, Y+5	; 0x05
    26b4:	9e 81       	ldd	r25, Y+6	; 0x06
    26b6:	91 87       	std	Z+9, r25	; 0x09
    26b8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    26ba:	ed 81       	ldd	r30, Y+5	; 0x05
    26bc:	fe 81       	ldd	r31, Y+6	; 0x06
    26be:	80 81       	ld	r24, Z
    26c0:	8f 5f       	subi	r24, 0xFF	; 255
    26c2:	ed 81       	ldd	r30, Y+5	; 0x05
    26c4:	fe 81       	ldd	r31, Y+6	; 0x06
    26c6:	80 83       	st	Z, r24
}
    26c8:	28 96       	adiw	r28, 0x08	; 8
    26ca:	0f b6       	in	r0, 0x3f	; 63
    26cc:	f8 94       	cli
    26ce:	de bf       	out	0x3e, r29	; 62
    26d0:	0f be       	out	0x3f, r0	; 63
    26d2:	cd bf       	out	0x3d, r28	; 61
    26d4:	cf 91       	pop	r28
    26d6:	df 91       	pop	r29
    26d8:	08 95       	ret

000026da <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    26da:	df 93       	push	r29
    26dc:	cf 93       	push	r28
    26de:	00 d0       	rcall	.+0      	; 0x26e0 <vListRemove+0x6>
    26e0:	00 d0       	rcall	.+0      	; 0x26e2 <vListRemove+0x8>
    26e2:	cd b7       	in	r28, 0x3d	; 61
    26e4:	de b7       	in	r29, 0x3e	; 62
    26e6:	9c 83       	std	Y+4, r25	; 0x04
    26e8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    26ea:	eb 81       	ldd	r30, Y+3	; 0x03
    26ec:	fc 81       	ldd	r31, Y+4	; 0x04
    26ee:	a2 81       	ldd	r26, Z+2	; 0x02
    26f0:	b3 81       	ldd	r27, Z+3	; 0x03
    26f2:	eb 81       	ldd	r30, Y+3	; 0x03
    26f4:	fc 81       	ldd	r31, Y+4	; 0x04
    26f6:	84 81       	ldd	r24, Z+4	; 0x04
    26f8:	95 81       	ldd	r25, Z+5	; 0x05
    26fa:	15 96       	adiw	r26, 0x05	; 5
    26fc:	9c 93       	st	X, r25
    26fe:	8e 93       	st	-X, r24
    2700:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2702:	eb 81       	ldd	r30, Y+3	; 0x03
    2704:	fc 81       	ldd	r31, Y+4	; 0x04
    2706:	a4 81       	ldd	r26, Z+4	; 0x04
    2708:	b5 81       	ldd	r27, Z+5	; 0x05
    270a:	eb 81       	ldd	r30, Y+3	; 0x03
    270c:	fc 81       	ldd	r31, Y+4	; 0x04
    270e:	82 81       	ldd	r24, Z+2	; 0x02
    2710:	93 81       	ldd	r25, Z+3	; 0x03
    2712:	13 96       	adiw	r26, 0x03	; 3
    2714:	9c 93       	st	X, r25
    2716:	8e 93       	st	-X, r24
    2718:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    271a:	eb 81       	ldd	r30, Y+3	; 0x03
    271c:	fc 81       	ldd	r31, Y+4	; 0x04
    271e:	80 85       	ldd	r24, Z+8	; 0x08
    2720:	91 85       	ldd	r25, Z+9	; 0x09
    2722:	9a 83       	std	Y+2, r25	; 0x02
    2724:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2726:	e9 81       	ldd	r30, Y+1	; 0x01
    2728:	fa 81       	ldd	r31, Y+2	; 0x02
    272a:	21 81       	ldd	r18, Z+1	; 0x01
    272c:	32 81       	ldd	r19, Z+2	; 0x02
    272e:	8b 81       	ldd	r24, Y+3	; 0x03
    2730:	9c 81       	ldd	r25, Y+4	; 0x04
    2732:	28 17       	cp	r18, r24
    2734:	39 07       	cpc	r19, r25
    2736:	41 f4       	brne	.+16     	; 0x2748 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2738:	eb 81       	ldd	r30, Y+3	; 0x03
    273a:	fc 81       	ldd	r31, Y+4	; 0x04
    273c:	84 81       	ldd	r24, Z+4	; 0x04
    273e:	95 81       	ldd	r25, Z+5	; 0x05
    2740:	e9 81       	ldd	r30, Y+1	; 0x01
    2742:	fa 81       	ldd	r31, Y+2	; 0x02
    2744:	92 83       	std	Z+2, r25	; 0x02
    2746:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2748:	eb 81       	ldd	r30, Y+3	; 0x03
    274a:	fc 81       	ldd	r31, Y+4	; 0x04
    274c:	11 86       	std	Z+9, r1	; 0x09
    274e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2750:	e9 81       	ldd	r30, Y+1	; 0x01
    2752:	fa 81       	ldd	r31, Y+2	; 0x02
    2754:	80 81       	ld	r24, Z
    2756:	81 50       	subi	r24, 0x01	; 1
    2758:	e9 81       	ldd	r30, Y+1	; 0x01
    275a:	fa 81       	ldd	r31, Y+2	; 0x02
    275c:	80 83       	st	Z, r24
}
    275e:	0f 90       	pop	r0
    2760:	0f 90       	pop	r0
    2762:	0f 90       	pop	r0
    2764:	0f 90       	pop	r0
    2766:	cf 91       	pop	r28
    2768:	df 91       	pop	r29
    276a:	08 95       	ret

0000276c <main>:
#define GET_BIT(VAR,BIT)	  (((VAR	>>BIT)	&  1))
#define TOG_BIT(VAR,BIT)	(VAR ^= (1 << (BIT)))


int main(void)
{
    276c:	af 92       	push	r10
    276e:	bf 92       	push	r11
    2770:	cf 92       	push	r12
    2772:	df 92       	push	r13
    2774:	ef 92       	push	r14
    2776:	ff 92       	push	r15
    2778:	0f 93       	push	r16
    277a:	df 93       	push	r29
    277c:	cf 93       	push	r28
    277e:	cd b7       	in	r28, 0x3d	; 61
    2780:	de b7       	in	r29, 0x3e	; 62
	PORT_VoidInit();
    2782:	0e 94 17 07 	call	0xe2e	; 0xe2e <PORT_VoidInit>
	LCD_VoidInit();
    2786:	0e 94 09 0c 	call	0x1812	; 0x1812 <LCD_VoidInit>
	vSemaphoreCreateBinary(LCD_SMPHRE);
    278a:	81 e0       	ldi	r24, 0x01	; 1
    278c:	60 e0       	ldi	r22, 0x00	; 0
    278e:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <xQueueCreate>
    2792:	90 93 7e 04 	sts	0x047E, r25
    2796:	80 93 7d 04 	sts	0x047D, r24
    279a:	80 91 7d 04 	lds	r24, 0x047D
    279e:	90 91 7e 04 	lds	r25, 0x047E
    27a2:	00 97       	sbiw	r24, 0x00	; 0
    27a4:	59 f0       	breq	.+22     	; 0x27bc <main+0x50>
    27a6:	80 91 7d 04 	lds	r24, 0x047D
    27aa:	90 91 7e 04 	lds	r25, 0x047E
    27ae:	60 e0       	ldi	r22, 0x00	; 0
    27b0:	70 e0       	ldi	r23, 0x00	; 0
    27b2:	40 e0       	ldi	r20, 0x00	; 0
    27b4:	50 e0       	ldi	r21, 0x00	; 0
    27b6:	20 e0       	ldi	r18, 0x00	; 0
    27b8:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <xQueueGenericSend>
	xTaskCreate(Task1,"Red",configMINIMAL_STACK_SIZE,NULL,1,NULL);
    27bc:	20 e6       	ldi	r18, 0x60	; 96
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	85 e0       	ldi	r24, 0x05	; 5
    27c2:	94 e1       	ldi	r25, 0x14	; 20
    27c4:	b9 01       	movw	r22, r18
    27c6:	46 e9       	ldi	r20, 0x96	; 150
    27c8:	50 e0       	ldi	r21, 0x00	; 0
    27ca:	20 e0       	ldi	r18, 0x00	; 0
    27cc:	30 e0       	ldi	r19, 0x00	; 0
    27ce:	01 e0       	ldi	r16, 0x01	; 1
    27d0:	ee 24       	eor	r14, r14
    27d2:	ff 24       	eor	r15, r15
    27d4:	cc 24       	eor	r12, r12
    27d6:	dd 24       	eor	r13, r13
    27d8:	aa 24       	eor	r10, r10
    27da:	bb 24       	eor	r11, r11
    27dc:	0e 94 a6 1b 	call	0x374c	; 0x374c <xTaskGenericCreate>
	xTaskCreate(Task2,"Green",configMINIMAL_STACK_SIZE,NULL,1,NULL);
    27e0:	24 e6       	ldi	r18, 0x64	; 100
    27e2:	30 e0       	ldi	r19, 0x00	; 0
    27e4:	8c e2       	ldi	r24, 0x2C	; 44
    27e6:	94 e1       	ldi	r25, 0x14	; 20
    27e8:	b9 01       	movw	r22, r18
    27ea:	46 e9       	ldi	r20, 0x96	; 150
    27ec:	50 e0       	ldi	r21, 0x00	; 0
    27ee:	20 e0       	ldi	r18, 0x00	; 0
    27f0:	30 e0       	ldi	r19, 0x00	; 0
    27f2:	01 e0       	ldi	r16, 0x01	; 1
    27f4:	ee 24       	eor	r14, r14
    27f6:	ff 24       	eor	r15, r15
    27f8:	cc 24       	eor	r12, r12
    27fa:	dd 24       	eor	r13, r13
    27fc:	aa 24       	eor	r10, r10
    27fe:	bb 24       	eor	r11, r11
    2800:	0e 94 a6 1b 	call	0x374c	; 0x374c <xTaskGenericCreate>

	vTaskStartScheduler();
    2804:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <vTaskStartScheduler>
    2808:	ff cf       	rjmp	.-2      	; 0x2808 <main+0x9c>

0000280a <Task1>:

	}
	return 0;
}
void Task1(void *PVPARAM)
{//DDRA|=(1<<0);
    280a:	df 93       	push	r29
    280c:	cf 93       	push	r28
    280e:	00 d0       	rcall	.+0      	; 0x2810 <Task1+0x6>
    2810:	0f 92       	push	r0
    2812:	cd b7       	in	r28, 0x3d	; 61
    2814:	de b7       	in	r29, 0x3e	; 62
    2816:	9b 83       	std	Y+3, r25	; 0x03
    2818:	8a 83       	std	Y+2, r24	; 0x02
	u8 stat=xSemaphoreTake(LCD_SMPHRE,100);
    281a:	80 91 7d 04 	lds	r24, 0x047D
    281e:	90 91 7e 04 	lds	r25, 0x047E
    2822:	60 e0       	ldi	r22, 0x00	; 0
    2824:	70 e0       	ldi	r23, 0x00	; 0
    2826:	44 e6       	ldi	r20, 0x64	; 100
    2828:	50 e0       	ldi	r21, 0x00	; 0
    282a:	20 e0       	ldi	r18, 0x00	; 0
    282c:	0e 94 b9 18 	call	0x3172	; 0x3172 <xQueueGenericReceive>
    2830:	89 83       	std	Y+1, r24	; 0x01
	if(stat==pdPASS)
    2832:	89 81       	ldd	r24, Y+1	; 0x01
    2834:	81 30       	cpi	r24, 0x01	; 1
    2836:	79 f4       	brne	.+30     	; 0x2856 <Task1+0x4c>
	{
		LCD_VoidSendString("MEKO");
    2838:	8a e6       	ldi	r24, 0x6A	; 106
    283a:	90 e0       	ldi	r25, 0x00	; 0
    283c:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_VoidSendString>
		xSemaphoreGive(LCD_SMPHRE);
    2840:	80 91 7d 04 	lds	r24, 0x047D
    2844:	90 91 7e 04 	lds	r25, 0x047E
    2848:	60 e0       	ldi	r22, 0x00	; 0
    284a:	70 e0       	ldi	r23, 0x00	; 0
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	50 e0       	ldi	r21, 0x00	; 0
    2850:	20 e0       	ldi	r18, 0x00	; 0
    2852:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <xQueueGenericSend>
    2856:	ff cf       	rjmp	.-2      	; 0x2856 <Task1+0x4c>

00002858 <Task2>:
	//	vTaskDelay(10);

	}
}
void Task2(void *PVPARAM)
{	//DDRA|=(1<<1);
    2858:	df 93       	push	r29
    285a:	cf 93       	push	r28
    285c:	00 d0       	rcall	.+0      	; 0x285e <Task2+0x6>
    285e:	0f 92       	push	r0
    2860:	cd b7       	in	r28, 0x3d	; 61
    2862:	de b7       	in	r29, 0x3e	; 62
    2864:	9b 83       	std	Y+3, r25	; 0x03
    2866:	8a 83       	std	Y+2, r24	; 0x02
	u8 stat=xSemaphoreTake(LCD_SMPHRE,100);
    2868:	80 91 7d 04 	lds	r24, 0x047D
    286c:	90 91 7e 04 	lds	r25, 0x047E
    2870:	60 e0       	ldi	r22, 0x00	; 0
    2872:	70 e0       	ldi	r23, 0x00	; 0
    2874:	44 e6       	ldi	r20, 0x64	; 100
    2876:	50 e0       	ldi	r21, 0x00	; 0
    2878:	20 e0       	ldi	r18, 0x00	; 0
    287a:	0e 94 b9 18 	call	0x3172	; 0x3172 <xQueueGenericReceive>
    287e:	89 83       	std	Y+1, r24	; 0x01
	if(stat==pdPASS)
    2880:	89 81       	ldd	r24, Y+1	; 0x01
    2882:	81 30       	cpi	r24, 0x01	; 1
    2884:	79 f4       	brne	.+30     	; 0x28a4 <Task2+0x4c>
		{
	 	 LCD_VoidSendString("Doaa");
    2886:	8f e6       	ldi	r24, 0x6F	; 111
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LCD_VoidSendString>
			xSemaphoreGive(LCD_SMPHRE);
    288e:	80 91 7d 04 	lds	r24, 0x047D
    2892:	90 91 7e 04 	lds	r25, 0x047E
    2896:	60 e0       	ldi	r22, 0x00	; 0
    2898:	70 e0       	ldi	r23, 0x00	; 0
    289a:	40 e0       	ldi	r20, 0x00	; 0
    289c:	50 e0       	ldi	r21, 0x00	; 0
    289e:	20 e0       	ldi	r18, 0x00	; 0
    28a0:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <xQueueGenericSend>
    28a4:	ff cf       	rjmp	.-2      	; 0x28a4 <Task2+0x4c>

000028a6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    28a6:	df 93       	push	r29
    28a8:	cf 93       	push	r28
    28aa:	cd b7       	in	r28, 0x3d	; 61
    28ac:	de b7       	in	r29, 0x3e	; 62
    28ae:	28 97       	sbiw	r28, 0x08	; 8
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	f8 94       	cli
    28b4:	de bf       	out	0x3e, r29	; 62
    28b6:	0f be       	out	0x3f, r0	; 63
    28b8:	cd bf       	out	0x3d, r28	; 61
    28ba:	9c 83       	std	Y+4, r25	; 0x04
    28bc:	8b 83       	std	Y+3, r24	; 0x03
    28be:	7e 83       	std	Y+6, r23	; 0x06
    28c0:	6d 83       	std	Y+5, r22	; 0x05
    28c2:	58 87       	std	Y+8, r21	; 0x08
    28c4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    28c6:	eb 81       	ldd	r30, Y+3	; 0x03
    28c8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ca:	81 e1       	ldi	r24, 0x11	; 17
    28cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    28ce:	8b 81       	ldd	r24, Y+3	; 0x03
    28d0:	9c 81       	ldd	r25, Y+4	; 0x04
    28d2:	01 97       	sbiw	r24, 0x01	; 1
    28d4:	9c 83       	std	Y+4, r25	; 0x04
    28d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    28d8:	eb 81       	ldd	r30, Y+3	; 0x03
    28da:	fc 81       	ldd	r31, Y+4	; 0x04
    28dc:	82 e2       	ldi	r24, 0x22	; 34
    28de:	80 83       	st	Z, r24
	pxTopOfStack--;
    28e0:	8b 81       	ldd	r24, Y+3	; 0x03
    28e2:	9c 81       	ldd	r25, Y+4	; 0x04
    28e4:	01 97       	sbiw	r24, 0x01	; 1
    28e6:	9c 83       	std	Y+4, r25	; 0x04
    28e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    28ea:	eb 81       	ldd	r30, Y+3	; 0x03
    28ec:	fc 81       	ldd	r31, Y+4	; 0x04
    28ee:	83 e3       	ldi	r24, 0x33	; 51
    28f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    28f2:	8b 81       	ldd	r24, Y+3	; 0x03
    28f4:	9c 81       	ldd	r25, Y+4	; 0x04
    28f6:	01 97       	sbiw	r24, 0x01	; 1
    28f8:	9c 83       	std	Y+4, r25	; 0x04
    28fa:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    28fc:	8d 81       	ldd	r24, Y+5	; 0x05
    28fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2900:	9a 83       	std	Y+2, r25	; 0x02
    2902:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	eb 81       	ldd	r30, Y+3	; 0x03
    2908:	fc 81       	ldd	r31, Y+4	; 0x04
    290a:	80 83       	st	Z, r24
	pxTopOfStack--;
    290c:	8b 81       	ldd	r24, Y+3	; 0x03
    290e:	9c 81       	ldd	r25, Y+4	; 0x04
    2910:	01 97       	sbiw	r24, 0x01	; 1
    2912:	9c 83       	std	Y+4, r25	; 0x04
    2914:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2916:	89 81       	ldd	r24, Y+1	; 0x01
    2918:	9a 81       	ldd	r25, Y+2	; 0x02
    291a:	89 2f       	mov	r24, r25
    291c:	99 27       	eor	r25, r25
    291e:	9a 83       	std	Y+2, r25	; 0x02
    2920:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	eb 81       	ldd	r30, Y+3	; 0x03
    2926:	fc 81       	ldd	r31, Y+4	; 0x04
    2928:	80 83       	st	Z, r24
	pxTopOfStack--;
    292a:	8b 81       	ldd	r24, Y+3	; 0x03
    292c:	9c 81       	ldd	r25, Y+4	; 0x04
    292e:	01 97       	sbiw	r24, 0x01	; 1
    2930:	9c 83       	std	Y+4, r25	; 0x04
    2932:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2934:	eb 81       	ldd	r30, Y+3	; 0x03
    2936:	fc 81       	ldd	r31, Y+4	; 0x04
    2938:	10 82       	st	Z, r1
	pxTopOfStack--;
    293a:	8b 81       	ldd	r24, Y+3	; 0x03
    293c:	9c 81       	ldd	r25, Y+4	; 0x04
    293e:	01 97       	sbiw	r24, 0x01	; 1
    2940:	9c 83       	std	Y+4, r25	; 0x04
    2942:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2944:	eb 81       	ldd	r30, Y+3	; 0x03
    2946:	fc 81       	ldd	r31, Y+4	; 0x04
    2948:	80 e8       	ldi	r24, 0x80	; 128
    294a:	80 83       	st	Z, r24
	pxTopOfStack--;
    294c:	8b 81       	ldd	r24, Y+3	; 0x03
    294e:	9c 81       	ldd	r25, Y+4	; 0x04
    2950:	01 97       	sbiw	r24, 0x01	; 1
    2952:	9c 83       	std	Y+4, r25	; 0x04
    2954:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2956:	eb 81       	ldd	r30, Y+3	; 0x03
    2958:	fc 81       	ldd	r31, Y+4	; 0x04
    295a:	10 82       	st	Z, r1
	pxTopOfStack--;
    295c:	8b 81       	ldd	r24, Y+3	; 0x03
    295e:	9c 81       	ldd	r25, Y+4	; 0x04
    2960:	01 97       	sbiw	r24, 0x01	; 1
    2962:	9c 83       	std	Y+4, r25	; 0x04
    2964:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2966:	eb 81       	ldd	r30, Y+3	; 0x03
    2968:	fc 81       	ldd	r31, Y+4	; 0x04
    296a:	82 e0       	ldi	r24, 0x02	; 2
    296c:	80 83       	st	Z, r24
	pxTopOfStack--;
    296e:	8b 81       	ldd	r24, Y+3	; 0x03
    2970:	9c 81       	ldd	r25, Y+4	; 0x04
    2972:	01 97       	sbiw	r24, 0x01	; 1
    2974:	9c 83       	std	Y+4, r25	; 0x04
    2976:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2978:	eb 81       	ldd	r30, Y+3	; 0x03
    297a:	fc 81       	ldd	r31, Y+4	; 0x04
    297c:	83 e0       	ldi	r24, 0x03	; 3
    297e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2980:	8b 81       	ldd	r24, Y+3	; 0x03
    2982:	9c 81       	ldd	r25, Y+4	; 0x04
    2984:	01 97       	sbiw	r24, 0x01	; 1
    2986:	9c 83       	std	Y+4, r25	; 0x04
    2988:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    298a:	eb 81       	ldd	r30, Y+3	; 0x03
    298c:	fc 81       	ldd	r31, Y+4	; 0x04
    298e:	84 e0       	ldi	r24, 0x04	; 4
    2990:	80 83       	st	Z, r24
	pxTopOfStack--;
    2992:	8b 81       	ldd	r24, Y+3	; 0x03
    2994:	9c 81       	ldd	r25, Y+4	; 0x04
    2996:	01 97       	sbiw	r24, 0x01	; 1
    2998:	9c 83       	std	Y+4, r25	; 0x04
    299a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    299c:	eb 81       	ldd	r30, Y+3	; 0x03
    299e:	fc 81       	ldd	r31, Y+4	; 0x04
    29a0:	85 e0       	ldi	r24, 0x05	; 5
    29a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    29a4:	8b 81       	ldd	r24, Y+3	; 0x03
    29a6:	9c 81       	ldd	r25, Y+4	; 0x04
    29a8:	01 97       	sbiw	r24, 0x01	; 1
    29aa:	9c 83       	std	Y+4, r25	; 0x04
    29ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    29ae:	eb 81       	ldd	r30, Y+3	; 0x03
    29b0:	fc 81       	ldd	r31, Y+4	; 0x04
    29b2:	86 e0       	ldi	r24, 0x06	; 6
    29b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    29b6:	8b 81       	ldd	r24, Y+3	; 0x03
    29b8:	9c 81       	ldd	r25, Y+4	; 0x04
    29ba:	01 97       	sbiw	r24, 0x01	; 1
    29bc:	9c 83       	std	Y+4, r25	; 0x04
    29be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    29c0:	eb 81       	ldd	r30, Y+3	; 0x03
    29c2:	fc 81       	ldd	r31, Y+4	; 0x04
    29c4:	87 e0       	ldi	r24, 0x07	; 7
    29c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    29c8:	8b 81       	ldd	r24, Y+3	; 0x03
    29ca:	9c 81       	ldd	r25, Y+4	; 0x04
    29cc:	01 97       	sbiw	r24, 0x01	; 1
    29ce:	9c 83       	std	Y+4, r25	; 0x04
    29d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    29d2:	eb 81       	ldd	r30, Y+3	; 0x03
    29d4:	fc 81       	ldd	r31, Y+4	; 0x04
    29d6:	88 e0       	ldi	r24, 0x08	; 8
    29d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29da:	8b 81       	ldd	r24, Y+3	; 0x03
    29dc:	9c 81       	ldd	r25, Y+4	; 0x04
    29de:	01 97       	sbiw	r24, 0x01	; 1
    29e0:	9c 83       	std	Y+4, r25	; 0x04
    29e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    29e4:	eb 81       	ldd	r30, Y+3	; 0x03
    29e6:	fc 81       	ldd	r31, Y+4	; 0x04
    29e8:	89 e0       	ldi	r24, 0x09	; 9
    29ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ec:	8b 81       	ldd	r24, Y+3	; 0x03
    29ee:	9c 81       	ldd	r25, Y+4	; 0x04
    29f0:	01 97       	sbiw	r24, 0x01	; 1
    29f2:	9c 83       	std	Y+4, r25	; 0x04
    29f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    29f6:	eb 81       	ldd	r30, Y+3	; 0x03
    29f8:	fc 81       	ldd	r31, Y+4	; 0x04
    29fa:	80 e1       	ldi	r24, 0x10	; 16
    29fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    29fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2a00:	9c 81       	ldd	r25, Y+4	; 0x04
    2a02:	01 97       	sbiw	r24, 0x01	; 1
    2a04:	9c 83       	std	Y+4, r25	; 0x04
    2a06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2a08:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0c:	81 e1       	ldi	r24, 0x11	; 17
    2a0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a10:	8b 81       	ldd	r24, Y+3	; 0x03
    2a12:	9c 81       	ldd	r25, Y+4	; 0x04
    2a14:	01 97       	sbiw	r24, 0x01	; 1
    2a16:	9c 83       	std	Y+4, r25	; 0x04
    2a18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a1e:	82 e1       	ldi	r24, 0x12	; 18
    2a20:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a22:	8b 81       	ldd	r24, Y+3	; 0x03
    2a24:	9c 81       	ldd	r25, Y+4	; 0x04
    2a26:	01 97       	sbiw	r24, 0x01	; 1
    2a28:	9c 83       	std	Y+4, r25	; 0x04
    2a2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a30:	83 e1       	ldi	r24, 0x13	; 19
    2a32:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a34:	8b 81       	ldd	r24, Y+3	; 0x03
    2a36:	9c 81       	ldd	r25, Y+4	; 0x04
    2a38:	01 97       	sbiw	r24, 0x01	; 1
    2a3a:	9c 83       	std	Y+4, r25	; 0x04
    2a3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a40:	fc 81       	ldd	r31, Y+4	; 0x04
    2a42:	84 e1       	ldi	r24, 0x14	; 20
    2a44:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4a:	01 97       	sbiw	r24, 0x01	; 1
    2a4c:	9c 83       	std	Y+4, r25	; 0x04
    2a4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2a50:	eb 81       	ldd	r30, Y+3	; 0x03
    2a52:	fc 81       	ldd	r31, Y+4	; 0x04
    2a54:	85 e1       	ldi	r24, 0x15	; 21
    2a56:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a58:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5c:	01 97       	sbiw	r24, 0x01	; 1
    2a5e:	9c 83       	std	Y+4, r25	; 0x04
    2a60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2a62:	eb 81       	ldd	r30, Y+3	; 0x03
    2a64:	fc 81       	ldd	r31, Y+4	; 0x04
    2a66:	86 e1       	ldi	r24, 0x16	; 22
    2a68:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a6e:	01 97       	sbiw	r24, 0x01	; 1
    2a70:	9c 83       	std	Y+4, r25	; 0x04
    2a72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	87 e1       	ldi	r24, 0x17	; 23
    2a7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a80:	01 97       	sbiw	r24, 0x01	; 1
    2a82:	9c 83       	std	Y+4, r25	; 0x04
    2a84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2a86:	eb 81       	ldd	r30, Y+3	; 0x03
    2a88:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8a:	88 e1       	ldi	r24, 0x18	; 24
    2a8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	01 97       	sbiw	r24, 0x01	; 1
    2a94:	9c 83       	std	Y+4, r25	; 0x04
    2a96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2a98:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9c:	89 e1       	ldi	r24, 0x19	; 25
    2a9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa4:	01 97       	sbiw	r24, 0x01	; 1
    2aa6:	9c 83       	std	Y+4, r25	; 0x04
    2aa8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    2aac:	fc 81       	ldd	r31, Y+4	; 0x04
    2aae:	80 e2       	ldi	r24, 0x20	; 32
    2ab0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab6:	01 97       	sbiw	r24, 0x01	; 1
    2ab8:	9c 83       	std	Y+4, r25	; 0x04
    2aba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2abc:	eb 81       	ldd	r30, Y+3	; 0x03
    2abe:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac0:	81 e2       	ldi	r24, 0x21	; 33
    2ac2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac8:	01 97       	sbiw	r24, 0x01	; 1
    2aca:	9c 83       	std	Y+4, r25	; 0x04
    2acc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	82 e2       	ldi	r24, 0x22	; 34
    2ad4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ad6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ad8:	9c 81       	ldd	r25, Y+4	; 0x04
    2ada:	01 97       	sbiw	r24, 0x01	; 1
    2adc:	9c 83       	std	Y+4, r25	; 0x04
    2ade:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae4:	83 e2       	ldi	r24, 0x23	; 35
    2ae6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aea:	9c 81       	ldd	r25, Y+4	; 0x04
    2aec:	01 97       	sbiw	r24, 0x01	; 1
    2aee:	9c 83       	std	Y+4, r25	; 0x04
    2af0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2af2:	8f 81       	ldd	r24, Y+7	; 0x07
    2af4:	98 85       	ldd	r25, Y+8	; 0x08
    2af6:	9a 83       	std	Y+2, r25	; 0x02
    2af8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	eb 81       	ldd	r30, Y+3	; 0x03
    2afe:	fc 81       	ldd	r31, Y+4	; 0x04
    2b00:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b02:	8b 81       	ldd	r24, Y+3	; 0x03
    2b04:	9c 81       	ldd	r25, Y+4	; 0x04
    2b06:	01 97       	sbiw	r24, 0x01	; 1
    2b08:	9c 83       	std	Y+4, r25	; 0x04
    2b0a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2b0c:	89 81       	ldd	r24, Y+1	; 0x01
    2b0e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b10:	89 2f       	mov	r24, r25
    2b12:	99 27       	eor	r25, r25
    2b14:	9a 83       	std	Y+2, r25	; 0x02
    2b16:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2b18:	89 81       	ldd	r24, Y+1	; 0x01
    2b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b20:	8b 81       	ldd	r24, Y+3	; 0x03
    2b22:	9c 81       	ldd	r25, Y+4	; 0x04
    2b24:	01 97       	sbiw	r24, 0x01	; 1
    2b26:	9c 83       	std	Y+4, r25	; 0x04
    2b28:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b2e:	86 e2       	ldi	r24, 0x26	; 38
    2b30:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b32:	8b 81       	ldd	r24, Y+3	; 0x03
    2b34:	9c 81       	ldd	r25, Y+4	; 0x04
    2b36:	01 97       	sbiw	r24, 0x01	; 1
    2b38:	9c 83       	std	Y+4, r25	; 0x04
    2b3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b40:	87 e2       	ldi	r24, 0x27	; 39
    2b42:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b44:	8b 81       	ldd	r24, Y+3	; 0x03
    2b46:	9c 81       	ldd	r25, Y+4	; 0x04
    2b48:	01 97       	sbiw	r24, 0x01	; 1
    2b4a:	9c 83       	std	Y+4, r25	; 0x04
    2b4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2b4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b50:	fc 81       	ldd	r31, Y+4	; 0x04
    2b52:	88 e2       	ldi	r24, 0x28	; 40
    2b54:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b56:	8b 81       	ldd	r24, Y+3	; 0x03
    2b58:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5a:	01 97       	sbiw	r24, 0x01	; 1
    2b5c:	9c 83       	std	Y+4, r25	; 0x04
    2b5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2b60:	eb 81       	ldd	r30, Y+3	; 0x03
    2b62:	fc 81       	ldd	r31, Y+4	; 0x04
    2b64:	89 e2       	ldi	r24, 0x29	; 41
    2b66:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b68:	8b 81       	ldd	r24, Y+3	; 0x03
    2b6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b6c:	01 97       	sbiw	r24, 0x01	; 1
    2b6e:	9c 83       	std	Y+4, r25	; 0x04
    2b70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2b72:	eb 81       	ldd	r30, Y+3	; 0x03
    2b74:	fc 81       	ldd	r31, Y+4	; 0x04
    2b76:	80 e3       	ldi	r24, 0x30	; 48
    2b78:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b7c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7e:	01 97       	sbiw	r24, 0x01	; 1
    2b80:	9c 83       	std	Y+4, r25	; 0x04
    2b82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2b84:	eb 81       	ldd	r30, Y+3	; 0x03
    2b86:	fc 81       	ldd	r31, Y+4	; 0x04
    2b88:	81 e3       	ldi	r24, 0x31	; 49
    2b8a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b90:	01 97       	sbiw	r24, 0x01	; 1
    2b92:	9c 83       	std	Y+4, r25	; 0x04
    2b94:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2b96:	8b 81       	ldd	r24, Y+3	; 0x03
    2b98:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2b9a:	28 96       	adiw	r28, 0x08	; 8
    2b9c:	0f b6       	in	r0, 0x3f	; 63
    2b9e:	f8 94       	cli
    2ba0:	de bf       	out	0x3e, r29	; 62
    2ba2:	0f be       	out	0x3f, r0	; 63
    2ba4:	cd bf       	out	0x3d, r28	; 61
    2ba6:	cf 91       	pop	r28
    2ba8:	df 91       	pop	r29
    2baa:	08 95       	ret

00002bac <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2bac:	df 93       	push	r29
    2bae:	cf 93       	push	r28
    2bb0:	cd b7       	in	r28, 0x3d	; 61
    2bb2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2bb4:	0e 94 c6 16 	call	0x2d8c	; 0x2d8c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2bb8:	a0 91 1a 04 	lds	r26, 0x041A
    2bbc:	b0 91 1b 04 	lds	r27, 0x041B
    2bc0:	cd 91       	ld	r28, X+
    2bc2:	cd bf       	out	0x3d, r28	; 61
    2bc4:	dd 91       	ld	r29, X+
    2bc6:	de bf       	out	0x3e, r29	; 62
    2bc8:	ff 91       	pop	r31
    2bca:	ef 91       	pop	r30
    2bcc:	df 91       	pop	r29
    2bce:	cf 91       	pop	r28
    2bd0:	bf 91       	pop	r27
    2bd2:	af 91       	pop	r26
    2bd4:	9f 91       	pop	r25
    2bd6:	8f 91       	pop	r24
    2bd8:	7f 91       	pop	r23
    2bda:	6f 91       	pop	r22
    2bdc:	5f 91       	pop	r21
    2bde:	4f 91       	pop	r20
    2be0:	3f 91       	pop	r19
    2be2:	2f 91       	pop	r18
    2be4:	1f 91       	pop	r17
    2be6:	0f 91       	pop	r16
    2be8:	ff 90       	pop	r15
    2bea:	ef 90       	pop	r14
    2bec:	df 90       	pop	r13
    2bee:	cf 90       	pop	r12
    2bf0:	bf 90       	pop	r11
    2bf2:	af 90       	pop	r10
    2bf4:	9f 90       	pop	r9
    2bf6:	8f 90       	pop	r8
    2bf8:	7f 90       	pop	r7
    2bfa:	6f 90       	pop	r6
    2bfc:	5f 90       	pop	r5
    2bfe:	4f 90       	pop	r4
    2c00:	3f 90       	pop	r3
    2c02:	2f 90       	pop	r2
    2c04:	1f 90       	pop	r1
    2c06:	0f 90       	pop	r0
    2c08:	0f be       	out	0x3f, r0	; 63
    2c0a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2c0c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2c0e:	81 e0       	ldi	r24, 0x01	; 1
}
    2c10:	cf 91       	pop	r28
    2c12:	df 91       	pop	r29
    2c14:	08 95       	ret

00002c16 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2c16:	df 93       	push	r29
    2c18:	cf 93       	push	r28
    2c1a:	cd b7       	in	r28, 0x3d	; 61
    2c1c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2c1e:	cf 91       	pop	r28
    2c20:	df 91       	pop	r29
    2c22:	08 95       	ret

00002c24 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2c24:	0f 92       	push	r0
    2c26:	0f b6       	in	r0, 0x3f	; 63
    2c28:	f8 94       	cli
    2c2a:	0f 92       	push	r0
    2c2c:	1f 92       	push	r1
    2c2e:	11 24       	eor	r1, r1
    2c30:	2f 92       	push	r2
    2c32:	3f 92       	push	r3
    2c34:	4f 92       	push	r4
    2c36:	5f 92       	push	r5
    2c38:	6f 92       	push	r6
    2c3a:	7f 92       	push	r7
    2c3c:	8f 92       	push	r8
    2c3e:	9f 92       	push	r9
    2c40:	af 92       	push	r10
    2c42:	bf 92       	push	r11
    2c44:	cf 92       	push	r12
    2c46:	df 92       	push	r13
    2c48:	ef 92       	push	r14
    2c4a:	ff 92       	push	r15
    2c4c:	0f 93       	push	r16
    2c4e:	1f 93       	push	r17
    2c50:	2f 93       	push	r18
    2c52:	3f 93       	push	r19
    2c54:	4f 93       	push	r20
    2c56:	5f 93       	push	r21
    2c58:	6f 93       	push	r22
    2c5a:	7f 93       	push	r23
    2c5c:	8f 93       	push	r24
    2c5e:	9f 93       	push	r25
    2c60:	af 93       	push	r26
    2c62:	bf 93       	push	r27
    2c64:	cf 93       	push	r28
    2c66:	df 93       	push	r29
    2c68:	ef 93       	push	r30
    2c6a:	ff 93       	push	r31
    2c6c:	a0 91 1a 04 	lds	r26, 0x041A
    2c70:	b0 91 1b 04 	lds	r27, 0x041B
    2c74:	0d b6       	in	r0, 0x3d	; 61
    2c76:	0d 92       	st	X+, r0
    2c78:	0e b6       	in	r0, 0x3e	; 62
    2c7a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c7c:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c80:	a0 91 1a 04 	lds	r26, 0x041A
    2c84:	b0 91 1b 04 	lds	r27, 0x041B
    2c88:	cd 91       	ld	r28, X+
    2c8a:	cd bf       	out	0x3d, r28	; 61
    2c8c:	dd 91       	ld	r29, X+
    2c8e:	de bf       	out	0x3e, r29	; 62
    2c90:	ff 91       	pop	r31
    2c92:	ef 91       	pop	r30
    2c94:	df 91       	pop	r29
    2c96:	cf 91       	pop	r28
    2c98:	bf 91       	pop	r27
    2c9a:	af 91       	pop	r26
    2c9c:	9f 91       	pop	r25
    2c9e:	8f 91       	pop	r24
    2ca0:	7f 91       	pop	r23
    2ca2:	6f 91       	pop	r22
    2ca4:	5f 91       	pop	r21
    2ca6:	4f 91       	pop	r20
    2ca8:	3f 91       	pop	r19
    2caa:	2f 91       	pop	r18
    2cac:	1f 91       	pop	r17
    2cae:	0f 91       	pop	r16
    2cb0:	ff 90       	pop	r15
    2cb2:	ef 90       	pop	r14
    2cb4:	df 90       	pop	r13
    2cb6:	cf 90       	pop	r12
    2cb8:	bf 90       	pop	r11
    2cba:	af 90       	pop	r10
    2cbc:	9f 90       	pop	r9
    2cbe:	8f 90       	pop	r8
    2cc0:	7f 90       	pop	r7
    2cc2:	6f 90       	pop	r6
    2cc4:	5f 90       	pop	r5
    2cc6:	4f 90       	pop	r4
    2cc8:	3f 90       	pop	r3
    2cca:	2f 90       	pop	r2
    2ccc:	1f 90       	pop	r1
    2cce:	0f 90       	pop	r0
    2cd0:	0f be       	out	0x3f, r0	; 63
    2cd2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2cd4:	08 95       	ret

00002cd6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2cd6:	0f 92       	push	r0
    2cd8:	0f b6       	in	r0, 0x3f	; 63
    2cda:	f8 94       	cli
    2cdc:	0f 92       	push	r0
    2cde:	1f 92       	push	r1
    2ce0:	11 24       	eor	r1, r1
    2ce2:	2f 92       	push	r2
    2ce4:	3f 92       	push	r3
    2ce6:	4f 92       	push	r4
    2ce8:	5f 92       	push	r5
    2cea:	6f 92       	push	r6
    2cec:	7f 92       	push	r7
    2cee:	8f 92       	push	r8
    2cf0:	9f 92       	push	r9
    2cf2:	af 92       	push	r10
    2cf4:	bf 92       	push	r11
    2cf6:	cf 92       	push	r12
    2cf8:	df 92       	push	r13
    2cfa:	ef 92       	push	r14
    2cfc:	ff 92       	push	r15
    2cfe:	0f 93       	push	r16
    2d00:	1f 93       	push	r17
    2d02:	2f 93       	push	r18
    2d04:	3f 93       	push	r19
    2d06:	4f 93       	push	r20
    2d08:	5f 93       	push	r21
    2d0a:	6f 93       	push	r22
    2d0c:	7f 93       	push	r23
    2d0e:	8f 93       	push	r24
    2d10:	9f 93       	push	r25
    2d12:	af 93       	push	r26
    2d14:	bf 93       	push	r27
    2d16:	cf 93       	push	r28
    2d18:	df 93       	push	r29
    2d1a:	ef 93       	push	r30
    2d1c:	ff 93       	push	r31
    2d1e:	a0 91 1a 04 	lds	r26, 0x041A
    2d22:	b0 91 1b 04 	lds	r27, 0x041B
    2d26:	0d b6       	in	r0, 0x3d	; 61
    2d28:	0d 92       	st	X+, r0
    2d2a:	0e b6       	in	r0, 0x3e	; 62
    2d2c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2d2e:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vTaskIncrementTick>
	vTaskSwitchContext();
    2d32:	0e 94 82 1f 	call	0x3f04	; 0x3f04 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2d36:	a0 91 1a 04 	lds	r26, 0x041A
    2d3a:	b0 91 1b 04 	lds	r27, 0x041B
    2d3e:	cd 91       	ld	r28, X+
    2d40:	cd bf       	out	0x3d, r28	; 61
    2d42:	dd 91       	ld	r29, X+
    2d44:	de bf       	out	0x3e, r29	; 62
    2d46:	ff 91       	pop	r31
    2d48:	ef 91       	pop	r30
    2d4a:	df 91       	pop	r29
    2d4c:	cf 91       	pop	r28
    2d4e:	bf 91       	pop	r27
    2d50:	af 91       	pop	r26
    2d52:	9f 91       	pop	r25
    2d54:	8f 91       	pop	r24
    2d56:	7f 91       	pop	r23
    2d58:	6f 91       	pop	r22
    2d5a:	5f 91       	pop	r21
    2d5c:	4f 91       	pop	r20
    2d5e:	3f 91       	pop	r19
    2d60:	2f 91       	pop	r18
    2d62:	1f 91       	pop	r17
    2d64:	0f 91       	pop	r16
    2d66:	ff 90       	pop	r15
    2d68:	ef 90       	pop	r14
    2d6a:	df 90       	pop	r13
    2d6c:	cf 90       	pop	r12
    2d6e:	bf 90       	pop	r11
    2d70:	af 90       	pop	r10
    2d72:	9f 90       	pop	r9
    2d74:	8f 90       	pop	r8
    2d76:	7f 90       	pop	r7
    2d78:	6f 90       	pop	r6
    2d7a:	5f 90       	pop	r5
    2d7c:	4f 90       	pop	r4
    2d7e:	3f 90       	pop	r3
    2d80:	2f 90       	pop	r2
    2d82:	1f 90       	pop	r1
    2d84:	0f 90       	pop	r0
    2d86:	0f be       	out	0x3f, r0	; 63
    2d88:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d8a:	08 95       	ret

00002d8c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2d8c:	df 93       	push	r29
    2d8e:	cf 93       	push	r28
    2d90:	00 d0       	rcall	.+0      	; 0x2d92 <prvSetupTimerInterrupt+0x6>
    2d92:	00 d0       	rcall	.+0      	; 0x2d94 <prvSetupTimerInterrupt+0x8>
    2d94:	00 d0       	rcall	.+0      	; 0x2d96 <prvSetupTimerInterrupt+0xa>
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2d9a:	80 e1       	ldi	r24, 0x10	; 16
    2d9c:	97 e2       	ldi	r25, 0x27	; 39
    2d9e:	a0 e0       	ldi	r26, 0x00	; 0
    2da0:	b0 e0       	ldi	r27, 0x00	; 0
    2da2:	8b 83       	std	Y+3, r24	; 0x03
    2da4:	9c 83       	std	Y+4, r25	; 0x04
    2da6:	ad 83       	std	Y+5, r26	; 0x05
    2da8:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2daa:	8b 81       	ldd	r24, Y+3	; 0x03
    2dac:	9c 81       	ldd	r25, Y+4	; 0x04
    2dae:	ad 81       	ldd	r26, Y+5	; 0x05
    2db0:	be 81       	ldd	r27, Y+6	; 0x06
    2db2:	68 94       	set
    2db4:	15 f8       	bld	r1, 5
    2db6:	b6 95       	lsr	r27
    2db8:	a7 95       	ror	r26
    2dba:	97 95       	ror	r25
    2dbc:	87 95       	ror	r24
    2dbe:	16 94       	lsr	r1
    2dc0:	d1 f7       	brne	.-12     	; 0x2db6 <prvSetupTimerInterrupt+0x2a>
    2dc2:	8b 83       	std	Y+3, r24	; 0x03
    2dc4:	9c 83       	std	Y+4, r25	; 0x04
    2dc6:	ad 83       	std	Y+5, r26	; 0x05
    2dc8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    2dca:	8b 81       	ldd	r24, Y+3	; 0x03
    2dcc:	9c 81       	ldd	r25, Y+4	; 0x04
    2dce:	ad 81       	ldd	r26, Y+5	; 0x05
    2dd0:	be 81       	ldd	r27, Y+6	; 0x06
    2dd2:	01 97       	sbiw	r24, 0x01	; 1
    2dd4:	a1 09       	sbc	r26, r1
    2dd6:	b1 09       	sbc	r27, r1
    2dd8:	8b 83       	std	Y+3, r24	; 0x03
    2dda:	9c 83       	std	Y+4, r25	; 0x04
    2ddc:	ad 83       	std	Y+5, r26	; 0x05
    2dde:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2de0:	8b 81       	ldd	r24, Y+3	; 0x03
    2de2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2de4:	8b 81       	ldd	r24, Y+3	; 0x03
    2de6:	9c 81       	ldd	r25, Y+4	; 0x04
    2de8:	ad 81       	ldd	r26, Y+5	; 0x05
    2dea:	be 81       	ldd	r27, Y+6	; 0x06
    2dec:	89 2f       	mov	r24, r25
    2dee:	9a 2f       	mov	r25, r26
    2df0:	ab 2f       	mov	r26, r27
    2df2:	bb 27       	eor	r27, r27
    2df4:	8b 83       	std	Y+3, r24	; 0x03
    2df6:	9c 83       	std	Y+4, r25	; 0x04
    2df8:	ad 83       	std	Y+5, r26	; 0x05
    2dfa:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2dfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dfe:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2e00:	eb e4       	ldi	r30, 0x4B	; 75
    2e02:	f0 e0       	ldi	r31, 0x00	; 0
    2e04:	8a 81       	ldd	r24, Y+2	; 0x02
    2e06:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2e08:	ea e4       	ldi	r30, 0x4A	; 74
    2e0a:	f0 e0       	ldi	r31, 0x00	; 0
    2e0c:	89 81       	ldd	r24, Y+1	; 0x01
    2e0e:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2e10:	8b e0       	ldi	r24, 0x0B	; 11
    2e12:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2e14:	ee e4       	ldi	r30, 0x4E	; 78
    2e16:	f0 e0       	ldi	r31, 0x00	; 0
    2e18:	89 81       	ldd	r24, Y+1	; 0x01
    2e1a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2e1c:	e9 e5       	ldi	r30, 0x59	; 89
    2e1e:	f0 e0       	ldi	r31, 0x00	; 0
    2e20:	80 81       	ld	r24, Z
    2e22:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2e24:	89 81       	ldd	r24, Y+1	; 0x01
    2e26:	80 61       	ori	r24, 0x10	; 16
    2e28:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2e2a:	e9 e5       	ldi	r30, 0x59	; 89
    2e2c:	f0 e0       	ldi	r31, 0x00	; 0
    2e2e:	89 81       	ldd	r24, Y+1	; 0x01
    2e30:	80 83       	st	Z, r24
}
    2e32:	26 96       	adiw	r28, 0x06	; 6
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2e44:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2e48:	18 95       	reti

00002e4a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2e4a:	df 93       	push	r29
    2e4c:	cf 93       	push	r28
    2e4e:	cd b7       	in	r28, 0x3d	; 61
    2e50:	de b7       	in	r29, 0x3e	; 62
    2e52:	28 97       	sbiw	r28, 0x08	; 8
    2e54:	0f b6       	in	r0, 0x3f	; 63
    2e56:	f8 94       	cli
    2e58:	de bf       	out	0x3e, r29	; 62
    2e5a:	0f be       	out	0x3f, r0	; 63
    2e5c:	cd bf       	out	0x3d, r28	; 61
    2e5e:	8f 83       	std	Y+7, r24	; 0x07
    2e60:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2e62:	1a 82       	std	Y+2, r1	; 0x02
    2e64:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2e66:	8f 81       	ldd	r24, Y+7	; 0x07
    2e68:	88 23       	and	r24, r24
    2e6a:	09 f4       	brne	.+2      	; 0x2e6e <xQueueCreate+0x24>
    2e6c:	8c c0       	rjmp	.+280    	; 0x2f86 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2e6e:	8f e1       	ldi	r24, 0x1F	; 31
    2e70:	90 e0       	ldi	r25, 0x00	; 0
    2e72:	0e 94 0f 12 	call	0x241e	; 0x241e <pvPortMalloc>
    2e76:	9e 83       	std	Y+6, r25	; 0x06
    2e78:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e7e:	00 97       	sbiw	r24, 0x00	; 0
    2e80:	09 f4       	brne	.+2      	; 0x2e84 <xQueueCreate+0x3a>
    2e82:	81 c0       	rjmp	.+258    	; 0x2f86 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2e84:	8f 81       	ldd	r24, Y+7	; 0x07
    2e86:	28 2f       	mov	r18, r24
    2e88:	30 e0       	ldi	r19, 0x00	; 0
    2e8a:	88 85       	ldd	r24, Y+8	; 0x08
    2e8c:	88 2f       	mov	r24, r24
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	ac 01       	movw	r20, r24
    2e92:	24 9f       	mul	r18, r20
    2e94:	c0 01       	movw	r24, r0
    2e96:	25 9f       	mul	r18, r21
    2e98:	90 0d       	add	r25, r0
    2e9a:	34 9f       	mul	r19, r20
    2e9c:	90 0d       	add	r25, r0
    2e9e:	11 24       	eor	r1, r1
    2ea0:	01 96       	adiw	r24, 0x01	; 1
    2ea2:	9c 83       	std	Y+4, r25	; 0x04
    2ea4:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eaa:	0e 94 0f 12 	call	0x241e	; 0x241e <pvPortMalloc>
    2eae:	ed 81       	ldd	r30, Y+5	; 0x05
    2eb0:	fe 81       	ldd	r31, Y+6	; 0x06
    2eb2:	91 83       	std	Z+1, r25	; 0x01
    2eb4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2eb6:	ed 81       	ldd	r30, Y+5	; 0x05
    2eb8:	fe 81       	ldd	r31, Y+6	; 0x06
    2eba:	80 81       	ld	r24, Z
    2ebc:	91 81       	ldd	r25, Z+1	; 0x01
    2ebe:	00 97       	sbiw	r24, 0x00	; 0
    2ec0:	09 f4       	brne	.+2      	; 0x2ec4 <xQueueCreate+0x7a>
    2ec2:	5d c0       	rjmp	.+186    	; 0x2f7e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2ec4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ec6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ec8:	40 81       	ld	r20, Z
    2eca:	51 81       	ldd	r21, Z+1	; 0x01
    2ecc:	8f 81       	ldd	r24, Y+7	; 0x07
    2ece:	28 2f       	mov	r18, r24
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	88 85       	ldd	r24, Y+8	; 0x08
    2ed4:	88 2f       	mov	r24, r24
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	bc 01       	movw	r22, r24
    2eda:	26 9f       	mul	r18, r22
    2edc:	c0 01       	movw	r24, r0
    2ede:	27 9f       	mul	r18, r23
    2ee0:	90 0d       	add	r25, r0
    2ee2:	36 9f       	mul	r19, r22
    2ee4:	90 0d       	add	r25, r0
    2ee6:	11 24       	eor	r1, r1
    2ee8:	84 0f       	add	r24, r20
    2eea:	95 1f       	adc	r25, r21
    2eec:	ed 81       	ldd	r30, Y+5	; 0x05
    2eee:	fe 81       	ldd	r31, Y+6	; 0x06
    2ef0:	93 83       	std	Z+3, r25	; 0x03
    2ef2:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2ef4:	ed 81       	ldd	r30, Y+5	; 0x05
    2ef6:	fe 81       	ldd	r31, Y+6	; 0x06
    2ef8:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2efa:	ed 81       	ldd	r30, Y+5	; 0x05
    2efc:	fe 81       	ldd	r31, Y+6	; 0x06
    2efe:	80 81       	ld	r24, Z
    2f00:	91 81       	ldd	r25, Z+1	; 0x01
    2f02:	ed 81       	ldd	r30, Y+5	; 0x05
    2f04:	fe 81       	ldd	r31, Y+6	; 0x06
    2f06:	95 83       	std	Z+5, r25	; 0x05
    2f08:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2f0a:	ed 81       	ldd	r30, Y+5	; 0x05
    2f0c:	fe 81       	ldd	r31, Y+6	; 0x06
    2f0e:	40 81       	ld	r20, Z
    2f10:	51 81       	ldd	r21, Z+1	; 0x01
    2f12:	8f 81       	ldd	r24, Y+7	; 0x07
    2f14:	88 2f       	mov	r24, r24
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	9c 01       	movw	r18, r24
    2f1a:	21 50       	subi	r18, 0x01	; 1
    2f1c:	30 40       	sbci	r19, 0x00	; 0
    2f1e:	88 85       	ldd	r24, Y+8	; 0x08
    2f20:	88 2f       	mov	r24, r24
    2f22:	90 e0       	ldi	r25, 0x00	; 0
    2f24:	bc 01       	movw	r22, r24
    2f26:	26 9f       	mul	r18, r22
    2f28:	c0 01       	movw	r24, r0
    2f2a:	27 9f       	mul	r18, r23
    2f2c:	90 0d       	add	r25, r0
    2f2e:	36 9f       	mul	r19, r22
    2f30:	90 0d       	add	r25, r0
    2f32:	11 24       	eor	r1, r1
    2f34:	84 0f       	add	r24, r20
    2f36:	95 1f       	adc	r25, r21
    2f38:	ed 81       	ldd	r30, Y+5	; 0x05
    2f3a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f3c:	97 83       	std	Z+7, r25	; 0x07
    2f3e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2f40:	ed 81       	ldd	r30, Y+5	; 0x05
    2f42:	fe 81       	ldd	r31, Y+6	; 0x06
    2f44:	8f 81       	ldd	r24, Y+7	; 0x07
    2f46:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2f48:	ed 81       	ldd	r30, Y+5	; 0x05
    2f4a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f4c:	88 85       	ldd	r24, Y+8	; 0x08
    2f4e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2f50:	ed 81       	ldd	r30, Y+5	; 0x05
    2f52:	fe 81       	ldd	r31, Y+6	; 0x06
    2f54:	8f ef       	ldi	r24, 0xFF	; 255
    2f56:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2f58:	ed 81       	ldd	r30, Y+5	; 0x05
    2f5a:	fe 81       	ldd	r31, Y+6	; 0x06
    2f5c:	8f ef       	ldi	r24, 0xFF	; 255
    2f5e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2f60:	8d 81       	ldd	r24, Y+5	; 0x05
    2f62:	9e 81       	ldd	r25, Y+6	; 0x06
    2f64:	08 96       	adiw	r24, 0x08	; 8
    2f66:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2f6a:	8d 81       	ldd	r24, Y+5	; 0x05
    2f6c:	9e 81       	ldd	r25, Y+6	; 0x06
    2f6e:	41 96       	adiw	r24, 0x11	; 17
    2f70:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2f74:	8d 81       	ldd	r24, Y+5	; 0x05
    2f76:	9e 81       	ldd	r25, Y+6	; 0x06
    2f78:	9a 83       	std	Y+2, r25	; 0x02
    2f7a:	89 83       	std	Y+1, r24	; 0x01
    2f7c:	04 c0       	rjmp	.+8      	; 0x2f86 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2f7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f80:	9e 81       	ldd	r25, Y+6	; 0x06
    2f82:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2f86:	89 81       	ldd	r24, Y+1	; 0x01
    2f88:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f8a:	28 96       	adiw	r28, 0x08	; 8
    2f8c:	0f b6       	in	r0, 0x3f	; 63
    2f8e:	f8 94       	cli
    2f90:	de bf       	out	0x3e, r29	; 62
    2f92:	0f be       	out	0x3f, r0	; 63
    2f94:	cd bf       	out	0x3d, r28	; 61
    2f96:	cf 91       	pop	r28
    2f98:	df 91       	pop	r29
    2f9a:	08 95       	ret

00002f9c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2f9c:	df 93       	push	r29
    2f9e:	cf 93       	push	r28
    2fa0:	cd b7       	in	r28, 0x3d	; 61
    2fa2:	de b7       	in	r29, 0x3e	; 62
    2fa4:	2c 97       	sbiw	r28, 0x0c	; 12
    2fa6:	0f b6       	in	r0, 0x3f	; 63
    2fa8:	f8 94       	cli
    2faa:	de bf       	out	0x3e, r29	; 62
    2fac:	0f be       	out	0x3f, r0	; 63
    2fae:	cd bf       	out	0x3d, r28	; 61
    2fb0:	9e 83       	std	Y+6, r25	; 0x06
    2fb2:	8d 83       	std	Y+5, r24	; 0x05
    2fb4:	78 87       	std	Y+8, r23	; 0x08
    2fb6:	6f 83       	std	Y+7, r22	; 0x07
    2fb8:	5a 87       	std	Y+10, r21	; 0x0a
    2fba:	49 87       	std	Y+9, r20	; 0x09
    2fbc:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2fbe:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2fc0:	0f b6       	in	r0, 0x3f	; 63
    2fc2:	f8 94       	cli
    2fc4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2fc6:	ed 81       	ldd	r30, Y+5	; 0x05
    2fc8:	fe 81       	ldd	r31, Y+6	; 0x06
    2fca:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fcc:	ed 81       	ldd	r30, Y+5	; 0x05
    2fce:	fe 81       	ldd	r31, Y+6	; 0x06
    2fd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    2fd2:	98 17       	cp	r25, r24
    2fd4:	d8 f4       	brcc	.+54     	; 0x300c <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    2fd8:	9e 81       	ldd	r25, Y+6	; 0x06
    2fda:	2f 81       	ldd	r18, Y+7	; 0x07
    2fdc:	38 85       	ldd	r19, Y+8	; 0x08
    2fde:	b9 01       	movw	r22, r18
    2fe0:	4b 85       	ldd	r20, Y+11	; 0x0b
    2fe2:	0e 94 09 1a 	call	0x3412	; 0x3412 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2fe6:	ed 81       	ldd	r30, Y+5	; 0x05
    2fe8:	fe 81       	ldd	r31, Y+6	; 0x06
    2fea:	81 89       	ldd	r24, Z+17	; 0x11
    2fec:	88 23       	and	r24, r24
    2fee:	49 f0       	breq	.+18     	; 0x3002 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2ff0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ff2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ff4:	41 96       	adiw	r24, 0x11	; 17
    2ff6:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    2ffa:	81 30       	cpi	r24, 0x01	; 1
    2ffc:	11 f4       	brne	.+4      	; 0x3002 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2ffe:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3002:	0f 90       	pop	r0
    3004:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3006:	81 e0       	ldi	r24, 0x01	; 1
    3008:	8c 87       	std	Y+12, r24	; 0x0c
    300a:	5c c0       	rjmp	.+184    	; 0x30c4 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    300c:	89 85       	ldd	r24, Y+9	; 0x09
    300e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3010:	00 97       	sbiw	r24, 0x00	; 0
    3012:	21 f4       	brne	.+8      	; 0x301c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3014:	0f 90       	pop	r0
    3016:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3018:	1c 86       	std	Y+12, r1	; 0x0c
    301a:	54 c0       	rjmp	.+168    	; 0x30c4 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	88 23       	and	r24, r24
    3020:	31 f4       	brne	.+12     	; 0x302e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3022:	ce 01       	movw	r24, r28
    3024:	02 96       	adiw	r24, 0x02	; 2
    3026:	0e 94 86 20 	call	0x410c	; 0x410c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    302a:	81 e0       	ldi	r24, 0x01	; 1
    302c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    302e:	0f 90       	pop	r0
    3030:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3032:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3036:	0f b6       	in	r0, 0x3f	; 63
    3038:	f8 94       	cli
    303a:	0f 92       	push	r0
    303c:	ed 81       	ldd	r30, Y+5	; 0x05
    303e:	fe 81       	ldd	r31, Y+6	; 0x06
    3040:	85 8d       	ldd	r24, Z+29	; 0x1d
    3042:	8f 3f       	cpi	r24, 0xFF	; 255
    3044:	19 f4       	brne	.+6      	; 0x304c <xQueueGenericSend+0xb0>
    3046:	ed 81       	ldd	r30, Y+5	; 0x05
    3048:	fe 81       	ldd	r31, Y+6	; 0x06
    304a:	15 8e       	std	Z+29, r1	; 0x1d
    304c:	ed 81       	ldd	r30, Y+5	; 0x05
    304e:	fe 81       	ldd	r31, Y+6	; 0x06
    3050:	86 8d       	ldd	r24, Z+30	; 0x1e
    3052:	8f 3f       	cpi	r24, 0xFF	; 255
    3054:	19 f4       	brne	.+6      	; 0x305c <xQueueGenericSend+0xc0>
    3056:	ed 81       	ldd	r30, Y+5	; 0x05
    3058:	fe 81       	ldd	r31, Y+6	; 0x06
    305a:	16 8e       	std	Z+30, r1	; 0x1e
    305c:	0f 90       	pop	r0
    305e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3060:	ce 01       	movw	r24, r28
    3062:	02 96       	adiw	r24, 0x02	; 2
    3064:	9e 01       	movw	r18, r28
    3066:	27 5f       	subi	r18, 0xF7	; 247
    3068:	3f 4f       	sbci	r19, 0xFF	; 255
    306a:	b9 01       	movw	r22, r18
    306c:	0e 94 9f 20 	call	0x413e	; 0x413e <xTaskCheckForTimeOut>
    3070:	88 23       	and	r24, r24
    3072:	09 f5       	brne	.+66     	; 0x30b6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3074:	8d 81       	ldd	r24, Y+5	; 0x05
    3076:	9e 81       	ldd	r25, Y+6	; 0x06
    3078:	0e 94 6d 1b 	call	0x36da	; 0x36da <prvIsQueueFull>
    307c:	88 23       	and	r24, r24
    307e:	a1 f0       	breq	.+40     	; 0x30a8 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3080:	8d 81       	ldd	r24, Y+5	; 0x05
    3082:	9e 81       	ldd	r25, Y+6	; 0x06
    3084:	08 96       	adiw	r24, 0x08	; 8
    3086:	29 85       	ldd	r18, Y+9	; 0x09
    3088:	3a 85       	ldd	r19, Y+10	; 0x0a
    308a:	b9 01       	movw	r22, r18
    308c:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3090:	8d 81       	ldd	r24, Y+5	; 0x05
    3092:	9e 81       	ldd	r25, Y+6	; 0x06
    3094:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3098:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    309c:	88 23       	and	r24, r24
    309e:	09 f0       	breq	.+2      	; 0x30a2 <xQueueGenericSend+0x106>
    30a0:	8f cf       	rjmp	.-226    	; 0x2fc0 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    30a2:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
    30a6:	8c cf       	rjmp	.-232    	; 0x2fc0 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    30a8:	8d 81       	ldd	r24, Y+5	; 0x05
    30aa:	9e 81       	ldd	r25, Y+6	; 0x06
    30ac:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    30b0:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    30b4:	85 cf       	rjmp	.-246    	; 0x2fc0 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    30b6:	8d 81       	ldd	r24, Y+5	; 0x05
    30b8:	9e 81       	ldd	r25, Y+6	; 0x06
    30ba:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    30be:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    30c2:	1c 86       	std	Y+12, r1	; 0x0c
    30c4:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    30c6:	2c 96       	adiw	r28, 0x0c	; 12
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	de bf       	out	0x3e, r29	; 62
    30ce:	0f be       	out	0x3f, r0	; 63
    30d0:	cd bf       	out	0x3d, r28	; 61
    30d2:	cf 91       	pop	r28
    30d4:	df 91       	pop	r29
    30d6:	08 95       	ret

000030d8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    30d8:	df 93       	push	r29
    30da:	cf 93       	push	r28
    30dc:	cd b7       	in	r28, 0x3d	; 61
    30de:	de b7       	in	r29, 0x3e	; 62
    30e0:	29 97       	sbiw	r28, 0x09	; 9
    30e2:	0f b6       	in	r0, 0x3f	; 63
    30e4:	f8 94       	cli
    30e6:	de bf       	out	0x3e, r29	; 62
    30e8:	0f be       	out	0x3f, r0	; 63
    30ea:	cd bf       	out	0x3d, r28	; 61
    30ec:	9c 83       	std	Y+4, r25	; 0x04
    30ee:	8b 83       	std	Y+3, r24	; 0x03
    30f0:	7e 83       	std	Y+6, r23	; 0x06
    30f2:	6d 83       	std	Y+5, r22	; 0x05
    30f4:	58 87       	std	Y+8, r21	; 0x08
    30f6:	4f 83       	std	Y+7, r20	; 0x07
    30f8:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    30fa:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    30fc:	eb 81       	ldd	r30, Y+3	; 0x03
    30fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3100:	92 8d       	ldd	r25, Z+26	; 0x1a
    3102:	eb 81       	ldd	r30, Y+3	; 0x03
    3104:	fc 81       	ldd	r31, Y+4	; 0x04
    3106:	83 8d       	ldd	r24, Z+27	; 0x1b
    3108:	98 17       	cp	r25, r24
    310a:	40 f5       	brcc	.+80     	; 0x315c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    310c:	8b 81       	ldd	r24, Y+3	; 0x03
    310e:	9c 81       	ldd	r25, Y+4	; 0x04
    3110:	2d 81       	ldd	r18, Y+5	; 0x05
    3112:	3e 81       	ldd	r19, Y+6	; 0x06
    3114:	b9 01       	movw	r22, r18
    3116:	49 85       	ldd	r20, Y+9	; 0x09
    3118:	0e 94 09 1a 	call	0x3412	; 0x3412 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    311c:	eb 81       	ldd	r30, Y+3	; 0x03
    311e:	fc 81       	ldd	r31, Y+4	; 0x04
    3120:	86 8d       	ldd	r24, Z+30	; 0x1e
    3122:	8f 3f       	cpi	r24, 0xFF	; 255
    3124:	89 f4       	brne	.+34     	; 0x3148 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3126:	eb 81       	ldd	r30, Y+3	; 0x03
    3128:	fc 81       	ldd	r31, Y+4	; 0x04
    312a:	81 89       	ldd	r24, Z+17	; 0x11
    312c:	88 23       	and	r24, r24
    312e:	99 f0       	breq	.+38     	; 0x3156 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3130:	8b 81       	ldd	r24, Y+3	; 0x03
    3132:	9c 81       	ldd	r25, Y+4	; 0x04
    3134:	41 96       	adiw	r24, 0x11	; 17
    3136:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    313a:	88 23       	and	r24, r24
    313c:	61 f0       	breq	.+24     	; 0x3156 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    313e:	ef 81       	ldd	r30, Y+7	; 0x07
    3140:	f8 85       	ldd	r31, Y+8	; 0x08
    3142:	81 e0       	ldi	r24, 0x01	; 1
    3144:	80 83       	st	Z, r24
    3146:	07 c0       	rjmp	.+14     	; 0x3156 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3148:	eb 81       	ldd	r30, Y+3	; 0x03
    314a:	fc 81       	ldd	r31, Y+4	; 0x04
    314c:	86 8d       	ldd	r24, Z+30	; 0x1e
    314e:	8f 5f       	subi	r24, 0xFF	; 255
    3150:	eb 81       	ldd	r30, Y+3	; 0x03
    3152:	fc 81       	ldd	r31, Y+4	; 0x04
    3154:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3156:	81 e0       	ldi	r24, 0x01	; 1
    3158:	8a 83       	std	Y+2, r24	; 0x02
    315a:	01 c0       	rjmp	.+2      	; 0x315e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    315c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    315e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3160:	29 96       	adiw	r28, 0x09	; 9
    3162:	0f b6       	in	r0, 0x3f	; 63
    3164:	f8 94       	cli
    3166:	de bf       	out	0x3e, r29	; 62
    3168:	0f be       	out	0x3f, r0	; 63
    316a:	cd bf       	out	0x3d, r28	; 61
    316c:	cf 91       	pop	r28
    316e:	df 91       	pop	r29
    3170:	08 95       	ret

00003172 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3172:	df 93       	push	r29
    3174:	cf 93       	push	r28
    3176:	cd b7       	in	r28, 0x3d	; 61
    3178:	de b7       	in	r29, 0x3e	; 62
    317a:	2e 97       	sbiw	r28, 0x0e	; 14
    317c:	0f b6       	in	r0, 0x3f	; 63
    317e:	f8 94       	cli
    3180:	de bf       	out	0x3e, r29	; 62
    3182:	0f be       	out	0x3f, r0	; 63
    3184:	cd bf       	out	0x3d, r28	; 61
    3186:	98 87       	std	Y+8, r25	; 0x08
    3188:	8f 83       	std	Y+7, r24	; 0x07
    318a:	7a 87       	std	Y+10, r23	; 0x0a
    318c:	69 87       	std	Y+9, r22	; 0x09
    318e:	5c 87       	std	Y+12, r21	; 0x0c
    3190:	4b 87       	std	Y+11, r20	; 0x0b
    3192:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3194:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3196:	0f b6       	in	r0, 0x3f	; 63
    3198:	f8 94       	cli
    319a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    319c:	ef 81       	ldd	r30, Y+7	; 0x07
    319e:	f8 85       	ldd	r31, Y+8	; 0x08
    31a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    31a2:	88 23       	and	r24, r24
    31a4:	09 f4       	brne	.+2      	; 0x31a8 <xQueueGenericReceive+0x36>
    31a6:	3f c0       	rjmp	.+126    	; 0x3226 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    31a8:	ef 81       	ldd	r30, Y+7	; 0x07
    31aa:	f8 85       	ldd	r31, Y+8	; 0x08
    31ac:	86 81       	ldd	r24, Z+6	; 0x06
    31ae:	97 81       	ldd	r25, Z+7	; 0x07
    31b0:	9a 83       	std	Y+2, r25	; 0x02
    31b2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    31b4:	8f 81       	ldd	r24, Y+7	; 0x07
    31b6:	98 85       	ldd	r25, Y+8	; 0x08
    31b8:	29 85       	ldd	r18, Y+9	; 0x09
    31ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    31bc:	b9 01       	movw	r22, r18
    31be:	0e 94 9e 1a 	call	0x353c	; 0x353c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    31c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    31c4:	88 23       	and	r24, r24
    31c6:	b1 f4       	brne	.+44     	; 0x31f4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    31c8:	ef 81       	ldd	r30, Y+7	; 0x07
    31ca:	f8 85       	ldd	r31, Y+8	; 0x08
    31cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    31ce:	81 50       	subi	r24, 0x01	; 1
    31d0:	ef 81       	ldd	r30, Y+7	; 0x07
    31d2:	f8 85       	ldd	r31, Y+8	; 0x08
    31d4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    31d6:	ef 81       	ldd	r30, Y+7	; 0x07
    31d8:	f8 85       	ldd	r31, Y+8	; 0x08
    31da:	80 85       	ldd	r24, Z+8	; 0x08
    31dc:	88 23       	and	r24, r24
    31de:	f1 f0       	breq	.+60     	; 0x321c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    31e0:	8f 81       	ldd	r24, Y+7	; 0x07
    31e2:	98 85       	ldd	r25, Y+8	; 0x08
    31e4:	08 96       	adiw	r24, 0x08	; 8
    31e6:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    31ea:	81 30       	cpi	r24, 0x01	; 1
    31ec:	b9 f4       	brne	.+46     	; 0x321c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    31ee:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
    31f2:	14 c0       	rjmp	.+40     	; 0x321c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    31f4:	ef 81       	ldd	r30, Y+7	; 0x07
    31f6:	f8 85       	ldd	r31, Y+8	; 0x08
    31f8:	89 81       	ldd	r24, Y+1	; 0x01
    31fa:	9a 81       	ldd	r25, Y+2	; 0x02
    31fc:	97 83       	std	Z+7, r25	; 0x07
    31fe:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3200:	ef 81       	ldd	r30, Y+7	; 0x07
    3202:	f8 85       	ldd	r31, Y+8	; 0x08
    3204:	81 89       	ldd	r24, Z+17	; 0x11
    3206:	88 23       	and	r24, r24
    3208:	49 f0       	breq	.+18     	; 0x321c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    320a:	8f 81       	ldd	r24, Y+7	; 0x07
    320c:	98 85       	ldd	r25, Y+8	; 0x08
    320e:	41 96       	adiw	r24, 0x11	; 17
    3210:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    3214:	88 23       	and	r24, r24
    3216:	11 f0       	breq	.+4      	; 0x321c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3218:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    321c:	0f 90       	pop	r0
    321e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3220:	81 e0       	ldi	r24, 0x01	; 1
    3222:	8e 87       	std	Y+14, r24	; 0x0e
    3224:	5c c0       	rjmp	.+184    	; 0x32de <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3226:	8b 85       	ldd	r24, Y+11	; 0x0b
    3228:	9c 85       	ldd	r25, Y+12	; 0x0c
    322a:	00 97       	sbiw	r24, 0x00	; 0
    322c:	21 f4       	brne	.+8      	; 0x3236 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    322e:	0f 90       	pop	r0
    3230:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3232:	1e 86       	std	Y+14, r1	; 0x0e
    3234:	54 c0       	rjmp	.+168    	; 0x32de <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3236:	8b 81       	ldd	r24, Y+3	; 0x03
    3238:	88 23       	and	r24, r24
    323a:	31 f4       	brne	.+12     	; 0x3248 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    323c:	ce 01       	movw	r24, r28
    323e:	04 96       	adiw	r24, 0x04	; 4
    3240:	0e 94 86 20 	call	0x410c	; 0x410c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3244:	81 e0       	ldi	r24, 0x01	; 1
    3246:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3248:	0f 90       	pop	r0
    324a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    324c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3250:	0f b6       	in	r0, 0x3f	; 63
    3252:	f8 94       	cli
    3254:	0f 92       	push	r0
    3256:	ef 81       	ldd	r30, Y+7	; 0x07
    3258:	f8 85       	ldd	r31, Y+8	; 0x08
    325a:	85 8d       	ldd	r24, Z+29	; 0x1d
    325c:	8f 3f       	cpi	r24, 0xFF	; 255
    325e:	19 f4       	brne	.+6      	; 0x3266 <xQueueGenericReceive+0xf4>
    3260:	ef 81       	ldd	r30, Y+7	; 0x07
    3262:	f8 85       	ldd	r31, Y+8	; 0x08
    3264:	15 8e       	std	Z+29, r1	; 0x1d
    3266:	ef 81       	ldd	r30, Y+7	; 0x07
    3268:	f8 85       	ldd	r31, Y+8	; 0x08
    326a:	86 8d       	ldd	r24, Z+30	; 0x1e
    326c:	8f 3f       	cpi	r24, 0xFF	; 255
    326e:	19 f4       	brne	.+6      	; 0x3276 <xQueueGenericReceive+0x104>
    3270:	ef 81       	ldd	r30, Y+7	; 0x07
    3272:	f8 85       	ldd	r31, Y+8	; 0x08
    3274:	16 8e       	std	Z+30, r1	; 0x1e
    3276:	0f 90       	pop	r0
    3278:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    327a:	ce 01       	movw	r24, r28
    327c:	04 96       	adiw	r24, 0x04	; 4
    327e:	9e 01       	movw	r18, r28
    3280:	25 5f       	subi	r18, 0xF5	; 245
    3282:	3f 4f       	sbci	r19, 0xFF	; 255
    3284:	b9 01       	movw	r22, r18
    3286:	0e 94 9f 20 	call	0x413e	; 0x413e <xTaskCheckForTimeOut>
    328a:	88 23       	and	r24, r24
    328c:	09 f5       	brne	.+66     	; 0x32d0 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    328e:	8f 81       	ldd	r24, Y+7	; 0x07
    3290:	98 85       	ldd	r25, Y+8	; 0x08
    3292:	0e 94 3a 1b 	call	0x3674	; 0x3674 <prvIsQueueEmpty>
    3296:	88 23       	and	r24, r24
    3298:	a1 f0       	breq	.+40     	; 0x32c2 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    329a:	8f 81       	ldd	r24, Y+7	; 0x07
    329c:	98 85       	ldd	r25, Y+8	; 0x08
    329e:	41 96       	adiw	r24, 0x11	; 17
    32a0:	2b 85       	ldd	r18, Y+11	; 0x0b
    32a2:	3c 85       	ldd	r19, Y+12	; 0x0c
    32a4:	b9 01       	movw	r22, r18
    32a6:	0e 94 e8 1f 	call	0x3fd0	; 0x3fd0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    32aa:	8f 81       	ldd	r24, Y+7	; 0x07
    32ac:	98 85       	ldd	r25, Y+8	; 0x08
    32ae:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    32b2:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    32b6:	88 23       	and	r24, r24
    32b8:	09 f0       	breq	.+2      	; 0x32bc <xQueueGenericReceive+0x14a>
    32ba:	6d cf       	rjmp	.-294    	; 0x3196 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    32bc:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
    32c0:	6a cf       	rjmp	.-300    	; 0x3196 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    32c2:	8f 81       	ldd	r24, Y+7	; 0x07
    32c4:	98 85       	ldd	r25, Y+8	; 0x08
    32c6:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    32ca:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    32ce:	63 cf       	rjmp	.-314    	; 0x3196 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    32d0:	8f 81       	ldd	r24, Y+7	; 0x07
    32d2:	98 85       	ldd	r25, Y+8	; 0x08
    32d4:	0e 94 e6 1a 	call	0x35cc	; 0x35cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    32d8:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    32dc:	1e 86       	std	Y+14, r1	; 0x0e
    32de:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    32e0:	2e 96       	adiw	r28, 0x0e	; 14
    32e2:	0f b6       	in	r0, 0x3f	; 63
    32e4:	f8 94       	cli
    32e6:	de bf       	out	0x3e, r29	; 62
    32e8:	0f be       	out	0x3f, r0	; 63
    32ea:	cd bf       	out	0x3d, r28	; 61
    32ec:	cf 91       	pop	r28
    32ee:	df 91       	pop	r29
    32f0:	08 95       	ret

000032f2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    32f2:	df 93       	push	r29
    32f4:	cf 93       	push	r28
    32f6:	cd b7       	in	r28, 0x3d	; 61
    32f8:	de b7       	in	r29, 0x3e	; 62
    32fa:	28 97       	sbiw	r28, 0x08	; 8
    32fc:	0f b6       	in	r0, 0x3f	; 63
    32fe:	f8 94       	cli
    3300:	de bf       	out	0x3e, r29	; 62
    3302:	0f be       	out	0x3f, r0	; 63
    3304:	cd bf       	out	0x3d, r28	; 61
    3306:	9c 83       	std	Y+4, r25	; 0x04
    3308:	8b 83       	std	Y+3, r24	; 0x03
    330a:	7e 83       	std	Y+6, r23	; 0x06
    330c:	6d 83       	std	Y+5, r22	; 0x05
    330e:	58 87       	std	Y+8, r21	; 0x08
    3310:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3312:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3314:	eb 81       	ldd	r30, Y+3	; 0x03
    3316:	fc 81       	ldd	r31, Y+4	; 0x04
    3318:	82 8d       	ldd	r24, Z+26	; 0x1a
    331a:	88 23       	and	r24, r24
    331c:	71 f1       	breq	.+92     	; 0x337a <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    331e:	8b 81       	ldd	r24, Y+3	; 0x03
    3320:	9c 81       	ldd	r25, Y+4	; 0x04
    3322:	2d 81       	ldd	r18, Y+5	; 0x05
    3324:	3e 81       	ldd	r19, Y+6	; 0x06
    3326:	b9 01       	movw	r22, r18
    3328:	0e 94 9e 1a 	call	0x353c	; 0x353c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    332c:	eb 81       	ldd	r30, Y+3	; 0x03
    332e:	fc 81       	ldd	r31, Y+4	; 0x04
    3330:	82 8d       	ldd	r24, Z+26	; 0x1a
    3332:	81 50       	subi	r24, 0x01	; 1
    3334:	eb 81       	ldd	r30, Y+3	; 0x03
    3336:	fc 81       	ldd	r31, Y+4	; 0x04
    3338:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    333a:	eb 81       	ldd	r30, Y+3	; 0x03
    333c:	fc 81       	ldd	r31, Y+4	; 0x04
    333e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3340:	8f 3f       	cpi	r24, 0xFF	; 255
    3342:	89 f4       	brne	.+34     	; 0x3366 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3344:	eb 81       	ldd	r30, Y+3	; 0x03
    3346:	fc 81       	ldd	r31, Y+4	; 0x04
    3348:	80 85       	ldd	r24, Z+8	; 0x08
    334a:	88 23       	and	r24, r24
    334c:	99 f0       	breq	.+38     	; 0x3374 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    334e:	8b 81       	ldd	r24, Y+3	; 0x03
    3350:	9c 81       	ldd	r25, Y+4	; 0x04
    3352:	08 96       	adiw	r24, 0x08	; 8
    3354:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    3358:	88 23       	and	r24, r24
    335a:	61 f0       	breq	.+24     	; 0x3374 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    335c:	ef 81       	ldd	r30, Y+7	; 0x07
    335e:	f8 85       	ldd	r31, Y+8	; 0x08
    3360:	81 e0       	ldi	r24, 0x01	; 1
    3362:	80 83       	st	Z, r24
    3364:	07 c0       	rjmp	.+14     	; 0x3374 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3366:	eb 81       	ldd	r30, Y+3	; 0x03
    3368:	fc 81       	ldd	r31, Y+4	; 0x04
    336a:	85 8d       	ldd	r24, Z+29	; 0x1d
    336c:	8f 5f       	subi	r24, 0xFF	; 255
    336e:	eb 81       	ldd	r30, Y+3	; 0x03
    3370:	fc 81       	ldd	r31, Y+4	; 0x04
    3372:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3374:	81 e0       	ldi	r24, 0x01	; 1
    3376:	8a 83       	std	Y+2, r24	; 0x02
    3378:	01 c0       	rjmp	.+2      	; 0x337c <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    337a:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    337c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    337e:	28 96       	adiw	r28, 0x08	; 8
    3380:	0f b6       	in	r0, 0x3f	; 63
    3382:	f8 94       	cli
    3384:	de bf       	out	0x3e, r29	; 62
    3386:	0f be       	out	0x3f, r0	; 63
    3388:	cd bf       	out	0x3d, r28	; 61
    338a:	cf 91       	pop	r28
    338c:	df 91       	pop	r29
    338e:	08 95       	ret

00003390 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3390:	df 93       	push	r29
    3392:	cf 93       	push	r28
    3394:	00 d0       	rcall	.+0      	; 0x3396 <uxQueueMessagesWaiting+0x6>
    3396:	0f 92       	push	r0
    3398:	cd b7       	in	r28, 0x3d	; 61
    339a:	de b7       	in	r29, 0x3e	; 62
    339c:	9b 83       	std	Y+3, r25	; 0x03
    339e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    33a6:	ea 81       	ldd	r30, Y+2	; 0x02
    33a8:	fb 81       	ldd	r31, Y+3	; 0x03
    33aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    33ac:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    33ae:	0f 90       	pop	r0
    33b0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    33b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    33b4:	0f 90       	pop	r0
    33b6:	0f 90       	pop	r0
    33b8:	0f 90       	pop	r0
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    33c0:	df 93       	push	r29
    33c2:	cf 93       	push	r28
    33c4:	00 d0       	rcall	.+0      	; 0x33c6 <uxQueueMessagesWaitingFromISR+0x6>
    33c6:	0f 92       	push	r0
    33c8:	cd b7       	in	r28, 0x3d	; 61
    33ca:	de b7       	in	r29, 0x3e	; 62
    33cc:	9b 83       	std	Y+3, r25	; 0x03
    33ce:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    33d0:	ea 81       	ldd	r30, Y+2	; 0x02
    33d2:	fb 81       	ldd	r31, Y+3	; 0x03
    33d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    33d6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    33d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    33da:	0f 90       	pop	r0
    33dc:	0f 90       	pop	r0
    33de:	0f 90       	pop	r0
    33e0:	cf 91       	pop	r28
    33e2:	df 91       	pop	r29
    33e4:	08 95       	ret

000033e6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    33e6:	df 93       	push	r29
    33e8:	cf 93       	push	r28
    33ea:	00 d0       	rcall	.+0      	; 0x33ec <vQueueDelete+0x6>
    33ec:	cd b7       	in	r28, 0x3d	; 61
    33ee:	de b7       	in	r29, 0x3e	; 62
    33f0:	9a 83       	std	Y+2, r25	; 0x02
    33f2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    33f4:	e9 81       	ldd	r30, Y+1	; 0x01
    33f6:	fa 81       	ldd	r31, Y+2	; 0x02
    33f8:	80 81       	ld	r24, Z
    33fa:	91 81       	ldd	r25, Z+1	; 0x01
    33fc:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
	vPortFree( pxQueue );
    3400:	89 81       	ldd	r24, Y+1	; 0x01
    3402:	9a 81       	ldd	r25, Y+2	; 0x02
    3404:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
}
    3408:	0f 90       	pop	r0
    340a:	0f 90       	pop	r0
    340c:	cf 91       	pop	r28
    340e:	df 91       	pop	r29
    3410:	08 95       	ret

00003412 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3412:	df 93       	push	r29
    3414:	cf 93       	push	r28
    3416:	00 d0       	rcall	.+0      	; 0x3418 <prvCopyDataToQueue+0x6>
    3418:	00 d0       	rcall	.+0      	; 0x341a <prvCopyDataToQueue+0x8>
    341a:	0f 92       	push	r0
    341c:	cd b7       	in	r28, 0x3d	; 61
    341e:	de b7       	in	r29, 0x3e	; 62
    3420:	9a 83       	std	Y+2, r25	; 0x02
    3422:	89 83       	std	Y+1, r24	; 0x01
    3424:	7c 83       	std	Y+4, r23	; 0x04
    3426:	6b 83       	std	Y+3, r22	; 0x03
    3428:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    342a:	e9 81       	ldd	r30, Y+1	; 0x01
    342c:	fa 81       	ldd	r31, Y+2	; 0x02
    342e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3430:	88 23       	and	r24, r24
    3432:	09 f4       	brne	.+2      	; 0x3436 <prvCopyDataToQueue+0x24>
    3434:	74 c0       	rjmp	.+232    	; 0x351e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3436:	8d 81       	ldd	r24, Y+5	; 0x05
    3438:	88 23       	and	r24, r24
    343a:	99 f5       	brne	.+102    	; 0x34a2 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    343c:	e9 81       	ldd	r30, Y+1	; 0x01
    343e:	fa 81       	ldd	r31, Y+2	; 0x02
    3440:	64 81       	ldd	r22, Z+4	; 0x04
    3442:	75 81       	ldd	r23, Z+5	; 0x05
    3444:	e9 81       	ldd	r30, Y+1	; 0x01
    3446:	fa 81       	ldd	r31, Y+2	; 0x02
    3448:	84 8d       	ldd	r24, Z+28	; 0x1c
    344a:	48 2f       	mov	r20, r24
    344c:	50 e0       	ldi	r21, 0x00	; 0
    344e:	2b 81       	ldd	r18, Y+3	; 0x03
    3450:	3c 81       	ldd	r19, Y+4	; 0x04
    3452:	cb 01       	movw	r24, r22
    3454:	b9 01       	movw	r22, r18
    3456:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    345a:	e9 81       	ldd	r30, Y+1	; 0x01
    345c:	fa 81       	ldd	r31, Y+2	; 0x02
    345e:	24 81       	ldd	r18, Z+4	; 0x04
    3460:	35 81       	ldd	r19, Z+5	; 0x05
    3462:	e9 81       	ldd	r30, Y+1	; 0x01
    3464:	fa 81       	ldd	r31, Y+2	; 0x02
    3466:	84 8d       	ldd	r24, Z+28	; 0x1c
    3468:	88 2f       	mov	r24, r24
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	82 0f       	add	r24, r18
    346e:	93 1f       	adc	r25, r19
    3470:	e9 81       	ldd	r30, Y+1	; 0x01
    3472:	fa 81       	ldd	r31, Y+2	; 0x02
    3474:	95 83       	std	Z+5, r25	; 0x05
    3476:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3478:	e9 81       	ldd	r30, Y+1	; 0x01
    347a:	fa 81       	ldd	r31, Y+2	; 0x02
    347c:	24 81       	ldd	r18, Z+4	; 0x04
    347e:	35 81       	ldd	r19, Z+5	; 0x05
    3480:	e9 81       	ldd	r30, Y+1	; 0x01
    3482:	fa 81       	ldd	r31, Y+2	; 0x02
    3484:	82 81       	ldd	r24, Z+2	; 0x02
    3486:	93 81       	ldd	r25, Z+3	; 0x03
    3488:	28 17       	cp	r18, r24
    348a:	39 07       	cpc	r19, r25
    348c:	08 f4       	brcc	.+2      	; 0x3490 <prvCopyDataToQueue+0x7e>
    348e:	47 c0       	rjmp	.+142    	; 0x351e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3490:	e9 81       	ldd	r30, Y+1	; 0x01
    3492:	fa 81       	ldd	r31, Y+2	; 0x02
    3494:	80 81       	ld	r24, Z
    3496:	91 81       	ldd	r25, Z+1	; 0x01
    3498:	e9 81       	ldd	r30, Y+1	; 0x01
    349a:	fa 81       	ldd	r31, Y+2	; 0x02
    349c:	95 83       	std	Z+5, r25	; 0x05
    349e:	84 83       	std	Z+4, r24	; 0x04
    34a0:	3e c0       	rjmp	.+124    	; 0x351e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    34a2:	e9 81       	ldd	r30, Y+1	; 0x01
    34a4:	fa 81       	ldd	r31, Y+2	; 0x02
    34a6:	66 81       	ldd	r22, Z+6	; 0x06
    34a8:	77 81       	ldd	r23, Z+7	; 0x07
    34aa:	e9 81       	ldd	r30, Y+1	; 0x01
    34ac:	fa 81       	ldd	r31, Y+2	; 0x02
    34ae:	84 8d       	ldd	r24, Z+28	; 0x1c
    34b0:	48 2f       	mov	r20, r24
    34b2:	50 e0       	ldi	r21, 0x00	; 0
    34b4:	2b 81       	ldd	r18, Y+3	; 0x03
    34b6:	3c 81       	ldd	r19, Y+4	; 0x04
    34b8:	cb 01       	movw	r24, r22
    34ba:	b9 01       	movw	r22, r18
    34bc:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    34c0:	e9 81       	ldd	r30, Y+1	; 0x01
    34c2:	fa 81       	ldd	r31, Y+2	; 0x02
    34c4:	26 81       	ldd	r18, Z+6	; 0x06
    34c6:	37 81       	ldd	r19, Z+7	; 0x07
    34c8:	e9 81       	ldd	r30, Y+1	; 0x01
    34ca:	fa 81       	ldd	r31, Y+2	; 0x02
    34cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    34ce:	88 2f       	mov	r24, r24
    34d0:	90 e0       	ldi	r25, 0x00	; 0
    34d2:	90 95       	com	r25
    34d4:	81 95       	neg	r24
    34d6:	9f 4f       	sbci	r25, 0xFF	; 255
    34d8:	82 0f       	add	r24, r18
    34da:	93 1f       	adc	r25, r19
    34dc:	e9 81       	ldd	r30, Y+1	; 0x01
    34de:	fa 81       	ldd	r31, Y+2	; 0x02
    34e0:	97 83       	std	Z+7, r25	; 0x07
    34e2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    34e4:	e9 81       	ldd	r30, Y+1	; 0x01
    34e6:	fa 81       	ldd	r31, Y+2	; 0x02
    34e8:	26 81       	ldd	r18, Z+6	; 0x06
    34ea:	37 81       	ldd	r19, Z+7	; 0x07
    34ec:	e9 81       	ldd	r30, Y+1	; 0x01
    34ee:	fa 81       	ldd	r31, Y+2	; 0x02
    34f0:	80 81       	ld	r24, Z
    34f2:	91 81       	ldd	r25, Z+1	; 0x01
    34f4:	28 17       	cp	r18, r24
    34f6:	39 07       	cpc	r19, r25
    34f8:	90 f4       	brcc	.+36     	; 0x351e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    34fa:	e9 81       	ldd	r30, Y+1	; 0x01
    34fc:	fa 81       	ldd	r31, Y+2	; 0x02
    34fe:	22 81       	ldd	r18, Z+2	; 0x02
    3500:	33 81       	ldd	r19, Z+3	; 0x03
    3502:	e9 81       	ldd	r30, Y+1	; 0x01
    3504:	fa 81       	ldd	r31, Y+2	; 0x02
    3506:	84 8d       	ldd	r24, Z+28	; 0x1c
    3508:	88 2f       	mov	r24, r24
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	90 95       	com	r25
    350e:	81 95       	neg	r24
    3510:	9f 4f       	sbci	r25, 0xFF	; 255
    3512:	82 0f       	add	r24, r18
    3514:	93 1f       	adc	r25, r19
    3516:	e9 81       	ldd	r30, Y+1	; 0x01
    3518:	fa 81       	ldd	r31, Y+2	; 0x02
    351a:	97 83       	std	Z+7, r25	; 0x07
    351c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    351e:	e9 81       	ldd	r30, Y+1	; 0x01
    3520:	fa 81       	ldd	r31, Y+2	; 0x02
    3522:	82 8d       	ldd	r24, Z+26	; 0x1a
    3524:	8f 5f       	subi	r24, 0xFF	; 255
    3526:	e9 81       	ldd	r30, Y+1	; 0x01
    3528:	fa 81       	ldd	r31, Y+2	; 0x02
    352a:	82 8f       	std	Z+26, r24	; 0x1a
}
    352c:	0f 90       	pop	r0
    352e:	0f 90       	pop	r0
    3530:	0f 90       	pop	r0
    3532:	0f 90       	pop	r0
    3534:	0f 90       	pop	r0
    3536:	cf 91       	pop	r28
    3538:	df 91       	pop	r29
    353a:	08 95       	ret

0000353c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    353c:	df 93       	push	r29
    353e:	cf 93       	push	r28
    3540:	00 d0       	rcall	.+0      	; 0x3542 <prvCopyDataFromQueue+0x6>
    3542:	00 d0       	rcall	.+0      	; 0x3544 <prvCopyDataFromQueue+0x8>
    3544:	cd b7       	in	r28, 0x3d	; 61
    3546:	de b7       	in	r29, 0x3e	; 62
    3548:	9a 83       	std	Y+2, r25	; 0x02
    354a:	89 83       	std	Y+1, r24	; 0x01
    354c:	7c 83       	std	Y+4, r23	; 0x04
    354e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3550:	e9 81       	ldd	r30, Y+1	; 0x01
    3552:	fa 81       	ldd	r31, Y+2	; 0x02
    3554:	80 81       	ld	r24, Z
    3556:	91 81       	ldd	r25, Z+1	; 0x01
    3558:	00 97       	sbiw	r24, 0x00	; 0
    355a:	89 f1       	breq	.+98     	; 0x35be <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    355c:	e9 81       	ldd	r30, Y+1	; 0x01
    355e:	fa 81       	ldd	r31, Y+2	; 0x02
    3560:	26 81       	ldd	r18, Z+6	; 0x06
    3562:	37 81       	ldd	r19, Z+7	; 0x07
    3564:	e9 81       	ldd	r30, Y+1	; 0x01
    3566:	fa 81       	ldd	r31, Y+2	; 0x02
    3568:	84 8d       	ldd	r24, Z+28	; 0x1c
    356a:	88 2f       	mov	r24, r24
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	82 0f       	add	r24, r18
    3570:	93 1f       	adc	r25, r19
    3572:	e9 81       	ldd	r30, Y+1	; 0x01
    3574:	fa 81       	ldd	r31, Y+2	; 0x02
    3576:	97 83       	std	Z+7, r25	; 0x07
    3578:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    357a:	e9 81       	ldd	r30, Y+1	; 0x01
    357c:	fa 81       	ldd	r31, Y+2	; 0x02
    357e:	26 81       	ldd	r18, Z+6	; 0x06
    3580:	37 81       	ldd	r19, Z+7	; 0x07
    3582:	e9 81       	ldd	r30, Y+1	; 0x01
    3584:	fa 81       	ldd	r31, Y+2	; 0x02
    3586:	82 81       	ldd	r24, Z+2	; 0x02
    3588:	93 81       	ldd	r25, Z+3	; 0x03
    358a:	28 17       	cp	r18, r24
    358c:	39 07       	cpc	r19, r25
    358e:	40 f0       	brcs	.+16     	; 0x35a0 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3590:	e9 81       	ldd	r30, Y+1	; 0x01
    3592:	fa 81       	ldd	r31, Y+2	; 0x02
    3594:	80 81       	ld	r24, Z
    3596:	91 81       	ldd	r25, Z+1	; 0x01
    3598:	e9 81       	ldd	r30, Y+1	; 0x01
    359a:	fa 81       	ldd	r31, Y+2	; 0x02
    359c:	97 83       	std	Z+7, r25	; 0x07
    359e:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    35a0:	e9 81       	ldd	r30, Y+1	; 0x01
    35a2:	fa 81       	ldd	r31, Y+2	; 0x02
    35a4:	46 81       	ldd	r20, Z+6	; 0x06
    35a6:	57 81       	ldd	r21, Z+7	; 0x07
    35a8:	e9 81       	ldd	r30, Y+1	; 0x01
    35aa:	fa 81       	ldd	r31, Y+2	; 0x02
    35ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    35ae:	28 2f       	mov	r18, r24
    35b0:	30 e0       	ldi	r19, 0x00	; 0
    35b2:	8b 81       	ldd	r24, Y+3	; 0x03
    35b4:	9c 81       	ldd	r25, Y+4	; 0x04
    35b6:	ba 01       	movw	r22, r20
    35b8:	a9 01       	movw	r20, r18
    35ba:	0e 94 dc 22 	call	0x45b8	; 0x45b8 <memcpy>
	}
}
    35be:	0f 90       	pop	r0
    35c0:	0f 90       	pop	r0
    35c2:	0f 90       	pop	r0
    35c4:	0f 90       	pop	r0
    35c6:	cf 91       	pop	r28
    35c8:	df 91       	pop	r29
    35ca:	08 95       	ret

000035cc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    35cc:	df 93       	push	r29
    35ce:	cf 93       	push	r28
    35d0:	00 d0       	rcall	.+0      	; 0x35d2 <prvUnlockQueue+0x6>
    35d2:	cd b7       	in	r28, 0x3d	; 61
    35d4:	de b7       	in	r29, 0x3e	; 62
    35d6:	9a 83       	std	Y+2, r25	; 0x02
    35d8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    35da:	0f b6       	in	r0, 0x3f	; 63
    35dc:	f8 94       	cli
    35de:	0f 92       	push	r0
    35e0:	15 c0       	rjmp	.+42     	; 0x360c <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    35e2:	e9 81       	ldd	r30, Y+1	; 0x01
    35e4:	fa 81       	ldd	r31, Y+2	; 0x02
    35e6:	81 89       	ldd	r24, Z+17	; 0x11
    35e8:	88 23       	and	r24, r24
    35ea:	a9 f0       	breq	.+42     	; 0x3616 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    35ec:	89 81       	ldd	r24, Y+1	; 0x01
    35ee:	9a 81       	ldd	r25, Y+2	; 0x02
    35f0:	41 96       	adiw	r24, 0x11	; 17
    35f2:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    35f6:	88 23       	and	r24, r24
    35f8:	11 f0       	breq	.+4      	; 0x35fe <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    35fa:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    35fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3600:	fa 81       	ldd	r31, Y+2	; 0x02
    3602:	86 8d       	ldd	r24, Z+30	; 0x1e
    3604:	81 50       	subi	r24, 0x01	; 1
    3606:	e9 81       	ldd	r30, Y+1	; 0x01
    3608:	fa 81       	ldd	r31, Y+2	; 0x02
    360a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    360c:	e9 81       	ldd	r30, Y+1	; 0x01
    360e:	fa 81       	ldd	r31, Y+2	; 0x02
    3610:	86 8d       	ldd	r24, Z+30	; 0x1e
    3612:	18 16       	cp	r1, r24
    3614:	34 f3       	brlt	.-52     	; 0x35e2 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3616:	e9 81       	ldd	r30, Y+1	; 0x01
    3618:	fa 81       	ldd	r31, Y+2	; 0x02
    361a:	8f ef       	ldi	r24, 0xFF	; 255
    361c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    361e:	0f 90       	pop	r0
    3620:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3622:	0f b6       	in	r0, 0x3f	; 63
    3624:	f8 94       	cli
    3626:	0f 92       	push	r0
    3628:	15 c0       	rjmp	.+42     	; 0x3654 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    362a:	e9 81       	ldd	r30, Y+1	; 0x01
    362c:	fa 81       	ldd	r31, Y+2	; 0x02
    362e:	80 85       	ldd	r24, Z+8	; 0x08
    3630:	88 23       	and	r24, r24
    3632:	a9 f0       	breq	.+42     	; 0x365e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3634:	89 81       	ldd	r24, Y+1	; 0x01
    3636:	9a 81       	ldd	r25, Y+2	; 0x02
    3638:	08 96       	adiw	r24, 0x08	; 8
    363a:	0e 94 1e 20 	call	0x403c	; 0x403c <xTaskRemoveFromEventList>
    363e:	88 23       	and	r24, r24
    3640:	11 f0       	breq	.+4      	; 0x3646 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3642:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3646:	e9 81       	ldd	r30, Y+1	; 0x01
    3648:	fa 81       	ldd	r31, Y+2	; 0x02
    364a:	85 8d       	ldd	r24, Z+29	; 0x1d
    364c:	81 50       	subi	r24, 0x01	; 1
    364e:	e9 81       	ldd	r30, Y+1	; 0x01
    3650:	fa 81       	ldd	r31, Y+2	; 0x02
    3652:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3654:	e9 81       	ldd	r30, Y+1	; 0x01
    3656:	fa 81       	ldd	r31, Y+2	; 0x02
    3658:	85 8d       	ldd	r24, Z+29	; 0x1d
    365a:	18 16       	cp	r1, r24
    365c:	34 f3       	brlt	.-52     	; 0x362a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    365e:	e9 81       	ldd	r30, Y+1	; 0x01
    3660:	fa 81       	ldd	r31, Y+2	; 0x02
    3662:	8f ef       	ldi	r24, 0xFF	; 255
    3664:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3666:	0f 90       	pop	r0
    3668:	0f be       	out	0x3f, r0	; 63
}
    366a:	0f 90       	pop	r0
    366c:	0f 90       	pop	r0
    366e:	cf 91       	pop	r28
    3670:	df 91       	pop	r29
    3672:	08 95       	ret

00003674 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3674:	df 93       	push	r29
    3676:	cf 93       	push	r28
    3678:	00 d0       	rcall	.+0      	; 0x367a <prvIsQueueEmpty+0x6>
    367a:	0f 92       	push	r0
    367c:	cd b7       	in	r28, 0x3d	; 61
    367e:	de b7       	in	r29, 0x3e	; 62
    3680:	9b 83       	std	Y+3, r25	; 0x03
    3682:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3684:	0f b6       	in	r0, 0x3f	; 63
    3686:	f8 94       	cli
    3688:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    368a:	ea 81       	ldd	r30, Y+2	; 0x02
    368c:	fb 81       	ldd	r31, Y+3	; 0x03
    368e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3690:	19 82       	std	Y+1, r1	; 0x01
    3692:	88 23       	and	r24, r24
    3694:	11 f4       	brne	.+4      	; 0x369a <prvIsQueueEmpty+0x26>
    3696:	81 e0       	ldi	r24, 0x01	; 1
    3698:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    369a:	0f 90       	pop	r0
    369c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    369e:	89 81       	ldd	r24, Y+1	; 0x01
}
    36a0:	0f 90       	pop	r0
    36a2:	0f 90       	pop	r0
    36a4:	0f 90       	pop	r0
    36a6:	cf 91       	pop	r28
    36a8:	df 91       	pop	r29
    36aa:	08 95       	ret

000036ac <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    36ac:	df 93       	push	r29
    36ae:	cf 93       	push	r28
    36b0:	00 d0       	rcall	.+0      	; 0x36b2 <xQueueIsQueueEmptyFromISR+0x6>
    36b2:	0f 92       	push	r0
    36b4:	cd b7       	in	r28, 0x3d	; 61
    36b6:	de b7       	in	r29, 0x3e	; 62
    36b8:	9b 83       	std	Y+3, r25	; 0x03
    36ba:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    36bc:	ea 81       	ldd	r30, Y+2	; 0x02
    36be:	fb 81       	ldd	r31, Y+3	; 0x03
    36c0:	82 8d       	ldd	r24, Z+26	; 0x1a
    36c2:	19 82       	std	Y+1, r1	; 0x01
    36c4:	88 23       	and	r24, r24
    36c6:	11 f4       	brne	.+4      	; 0x36cc <xQueueIsQueueEmptyFromISR+0x20>
    36c8:	81 e0       	ldi	r24, 0x01	; 1
    36ca:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    36cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    36ce:	0f 90       	pop	r0
    36d0:	0f 90       	pop	r0
    36d2:	0f 90       	pop	r0
    36d4:	cf 91       	pop	r28
    36d6:	df 91       	pop	r29
    36d8:	08 95       	ret

000036da <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    36da:	df 93       	push	r29
    36dc:	cf 93       	push	r28
    36de:	00 d0       	rcall	.+0      	; 0x36e0 <prvIsQueueFull+0x6>
    36e0:	0f 92       	push	r0
    36e2:	cd b7       	in	r28, 0x3d	; 61
    36e4:	de b7       	in	r29, 0x3e	; 62
    36e6:	9b 83       	std	Y+3, r25	; 0x03
    36e8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    36ea:	0f b6       	in	r0, 0x3f	; 63
    36ec:	f8 94       	cli
    36ee:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    36f0:	ea 81       	ldd	r30, Y+2	; 0x02
    36f2:	fb 81       	ldd	r31, Y+3	; 0x03
    36f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    36f6:	ea 81       	ldd	r30, Y+2	; 0x02
    36f8:	fb 81       	ldd	r31, Y+3	; 0x03
    36fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    36fc:	19 82       	std	Y+1, r1	; 0x01
    36fe:	98 17       	cp	r25, r24
    3700:	11 f4       	brne	.+4      	; 0x3706 <prvIsQueueFull+0x2c>
    3702:	81 e0       	ldi	r24, 0x01	; 1
    3704:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3706:	0f 90       	pop	r0
    3708:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    370a:	89 81       	ldd	r24, Y+1	; 0x01
}
    370c:	0f 90       	pop	r0
    370e:	0f 90       	pop	r0
    3710:	0f 90       	pop	r0
    3712:	cf 91       	pop	r28
    3714:	df 91       	pop	r29
    3716:	08 95       	ret

00003718 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3718:	df 93       	push	r29
    371a:	cf 93       	push	r28
    371c:	00 d0       	rcall	.+0      	; 0x371e <xQueueIsQueueFullFromISR+0x6>
    371e:	0f 92       	push	r0
    3720:	cd b7       	in	r28, 0x3d	; 61
    3722:	de b7       	in	r29, 0x3e	; 62
    3724:	9b 83       	std	Y+3, r25	; 0x03
    3726:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3728:	ea 81       	ldd	r30, Y+2	; 0x02
    372a:	fb 81       	ldd	r31, Y+3	; 0x03
    372c:	92 8d       	ldd	r25, Z+26	; 0x1a
    372e:	ea 81       	ldd	r30, Y+2	; 0x02
    3730:	fb 81       	ldd	r31, Y+3	; 0x03
    3732:	83 8d       	ldd	r24, Z+27	; 0x1b
    3734:	19 82       	std	Y+1, r1	; 0x01
    3736:	98 17       	cp	r25, r24
    3738:	11 f4       	brne	.+4      	; 0x373e <xQueueIsQueueFullFromISR+0x26>
    373a:	81 e0       	ldi	r24, 0x01	; 1
    373c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    373e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3740:	0f 90       	pop	r0
    3742:	0f 90       	pop	r0
    3744:	0f 90       	pop	r0
    3746:	cf 91       	pop	r28
    3748:	df 91       	pop	r29
    374a:	08 95       	ret

0000374c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    374c:	af 92       	push	r10
    374e:	bf 92       	push	r11
    3750:	cf 92       	push	r12
    3752:	df 92       	push	r13
    3754:	ef 92       	push	r14
    3756:	ff 92       	push	r15
    3758:	0f 93       	push	r16
    375a:	1f 93       	push	r17
    375c:	df 93       	push	r29
    375e:	cf 93       	push	r28
    3760:	cd b7       	in	r28, 0x3d	; 61
    3762:	de b7       	in	r29, 0x3e	; 62
    3764:	64 97       	sbiw	r28, 0x14	; 20
    3766:	0f b6       	in	r0, 0x3f	; 63
    3768:	f8 94       	cli
    376a:	de bf       	out	0x3e, r29	; 62
    376c:	0f be       	out	0x3f, r0	; 63
    376e:	cd bf       	out	0x3d, r28	; 61
    3770:	9f 83       	std	Y+7, r25	; 0x07
    3772:	8e 83       	std	Y+6, r24	; 0x06
    3774:	79 87       	std	Y+9, r23	; 0x09
    3776:	68 87       	std	Y+8, r22	; 0x08
    3778:	5b 87       	std	Y+11, r21	; 0x0b
    377a:	4a 87       	std	Y+10, r20	; 0x0a
    377c:	3d 87       	std	Y+13, r19	; 0x0d
    377e:	2c 87       	std	Y+12, r18	; 0x0c
    3780:	0e 87       	std	Y+14, r16	; 0x0e
    3782:	f8 8a       	std	Y+16, r15	; 0x10
    3784:	ef 86       	std	Y+15, r14	; 0x0f
    3786:	da 8a       	std	Y+18, r13	; 0x12
    3788:	c9 8a       	std	Y+17, r12	; 0x11
    378a:	bc 8a       	std	Y+20, r11	; 0x14
    378c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    378e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3790:	9b 85       	ldd	r25, Y+11	; 0x0b
    3792:	29 89       	ldd	r18, Y+17	; 0x11
    3794:	3a 89       	ldd	r19, Y+18	; 0x12
    3796:	b9 01       	movw	r22, r18
    3798:	0e 94 2b 22 	call	0x4456	; 0x4456 <prvAllocateTCBAndStack>
    379c:	9c 83       	std	Y+4, r25	; 0x04
    379e:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    37a0:	8b 81       	ldd	r24, Y+3	; 0x03
    37a2:	9c 81       	ldd	r25, Y+4	; 0x04
    37a4:	00 97       	sbiw	r24, 0x00	; 0
    37a6:	09 f4       	brne	.+2      	; 0x37aa <xTaskGenericCreate+0x5e>
    37a8:	99 c0       	rjmp	.+306    	; 0x38dc <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    37aa:	eb 81       	ldd	r30, Y+3	; 0x03
    37ac:	fc 81       	ldd	r31, Y+4	; 0x04
    37ae:	27 89       	ldd	r18, Z+23	; 0x17
    37b0:	30 8d       	ldd	r19, Z+24	; 0x18
    37b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    37b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    37b6:	01 97       	sbiw	r24, 0x01	; 1
    37b8:	82 0f       	add	r24, r18
    37ba:	93 1f       	adc	r25, r19
    37bc:	9a 83       	std	Y+2, r25	; 0x02
    37be:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    37c0:	8b 81       	ldd	r24, Y+3	; 0x03
    37c2:	9c 81       	ldd	r25, Y+4	; 0x04
    37c4:	28 85       	ldd	r18, Y+8	; 0x08
    37c6:	39 85       	ldd	r19, Y+9	; 0x09
    37c8:	eb 89       	ldd	r30, Y+19	; 0x13
    37ca:	fc 89       	ldd	r31, Y+20	; 0x14
    37cc:	aa 85       	ldd	r26, Y+10	; 0x0a
    37ce:	bb 85       	ldd	r27, Y+11	; 0x0b
    37d0:	b9 01       	movw	r22, r18
    37d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    37d4:	9f 01       	movw	r18, r30
    37d6:	8d 01       	movw	r16, r26
    37d8:	0e 94 10 21 	call	0x4220	; 0x4220 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    37dc:	89 81       	ldd	r24, Y+1	; 0x01
    37de:	9a 81       	ldd	r25, Y+2	; 0x02
    37e0:	2e 81       	ldd	r18, Y+6	; 0x06
    37e2:	3f 81       	ldd	r19, Y+7	; 0x07
    37e4:	4c 85       	ldd	r20, Y+12	; 0x0c
    37e6:	5d 85       	ldd	r21, Y+13	; 0x0d
    37e8:	b9 01       	movw	r22, r18
    37ea:	0e 94 53 14 	call	0x28a6	; 0x28a6 <pxPortInitialiseStack>
    37ee:	eb 81       	ldd	r30, Y+3	; 0x03
    37f0:	fc 81       	ldd	r31, Y+4	; 0x04
    37f2:	91 83       	std	Z+1, r25	; 0x01
    37f4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    37f6:	8f 85       	ldd	r24, Y+15	; 0x0f
    37f8:	98 89       	ldd	r25, Y+16	; 0x10
    37fa:	00 97       	sbiw	r24, 0x00	; 0
    37fc:	31 f0       	breq	.+12     	; 0x380a <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    37fe:	ef 85       	ldd	r30, Y+15	; 0x0f
    3800:	f8 89       	ldd	r31, Y+16	; 0x10
    3802:	8b 81       	ldd	r24, Y+3	; 0x03
    3804:	9c 81       	ldd	r25, Y+4	; 0x04
    3806:	91 83       	std	Z+1, r25	; 0x01
    3808:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    380a:	0f b6       	in	r0, 0x3f	; 63
    380c:	f8 94       	cli
    380e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3810:	80 91 1d 04 	lds	r24, 0x041D
    3814:	8f 5f       	subi	r24, 0xFF	; 255
    3816:	80 93 1d 04 	sts	0x041D, r24
			if( pxCurrentTCB == NULL )
    381a:	80 91 1a 04 	lds	r24, 0x041A
    381e:	90 91 1b 04 	lds	r25, 0x041B
    3822:	00 97       	sbiw	r24, 0x00	; 0
    3824:	69 f4       	brne	.+26     	; 0x3840 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3826:	8b 81       	ldd	r24, Y+3	; 0x03
    3828:	9c 81       	ldd	r25, Y+4	; 0x04
    382a:	90 93 1b 04 	sts	0x041B, r25
    382e:	80 93 1a 04 	sts	0x041A, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3832:	80 91 1d 04 	lds	r24, 0x041D
    3836:	81 30       	cpi	r24, 0x01	; 1
    3838:	a9 f4       	brne	.+42     	; 0x3864 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    383a:	0e 94 67 21 	call	0x42ce	; 0x42ce <prvInitialiseTaskLists>
    383e:	12 c0       	rjmp	.+36     	; 0x3864 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3840:	80 91 22 04 	lds	r24, 0x0422
    3844:	88 23       	and	r24, r24
    3846:	71 f4       	brne	.+28     	; 0x3864 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3848:	e0 91 1a 04 	lds	r30, 0x041A
    384c:	f0 91 1b 04 	lds	r31, 0x041B
    3850:	96 89       	ldd	r25, Z+22	; 0x16
    3852:	8e 85       	ldd	r24, Y+14	; 0x0e
    3854:	89 17       	cp	r24, r25
    3856:	30 f0       	brcs	.+12     	; 0x3864 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3858:	8b 81       	ldd	r24, Y+3	; 0x03
    385a:	9c 81       	ldd	r25, Y+4	; 0x04
    385c:	90 93 1b 04 	sts	0x041B, r25
    3860:	80 93 1a 04 	sts	0x041A, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3864:	eb 81       	ldd	r30, Y+3	; 0x03
    3866:	fc 81       	ldd	r31, Y+4	; 0x04
    3868:	96 89       	ldd	r25, Z+22	; 0x16
    386a:	80 91 20 04 	lds	r24, 0x0420
    386e:	89 17       	cp	r24, r25
    3870:	28 f4       	brcc	.+10     	; 0x387c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3872:	eb 81       	ldd	r30, Y+3	; 0x03
    3874:	fc 81       	ldd	r31, Y+4	; 0x04
    3876:	86 89       	ldd	r24, Z+22	; 0x16
    3878:	80 93 20 04 	sts	0x0420, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    387c:	80 91 27 04 	lds	r24, 0x0427
    3880:	8f 5f       	subi	r24, 0xFF	; 255
    3882:	80 93 27 04 	sts	0x0427, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    3886:	eb 81       	ldd	r30, Y+3	; 0x03
    3888:	fc 81       	ldd	r31, Y+4	; 0x04
    388a:	96 89       	ldd	r25, Z+22	; 0x16
    388c:	80 91 21 04 	lds	r24, 0x0421
    3890:	89 17       	cp	r24, r25
    3892:	28 f4       	brcc	.+10     	; 0x389e <xTaskGenericCreate+0x152>
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	86 89       	ldd	r24, Z+22	; 0x16
    389a:	80 93 21 04 	sts	0x0421, r24
    389e:	eb 81       	ldd	r30, Y+3	; 0x03
    38a0:	fc 81       	ldd	r31, Y+4	; 0x04
    38a2:	86 89       	ldd	r24, Z+22	; 0x16
    38a4:	28 2f       	mov	r18, r24
    38a6:	30 e0       	ldi	r19, 0x00	; 0
    38a8:	c9 01       	movw	r24, r18
    38aa:	88 0f       	add	r24, r24
    38ac:	99 1f       	adc	r25, r25
    38ae:	88 0f       	add	r24, r24
    38b0:	99 1f       	adc	r25, r25
    38b2:	88 0f       	add	r24, r24
    38b4:	99 1f       	adc	r25, r25
    38b6:	82 0f       	add	r24, r18
    38b8:	93 1f       	adc	r25, r19
    38ba:	ac 01       	movw	r20, r24
    38bc:	48 5d       	subi	r20, 0xD8	; 216
    38be:	5b 4f       	sbci	r21, 0xFB	; 251
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	9c 01       	movw	r18, r24
    38c6:	2e 5f       	subi	r18, 0xFE	; 254
    38c8:	3f 4f       	sbci	r19, 0xFF	; 255
    38ca:	ca 01       	movw	r24, r20
    38cc:	b9 01       	movw	r22, r18
    38ce:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>

			xReturn = pdPASS;
    38d2:	81 e0       	ldi	r24, 0x01	; 1
    38d4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    38d6:	0f 90       	pop	r0
    38d8:	0f be       	out	0x3f, r0	; 63
    38da:	02 c0       	rjmp	.+4      	; 0x38e0 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    38dc:	8f ef       	ldi	r24, 0xFF	; 255
    38de:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    38e0:	8d 81       	ldd	r24, Y+5	; 0x05
    38e2:	81 30       	cpi	r24, 0x01	; 1
    38e4:	71 f4       	brne	.+28     	; 0x3902 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    38e6:	80 91 22 04 	lds	r24, 0x0422
    38ea:	88 23       	and	r24, r24
    38ec:	51 f0       	breq	.+20     	; 0x3902 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    38ee:	e0 91 1a 04 	lds	r30, 0x041A
    38f2:	f0 91 1b 04 	lds	r31, 0x041B
    38f6:	96 89       	ldd	r25, Z+22	; 0x16
    38f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    38fa:	98 17       	cp	r25, r24
    38fc:	10 f4       	brcc	.+4      	; 0x3902 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    38fe:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
			}
		}
	}

	return xReturn;
    3902:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3904:	64 96       	adiw	r28, 0x14	; 20
    3906:	0f b6       	in	r0, 0x3f	; 63
    3908:	f8 94       	cli
    390a:	de bf       	out	0x3e, r29	; 62
    390c:	0f be       	out	0x3f, r0	; 63
    390e:	cd bf       	out	0x3d, r28	; 61
    3910:	cf 91       	pop	r28
    3912:	df 91       	pop	r29
    3914:	1f 91       	pop	r17
    3916:	0f 91       	pop	r16
    3918:	ff 90       	pop	r15
    391a:	ef 90       	pop	r14
    391c:	df 90       	pop	r13
    391e:	cf 90       	pop	r12
    3920:	bf 90       	pop	r11
    3922:	af 90       	pop	r10
    3924:	08 95       	ret

00003926 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    3926:	df 93       	push	r29
    3928:	cf 93       	push	r28
    392a:	00 d0       	rcall	.+0      	; 0x392c <vTaskDelete+0x6>
    392c:	00 d0       	rcall	.+0      	; 0x392e <vTaskDelete+0x8>
    392e:	00 d0       	rcall	.+0      	; 0x3930 <vTaskDelete+0xa>
    3930:	cd b7       	in	r28, 0x3d	; 61
    3932:	de b7       	in	r29, 0x3e	; 62
    3934:	9c 83       	std	Y+4, r25	; 0x04
    3936:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3938:	0f b6       	in	r0, 0x3f	; 63
    393a:	f8 94       	cli
    393c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    393e:	20 91 1a 04 	lds	r18, 0x041A
    3942:	30 91 1b 04 	lds	r19, 0x041B
    3946:	8b 81       	ldd	r24, Y+3	; 0x03
    3948:	9c 81       	ldd	r25, Y+4	; 0x04
    394a:	82 17       	cp	r24, r18
    394c:	93 07       	cpc	r25, r19
    394e:	11 f4       	brne	.+4      	; 0x3954 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3950:	1c 82       	std	Y+4, r1	; 0x04
    3952:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3954:	8b 81       	ldd	r24, Y+3	; 0x03
    3956:	9c 81       	ldd	r25, Y+4	; 0x04
    3958:	00 97       	sbiw	r24, 0x00	; 0
    395a:	39 f4       	brne	.+14     	; 0x396a <vTaskDelete+0x44>
    395c:	80 91 1a 04 	lds	r24, 0x041A
    3960:	90 91 1b 04 	lds	r25, 0x041B
    3964:	9e 83       	std	Y+6, r25	; 0x06
    3966:	8d 83       	std	Y+5, r24	; 0x05
    3968:	04 c0       	rjmp	.+8      	; 0x3972 <vTaskDelete+0x4c>
    396a:	8b 81       	ldd	r24, Y+3	; 0x03
    396c:	9c 81       	ldd	r25, Y+4	; 0x04
    396e:	9e 83       	std	Y+6, r25	; 0x06
    3970:	8d 83       	std	Y+5, r24	; 0x05
    3972:	8d 81       	ldd	r24, Y+5	; 0x05
    3974:	9e 81       	ldd	r25, Y+6	; 0x06
    3976:	9a 83       	std	Y+2, r25	; 0x02
    3978:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    397a:	89 81       	ldd	r24, Y+1	; 0x01
    397c:	9a 81       	ldd	r25, Y+2	; 0x02
    397e:	02 96       	adiw	r24, 0x02	; 2
    3980:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    3984:	e9 81       	ldd	r30, Y+1	; 0x01
    3986:	fa 81       	ldd	r31, Y+2	; 0x02
    3988:	84 89       	ldd	r24, Z+20	; 0x14
    398a:	95 89       	ldd	r25, Z+21	; 0x15
    398c:	00 97       	sbiw	r24, 0x00	; 0
    398e:	29 f0       	breq	.+10     	; 0x399a <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    3990:	89 81       	ldd	r24, Y+1	; 0x01
    3992:	9a 81       	ldd	r25, Y+2	; 0x02
    3994:	0c 96       	adiw	r24, 0x0c	; 12
    3996:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    399a:	89 81       	ldd	r24, Y+1	; 0x01
    399c:	9a 81       	ldd	r25, Y+2	; 0x02
    399e:	9c 01       	movw	r18, r24
    39a0:	2e 5f       	subi	r18, 0xFE	; 254
    39a2:	3f 4f       	sbci	r19, 0xFF	; 255
    39a4:	84 e7       	ldi	r24, 0x74	; 116
    39a6:	94 e0       	ldi	r25, 0x04	; 4
    39a8:	b9 01       	movw	r22, r18
    39aa:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    39ae:	80 91 1c 04 	lds	r24, 0x041C
    39b2:	8f 5f       	subi	r24, 0xFF	; 255
    39b4:	80 93 1c 04 	sts	0x041C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    39b8:	80 91 27 04 	lds	r24, 0x0427
    39bc:	8f 5f       	subi	r24, 0xFF	; 255
    39be:	80 93 27 04 	sts	0x0427, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    39c2:	0f 90       	pop	r0
    39c4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    39c6:	80 91 22 04 	lds	r24, 0x0422
    39ca:	88 23       	and	r24, r24
    39cc:	31 f0       	breq	.+12     	; 0x39da <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	9c 81       	ldd	r25, Y+4	; 0x04
    39d2:	00 97       	sbiw	r24, 0x00	; 0
    39d4:	11 f4       	brne	.+4      	; 0x39da <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    39d6:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
			}
		}
	}
    39da:	26 96       	adiw	r28, 0x06	; 6
    39dc:	0f b6       	in	r0, 0x3f	; 63
    39de:	f8 94       	cli
    39e0:	de bf       	out	0x3e, r29	; 62
    39e2:	0f be       	out	0x3f, r0	; 63
    39e4:	cd bf       	out	0x3d, r28	; 61
    39e6:	cf 91       	pop	r28
    39e8:	df 91       	pop	r29
    39ea:	08 95       	ret

000039ec <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    39ec:	df 93       	push	r29
    39ee:	cf 93       	push	r28
    39f0:	cd b7       	in	r28, 0x3d	; 61
    39f2:	de b7       	in	r29, 0x3e	; 62
    39f4:	28 97       	sbiw	r28, 0x08	; 8
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	f8 94       	cli
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	0f be       	out	0x3f, r0	; 63
    39fe:	cd bf       	out	0x3d, r28	; 61
    3a00:	9e 83       	std	Y+6, r25	; 0x06
    3a02:	8d 83       	std	Y+5, r24	; 0x05
    3a04:	78 87       	std	Y+8, r23	; 0x08
    3a06:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    3a08:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3a0a:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3a0e:	ed 81       	ldd	r30, Y+5	; 0x05
    3a10:	fe 81       	ldd	r31, Y+6	; 0x06
    3a12:	20 81       	ld	r18, Z
    3a14:	31 81       	ldd	r19, Z+1	; 0x01
    3a16:	8f 81       	ldd	r24, Y+7	; 0x07
    3a18:	98 85       	ldd	r25, Y+8	; 0x08
    3a1a:	82 0f       	add	r24, r18
    3a1c:	93 1f       	adc	r25, r19
    3a1e:	9c 83       	std	Y+4, r25	; 0x04
    3a20:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3a22:	ed 81       	ldd	r30, Y+5	; 0x05
    3a24:	fe 81       	ldd	r31, Y+6	; 0x06
    3a26:	20 81       	ld	r18, Z
    3a28:	31 81       	ldd	r19, Z+1	; 0x01
    3a2a:	80 91 1e 04 	lds	r24, 0x041E
    3a2e:	90 91 1f 04 	lds	r25, 0x041F
    3a32:	82 17       	cp	r24, r18
    3a34:	93 07       	cpc	r25, r19
    3a36:	a8 f4       	brcc	.+42     	; 0x3a62 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    3a38:	ed 81       	ldd	r30, Y+5	; 0x05
    3a3a:	fe 81       	ldd	r31, Y+6	; 0x06
    3a3c:	20 81       	ld	r18, Z
    3a3e:	31 81       	ldd	r19, Z+1	; 0x01
    3a40:	8b 81       	ldd	r24, Y+3	; 0x03
    3a42:	9c 81       	ldd	r25, Y+4	; 0x04
    3a44:	82 17       	cp	r24, r18
    3a46:	93 07       	cpc	r25, r19
    3a48:	00 f5       	brcc	.+64     	; 0x3a8a <vTaskDelayUntil+0x9e>
    3a4a:	20 91 1e 04 	lds	r18, 0x041E
    3a4e:	30 91 1f 04 	lds	r19, 0x041F
    3a52:	8b 81       	ldd	r24, Y+3	; 0x03
    3a54:	9c 81       	ldd	r25, Y+4	; 0x04
    3a56:	28 17       	cp	r18, r24
    3a58:	39 07       	cpc	r19, r25
    3a5a:	b8 f4       	brcc	.+46     	; 0x3a8a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3a5c:	81 e0       	ldi	r24, 0x01	; 1
    3a5e:	89 83       	std	Y+1, r24	; 0x01
    3a60:	14 c0       	rjmp	.+40     	; 0x3a8a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3a62:	ed 81       	ldd	r30, Y+5	; 0x05
    3a64:	fe 81       	ldd	r31, Y+6	; 0x06
    3a66:	20 81       	ld	r18, Z
    3a68:	31 81       	ldd	r19, Z+1	; 0x01
    3a6a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a6c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a6e:	82 17       	cp	r24, r18
    3a70:	93 07       	cpc	r25, r19
    3a72:	48 f0       	brcs	.+18     	; 0x3a86 <vTaskDelayUntil+0x9a>
    3a74:	20 91 1e 04 	lds	r18, 0x041E
    3a78:	30 91 1f 04 	lds	r19, 0x041F
    3a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a80:	28 17       	cp	r18, r24
    3a82:	39 07       	cpc	r19, r25
    3a84:	10 f4       	brcc	.+4      	; 0x3a8a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3a86:	81 e0       	ldi	r24, 0x01	; 1
    3a88:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3a8a:	ed 81       	ldd	r30, Y+5	; 0x05
    3a8c:	fe 81       	ldd	r31, Y+6	; 0x06
    3a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a90:	9c 81       	ldd	r25, Y+4	; 0x04
    3a92:	91 83       	std	Z+1, r25	; 0x01
    3a94:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3a96:	89 81       	ldd	r24, Y+1	; 0x01
    3a98:	88 23       	and	r24, r24
    3a9a:	59 f0       	breq	.+22     	; 0x3ab2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3a9c:	80 91 1a 04 	lds	r24, 0x041A
    3aa0:	90 91 1b 04 	lds	r25, 0x041B
    3aa4:	02 96       	adiw	r24, 0x02	; 2
    3aa6:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    3aac:	9c 81       	ldd	r25, Y+4	; 0x04
    3aae:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3ab2:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    3ab6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aba:	88 23       	and	r24, r24
    3abc:	11 f4       	brne	.+4      	; 0x3ac2 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3abe:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
		}
	}
    3ac2:	28 96       	adiw	r28, 0x08	; 8
    3ac4:	0f b6       	in	r0, 0x3f	; 63
    3ac6:	f8 94       	cli
    3ac8:	de bf       	out	0x3e, r29	; 62
    3aca:	0f be       	out	0x3f, r0	; 63
    3acc:	cd bf       	out	0x3d, r28	; 61
    3ace:	cf 91       	pop	r28
    3ad0:	df 91       	pop	r29
    3ad2:	08 95       	ret

00003ad4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3ad4:	df 93       	push	r29
    3ad6:	cf 93       	push	r28
    3ad8:	00 d0       	rcall	.+0      	; 0x3ada <vTaskDelay+0x6>
    3ada:	00 d0       	rcall	.+0      	; 0x3adc <vTaskDelay+0x8>
    3adc:	0f 92       	push	r0
    3ade:	cd b7       	in	r28, 0x3d	; 61
    3ae0:	de b7       	in	r29, 0x3e	; 62
    3ae2:	9d 83       	std	Y+5, r25	; 0x05
    3ae4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3ae6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3ae8:	8c 81       	ldd	r24, Y+4	; 0x04
    3aea:	9d 81       	ldd	r25, Y+5	; 0x05
    3aec:	00 97       	sbiw	r24, 0x00	; 0
    3aee:	d1 f0       	breq	.+52     	; 0x3b24 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    3af0:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3af4:	20 91 1e 04 	lds	r18, 0x041E
    3af8:	30 91 1f 04 	lds	r19, 0x041F
    3afc:	8c 81       	ldd	r24, Y+4	; 0x04
    3afe:	9d 81       	ldd	r25, Y+5	; 0x05
    3b00:	82 0f       	add	r24, r18
    3b02:	93 1f       	adc	r25, r19
    3b04:	9b 83       	std	Y+3, r25	; 0x03
    3b06:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3b08:	80 91 1a 04 	lds	r24, 0x041A
    3b0c:	90 91 1b 04 	lds	r25, 0x041B
    3b10:	02 96       	adiw	r24, 0x02	; 2
    3b12:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3b16:	8a 81       	ldd	r24, Y+2	; 0x02
    3b18:	9b 81       	ldd	r25, Y+3	; 0x03
    3b1a:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3b1e:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>
    3b22:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3b24:	89 81       	ldd	r24, Y+1	; 0x01
    3b26:	88 23       	and	r24, r24
    3b28:	11 f4       	brne	.+4      	; 0x3b2e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3b2a:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
		}
	}
    3b2e:	0f 90       	pop	r0
    3b30:	0f 90       	pop	r0
    3b32:	0f 90       	pop	r0
    3b34:	0f 90       	pop	r0
    3b36:	0f 90       	pop	r0
    3b38:	cf 91       	pop	r28
    3b3a:	df 91       	pop	r29
    3b3c:	08 95       	ret

00003b3e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3b3e:	af 92       	push	r10
    3b40:	bf 92       	push	r11
    3b42:	cf 92       	push	r12
    3b44:	df 92       	push	r13
    3b46:	ef 92       	push	r14
    3b48:	ff 92       	push	r15
    3b4a:	0f 93       	push	r16
    3b4c:	df 93       	push	r29
    3b4e:	cf 93       	push	r28
    3b50:	0f 92       	push	r0
    3b52:	cd b7       	in	r28, 0x3d	; 61
    3b54:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    3b56:	24 e7       	ldi	r18, 0x74	; 116
    3b58:	30 e0       	ldi	r19, 0x00	; 0
    3b5a:	86 e0       	ldi	r24, 0x06	; 6
    3b5c:	91 e2       	ldi	r25, 0x21	; 33
    3b5e:	b9 01       	movw	r22, r18
    3b60:	46 e9       	ldi	r20, 0x96	; 150
    3b62:	50 e0       	ldi	r21, 0x00	; 0
    3b64:	20 e0       	ldi	r18, 0x00	; 0
    3b66:	30 e0       	ldi	r19, 0x00	; 0
    3b68:	00 e0       	ldi	r16, 0x00	; 0
    3b6a:	ee 24       	eor	r14, r14
    3b6c:	ff 24       	eor	r15, r15
    3b6e:	cc 24       	eor	r12, r12
    3b70:	dd 24       	eor	r13, r13
    3b72:	aa 24       	eor	r10, r10
    3b74:	bb 24       	eor	r11, r11
    3b76:	0e 94 a6 1b 	call	0x374c	; 0x374c <xTaskGenericCreate>
    3b7a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3b7c:	89 81       	ldd	r24, Y+1	; 0x01
    3b7e:	81 30       	cpi	r24, 0x01	; 1
    3b80:	51 f4       	brne	.+20     	; 0x3b96 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3b82:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3b84:	81 e0       	ldi	r24, 0x01	; 1
    3b86:	80 93 22 04 	sts	0x0422, r24
		xTickCount = ( portTickType ) 0U;
    3b8a:	10 92 1f 04 	sts	0x041F, r1
    3b8e:	10 92 1e 04 	sts	0x041E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3b92:	0e 94 d6 15 	call	0x2bac	; 0x2bac <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    3b96:	0f 90       	pop	r0
    3b98:	cf 91       	pop	r28
    3b9a:	df 91       	pop	r29
    3b9c:	0f 91       	pop	r16
    3b9e:	ff 90       	pop	r15
    3ba0:	ef 90       	pop	r14
    3ba2:	df 90       	pop	r13
    3ba4:	cf 90       	pop	r12
    3ba6:	bf 90       	pop	r11
    3ba8:	af 90       	pop	r10
    3baa:	08 95       	ret

00003bac <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3bac:	df 93       	push	r29
    3bae:	cf 93       	push	r28
    3bb0:	cd b7       	in	r28, 0x3d	; 61
    3bb2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3bb4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3bb6:	10 92 22 04 	sts	0x0422, r1
	vPortEndScheduler();
    3bba:	0e 94 0b 16 	call	0x2c16	; 0x2c16 <vPortEndScheduler>
}
    3bbe:	cf 91       	pop	r28
    3bc0:	df 91       	pop	r29
    3bc2:	08 95       	ret

00003bc4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3bc4:	df 93       	push	r29
    3bc6:	cf 93       	push	r28
    3bc8:	cd b7       	in	r28, 0x3d	; 61
    3bca:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    3bcc:	80 91 23 04 	lds	r24, 0x0423
    3bd0:	8f 5f       	subi	r24, 0xFF	; 255
    3bd2:	80 93 23 04 	sts	0x0423, r24
}
    3bd6:	cf 91       	pop	r28
    3bd8:	df 91       	pop	r29
    3bda:	08 95       	ret

00003bdc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    3bdc:	df 93       	push	r29
    3bde:	cf 93       	push	r28
    3be0:	00 d0       	rcall	.+0      	; 0x3be2 <xTaskResumeAll+0x6>
    3be2:	00 d0       	rcall	.+0      	; 0x3be4 <xTaskResumeAll+0x8>
    3be4:	cd b7       	in	r28, 0x3d	; 61
    3be6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3be8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3bea:	0f b6       	in	r0, 0x3f	; 63
    3bec:	f8 94       	cli
    3bee:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3bf0:	80 91 23 04 	lds	r24, 0x0423
    3bf4:	81 50       	subi	r24, 0x01	; 1
    3bf6:	80 93 23 04 	sts	0x0423, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3bfa:	80 91 23 04 	lds	r24, 0x0423
    3bfe:	88 23       	and	r24, r24
    3c00:	09 f0       	breq	.+2      	; 0x3c04 <xTaskResumeAll+0x28>
    3c02:	6c c0       	rjmp	.+216    	; 0x3cdc <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    3c04:	80 91 1d 04 	lds	r24, 0x041D
    3c08:	88 23       	and	r24, r24
    3c0a:	09 f4       	brne	.+2      	; 0x3c0e <xTaskResumeAll+0x32>
    3c0c:	67 c0       	rjmp	.+206    	; 0x3cdc <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3c0e:	19 82       	std	Y+1, r1	; 0x01
    3c10:	41 c0       	rjmp	.+130    	; 0x3c94 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3c12:	e0 91 70 04 	lds	r30, 0x0470
    3c16:	f0 91 71 04 	lds	r31, 0x0471
    3c1a:	86 81       	ldd	r24, Z+6	; 0x06
    3c1c:	97 81       	ldd	r25, Z+7	; 0x07
    3c1e:	9c 83       	std	Y+4, r25	; 0x04
    3c20:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3c22:	8b 81       	ldd	r24, Y+3	; 0x03
    3c24:	9c 81       	ldd	r25, Y+4	; 0x04
    3c26:	0c 96       	adiw	r24, 0x0c	; 12
    3c28:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c30:	02 96       	adiw	r24, 0x02	; 2
    3c32:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3c36:	eb 81       	ldd	r30, Y+3	; 0x03
    3c38:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3a:	96 89       	ldd	r25, Z+22	; 0x16
    3c3c:	80 91 21 04 	lds	r24, 0x0421
    3c40:	89 17       	cp	r24, r25
    3c42:	28 f4       	brcc	.+10     	; 0x3c4e <xTaskResumeAll+0x72>
    3c44:	eb 81       	ldd	r30, Y+3	; 0x03
    3c46:	fc 81       	ldd	r31, Y+4	; 0x04
    3c48:	86 89       	ldd	r24, Z+22	; 0x16
    3c4a:	80 93 21 04 	sts	0x0421, r24
    3c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c50:	fc 81       	ldd	r31, Y+4	; 0x04
    3c52:	86 89       	ldd	r24, Z+22	; 0x16
    3c54:	28 2f       	mov	r18, r24
    3c56:	30 e0       	ldi	r19, 0x00	; 0
    3c58:	c9 01       	movw	r24, r18
    3c5a:	88 0f       	add	r24, r24
    3c5c:	99 1f       	adc	r25, r25
    3c5e:	88 0f       	add	r24, r24
    3c60:	99 1f       	adc	r25, r25
    3c62:	88 0f       	add	r24, r24
    3c64:	99 1f       	adc	r25, r25
    3c66:	82 0f       	add	r24, r18
    3c68:	93 1f       	adc	r25, r19
    3c6a:	88 5d       	subi	r24, 0xD8	; 216
    3c6c:	9b 4f       	sbci	r25, 0xFB	; 251
    3c6e:	2b 81       	ldd	r18, Y+3	; 0x03
    3c70:	3c 81       	ldd	r19, Y+4	; 0x04
    3c72:	2e 5f       	subi	r18, 0xFE	; 254
    3c74:	3f 4f       	sbci	r19, 0xFF	; 255
    3c76:	b9 01       	movw	r22, r18
    3c78:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3c7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c80:	96 89       	ldd	r25, Z+22	; 0x16
    3c82:	e0 91 1a 04 	lds	r30, 0x041A
    3c86:	f0 91 1b 04 	lds	r31, 0x041B
    3c8a:	86 89       	ldd	r24, Z+22	; 0x16
    3c8c:	98 17       	cp	r25, r24
    3c8e:	10 f0       	brcs	.+4      	; 0x3c94 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3c90:	81 e0       	ldi	r24, 0x01	; 1
    3c92:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3c94:	80 91 6b 04 	lds	r24, 0x046B
    3c98:	88 23       	and	r24, r24
    3c9a:	09 f0       	breq	.+2      	; 0x3c9e <xTaskResumeAll+0xc2>
    3c9c:	ba cf       	rjmp	.-140    	; 0x3c12 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3c9e:	80 91 24 04 	lds	r24, 0x0424
    3ca2:	88 23       	and	r24, r24
    3ca4:	71 f0       	breq	.+28     	; 0x3cc2 <xTaskResumeAll+0xe6>
    3ca6:	07 c0       	rjmp	.+14     	; 0x3cb6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3ca8:	0e 94 ad 1e 	call	0x3d5a	; 0x3d5a <vTaskIncrementTick>
						--uxMissedTicks;
    3cac:	80 91 24 04 	lds	r24, 0x0424
    3cb0:	81 50       	subi	r24, 0x01	; 1
    3cb2:	80 93 24 04 	sts	0x0424, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3cb6:	80 91 24 04 	lds	r24, 0x0424
    3cba:	88 23       	and	r24, r24
    3cbc:	a9 f7       	brne	.-22     	; 0x3ca8 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    3cbe:	81 e0       	ldi	r24, 0x01	; 1
    3cc0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    3cc2:	89 81       	ldd	r24, Y+1	; 0x01
    3cc4:	81 30       	cpi	r24, 0x01	; 1
    3cc6:	21 f0       	breq	.+8      	; 0x3cd0 <xTaskResumeAll+0xf4>
    3cc8:	80 91 25 04 	lds	r24, 0x0425
    3ccc:	81 30       	cpi	r24, 0x01	; 1
    3cce:	31 f4       	brne	.+12     	; 0x3cdc <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    3cd0:	81 e0       	ldi	r24, 0x01	; 1
    3cd2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    3cd4:	10 92 25 04 	sts	0x0425, r1
					portYIELD_WITHIN_API();
    3cd8:	0e 94 12 16 	call	0x2c24	; 0x2c24 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    3cdc:	0f 90       	pop	r0
    3cde:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3ce0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3ce2:	0f 90       	pop	r0
    3ce4:	0f 90       	pop	r0
    3ce6:	0f 90       	pop	r0
    3ce8:	0f 90       	pop	r0
    3cea:	cf 91       	pop	r28
    3cec:	df 91       	pop	r29
    3cee:	08 95       	ret

00003cf0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3cf0:	df 93       	push	r29
    3cf2:	cf 93       	push	r28
    3cf4:	00 d0       	rcall	.+0      	; 0x3cf6 <xTaskGetTickCount+0x6>
    3cf6:	cd b7       	in	r28, 0x3d	; 61
    3cf8:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3cfa:	0f b6       	in	r0, 0x3f	; 63
    3cfc:	f8 94       	cli
    3cfe:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3d00:	80 91 1e 04 	lds	r24, 0x041E
    3d04:	90 91 1f 04 	lds	r25, 0x041F
    3d08:	9a 83       	std	Y+2, r25	; 0x02
    3d0a:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3d0c:	0f 90       	pop	r0
    3d0e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3d14:	0f 90       	pop	r0
    3d16:	0f 90       	pop	r0
    3d18:	cf 91       	pop	r28
    3d1a:	df 91       	pop	r29
    3d1c:	08 95       	ret

00003d1e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3d1e:	df 93       	push	r29
    3d20:	cf 93       	push	r28
    3d22:	00 d0       	rcall	.+0      	; 0x3d24 <xTaskGetTickCountFromISR+0x6>
    3d24:	0f 92       	push	r0
    3d26:	cd b7       	in	r28, 0x3d	; 61
    3d28:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d2a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3d2c:	80 91 1e 04 	lds	r24, 0x041E
    3d30:	90 91 1f 04 	lds	r25, 0x041F
    3d34:	9b 83       	std	Y+3, r25	; 0x03
    3d36:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3d38:	8a 81       	ldd	r24, Y+2	; 0x02
    3d3a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3d3c:	0f 90       	pop	r0
    3d3e:	0f 90       	pop	r0
    3d40:	0f 90       	pop	r0
    3d42:	cf 91       	pop	r28
    3d44:	df 91       	pop	r29
    3d46:	08 95       	ret

00003d48 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3d48:	df 93       	push	r29
    3d4a:	cf 93       	push	r28
    3d4c:	cd b7       	in	r28, 0x3d	; 61
    3d4e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3d50:	80 91 1d 04 	lds	r24, 0x041D
}
    3d54:	cf 91       	pop	r28
    3d56:	df 91       	pop	r29
    3d58:	08 95       	ret

00003d5a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3d5a:	df 93       	push	r29
    3d5c:	cf 93       	push	r28
    3d5e:	00 d0       	rcall	.+0      	; 0x3d60 <vTaskIncrementTick+0x6>
    3d60:	00 d0       	rcall	.+0      	; 0x3d62 <vTaskIncrementTick+0x8>
    3d62:	00 d0       	rcall	.+0      	; 0x3d64 <vTaskIncrementTick+0xa>
    3d64:	cd b7       	in	r28, 0x3d	; 61
    3d66:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3d68:	80 91 23 04 	lds	r24, 0x0423
    3d6c:	88 23       	and	r24, r24
    3d6e:	09 f0       	breq	.+2      	; 0x3d72 <vTaskIncrementTick+0x18>
    3d70:	bb c0       	rjmp	.+374    	; 0x3ee8 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3d72:	80 91 1e 04 	lds	r24, 0x041E
    3d76:	90 91 1f 04 	lds	r25, 0x041F
    3d7a:	01 96       	adiw	r24, 0x01	; 1
    3d7c:	90 93 1f 04 	sts	0x041F, r25
    3d80:	80 93 1e 04 	sts	0x041E, r24
		if( xTickCount == ( portTickType ) 0U )
    3d84:	80 91 1e 04 	lds	r24, 0x041E
    3d88:	90 91 1f 04 	lds	r25, 0x041F
    3d8c:	00 97       	sbiw	r24, 0x00	; 0
    3d8e:	d1 f5       	brne	.+116    	; 0x3e04 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3d90:	80 91 67 04 	lds	r24, 0x0467
    3d94:	90 91 68 04 	lds	r25, 0x0468
    3d98:	9c 83       	std	Y+4, r25	; 0x04
    3d9a:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3d9c:	80 91 69 04 	lds	r24, 0x0469
    3da0:	90 91 6a 04 	lds	r25, 0x046A
    3da4:	90 93 68 04 	sts	0x0468, r25
    3da8:	80 93 67 04 	sts	0x0467, r24
			pxOverflowDelayedTaskList = pxTemp;
    3dac:	8b 81       	ldd	r24, Y+3	; 0x03
    3dae:	9c 81       	ldd	r25, Y+4	; 0x04
    3db0:	90 93 6a 04 	sts	0x046A, r25
    3db4:	80 93 69 04 	sts	0x0469, r24
			xNumOfOverflows++;
    3db8:	80 91 26 04 	lds	r24, 0x0426
    3dbc:	8f 5f       	subi	r24, 0xFF	; 255
    3dbe:	80 93 26 04 	sts	0x0426, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3dc2:	e0 91 67 04 	lds	r30, 0x0467
    3dc6:	f0 91 68 04 	lds	r31, 0x0468
    3dca:	80 81       	ld	r24, Z
    3dcc:	88 23       	and	r24, r24
    3dce:	39 f4       	brne	.+14     	; 0x3dde <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    3dd0:	8f ef       	ldi	r24, 0xFF	; 255
    3dd2:	9f ef       	ldi	r25, 0xFF	; 255
    3dd4:	90 93 82 01 	sts	0x0182, r25
    3dd8:	80 93 81 01 	sts	0x0181, r24
    3ddc:	13 c0       	rjmp	.+38     	; 0x3e04 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3dde:	e0 91 67 04 	lds	r30, 0x0467
    3de2:	f0 91 68 04 	lds	r31, 0x0468
    3de6:	05 80       	ldd	r0, Z+5	; 0x05
    3de8:	f6 81       	ldd	r31, Z+6	; 0x06
    3dea:	e0 2d       	mov	r30, r0
    3dec:	86 81       	ldd	r24, Z+6	; 0x06
    3dee:	97 81       	ldd	r25, Z+7	; 0x07
    3df0:	9e 83       	std	Y+6, r25	; 0x06
    3df2:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3df4:	ed 81       	ldd	r30, Y+5	; 0x05
    3df6:	fe 81       	ldd	r31, Y+6	; 0x06
    3df8:	82 81       	ldd	r24, Z+2	; 0x02
    3dfa:	93 81       	ldd	r25, Z+3	; 0x03
    3dfc:	90 93 82 01 	sts	0x0182, r25
    3e00:	80 93 81 01 	sts	0x0181, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    3e04:	20 91 1e 04 	lds	r18, 0x041E
    3e08:	30 91 1f 04 	lds	r19, 0x041F
    3e0c:	80 91 81 01 	lds	r24, 0x0181
    3e10:	90 91 82 01 	lds	r25, 0x0182
    3e14:	28 17       	cp	r18, r24
    3e16:	39 07       	cpc	r19, r25
    3e18:	08 f4       	brcc	.+2      	; 0x3e1c <vTaskIncrementTick+0xc2>
    3e1a:	6b c0       	rjmp	.+214    	; 0x3ef2 <vTaskIncrementTick+0x198>
    3e1c:	e0 91 67 04 	lds	r30, 0x0467
    3e20:	f0 91 68 04 	lds	r31, 0x0468
    3e24:	80 81       	ld	r24, Z
    3e26:	88 23       	and	r24, r24
    3e28:	39 f4       	brne	.+14     	; 0x3e38 <vTaskIncrementTick+0xde>
    3e2a:	8f ef       	ldi	r24, 0xFF	; 255
    3e2c:	9f ef       	ldi	r25, 0xFF	; 255
    3e2e:	90 93 82 01 	sts	0x0182, r25
    3e32:	80 93 81 01 	sts	0x0181, r24
    3e36:	5d c0       	rjmp	.+186    	; 0x3ef2 <vTaskIncrementTick+0x198>
    3e38:	e0 91 67 04 	lds	r30, 0x0467
    3e3c:	f0 91 68 04 	lds	r31, 0x0468
    3e40:	05 80       	ldd	r0, Z+5	; 0x05
    3e42:	f6 81       	ldd	r31, Z+6	; 0x06
    3e44:	e0 2d       	mov	r30, r0
    3e46:	86 81       	ldd	r24, Z+6	; 0x06
    3e48:	97 81       	ldd	r25, Z+7	; 0x07
    3e4a:	9e 83       	std	Y+6, r25	; 0x06
    3e4c:	8d 83       	std	Y+5, r24	; 0x05
    3e4e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e50:	fe 81       	ldd	r31, Y+6	; 0x06
    3e52:	82 81       	ldd	r24, Z+2	; 0x02
    3e54:	93 81       	ldd	r25, Z+3	; 0x03
    3e56:	9a 83       	std	Y+2, r25	; 0x02
    3e58:	89 83       	std	Y+1, r24	; 0x01
    3e5a:	20 91 1e 04 	lds	r18, 0x041E
    3e5e:	30 91 1f 04 	lds	r19, 0x041F
    3e62:	89 81       	ldd	r24, Y+1	; 0x01
    3e64:	9a 81       	ldd	r25, Y+2	; 0x02
    3e66:	28 17       	cp	r18, r24
    3e68:	39 07       	cpc	r19, r25
    3e6a:	38 f4       	brcc	.+14     	; 0x3e7a <vTaskIncrementTick+0x120>
    3e6c:	89 81       	ldd	r24, Y+1	; 0x01
    3e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e70:	90 93 82 01 	sts	0x0182, r25
    3e74:	80 93 81 01 	sts	0x0181, r24
    3e78:	3c c0       	rjmp	.+120    	; 0x3ef2 <vTaskIncrementTick+0x198>
    3e7a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e7c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e7e:	02 96       	adiw	r24, 0x02	; 2
    3e80:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
    3e84:	ed 81       	ldd	r30, Y+5	; 0x05
    3e86:	fe 81       	ldd	r31, Y+6	; 0x06
    3e88:	84 89       	ldd	r24, Z+20	; 0x14
    3e8a:	95 89       	ldd	r25, Z+21	; 0x15
    3e8c:	00 97       	sbiw	r24, 0x00	; 0
    3e8e:	29 f0       	breq	.+10     	; 0x3e9a <vTaskIncrementTick+0x140>
    3e90:	8d 81       	ldd	r24, Y+5	; 0x05
    3e92:	9e 81       	ldd	r25, Y+6	; 0x06
    3e94:	0c 96       	adiw	r24, 0x0c	; 12
    3e96:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
    3e9a:	ed 81       	ldd	r30, Y+5	; 0x05
    3e9c:	fe 81       	ldd	r31, Y+6	; 0x06
    3e9e:	96 89       	ldd	r25, Z+22	; 0x16
    3ea0:	80 91 21 04 	lds	r24, 0x0421
    3ea4:	89 17       	cp	r24, r25
    3ea6:	28 f4       	brcc	.+10     	; 0x3eb2 <vTaskIncrementTick+0x158>
    3ea8:	ed 81       	ldd	r30, Y+5	; 0x05
    3eaa:	fe 81       	ldd	r31, Y+6	; 0x06
    3eac:	86 89       	ldd	r24, Z+22	; 0x16
    3eae:	80 93 21 04 	sts	0x0421, r24
    3eb2:	ed 81       	ldd	r30, Y+5	; 0x05
    3eb4:	fe 81       	ldd	r31, Y+6	; 0x06
    3eb6:	86 89       	ldd	r24, Z+22	; 0x16
    3eb8:	28 2f       	mov	r18, r24
    3eba:	30 e0       	ldi	r19, 0x00	; 0
    3ebc:	c9 01       	movw	r24, r18
    3ebe:	88 0f       	add	r24, r24
    3ec0:	99 1f       	adc	r25, r25
    3ec2:	88 0f       	add	r24, r24
    3ec4:	99 1f       	adc	r25, r25
    3ec6:	88 0f       	add	r24, r24
    3ec8:	99 1f       	adc	r25, r25
    3eca:	82 0f       	add	r24, r18
    3ecc:	93 1f       	adc	r25, r19
    3ece:	ac 01       	movw	r20, r24
    3ed0:	48 5d       	subi	r20, 0xD8	; 216
    3ed2:	5b 4f       	sbci	r21, 0xFB	; 251
    3ed4:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed6:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed8:	9c 01       	movw	r18, r24
    3eda:	2e 5f       	subi	r18, 0xFE	; 254
    3edc:	3f 4f       	sbci	r19, 0xFF	; 255
    3ede:	ca 01       	movw	r24, r20
    3ee0:	b9 01       	movw	r22, r18
    3ee2:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>
    3ee6:	9a cf       	rjmp	.-204    	; 0x3e1c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3ee8:	80 91 24 04 	lds	r24, 0x0424
    3eec:	8f 5f       	subi	r24, 0xFF	; 255
    3eee:	80 93 24 04 	sts	0x0424, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3ef2:	26 96       	adiw	r28, 0x06	; 6
    3ef4:	0f b6       	in	r0, 0x3f	; 63
    3ef6:	f8 94       	cli
    3ef8:	de bf       	out	0x3e, r29	; 62
    3efa:	0f be       	out	0x3f, r0	; 63
    3efc:	cd bf       	out	0x3d, r28	; 61
    3efe:	cf 91       	pop	r28
    3f00:	df 91       	pop	r29
    3f02:	08 95       	ret

00003f04 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3f04:	df 93       	push	r29
    3f06:	cf 93       	push	r28
    3f08:	00 d0       	rcall	.+0      	; 0x3f0a <vTaskSwitchContext+0x6>
    3f0a:	cd b7       	in	r28, 0x3d	; 61
    3f0c:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3f0e:	80 91 23 04 	lds	r24, 0x0423
    3f12:	88 23       	and	r24, r24
    3f14:	49 f0       	breq	.+18     	; 0x3f28 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3f16:	81 e0       	ldi	r24, 0x01	; 1
    3f18:	80 93 25 04 	sts	0x0425, r24
    3f1c:	54 c0       	rjmp	.+168    	; 0x3fc6 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3f1e:	80 91 21 04 	lds	r24, 0x0421
    3f22:	81 50       	subi	r24, 0x01	; 1
    3f24:	80 93 21 04 	sts	0x0421, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3f28:	80 91 21 04 	lds	r24, 0x0421
    3f2c:	28 2f       	mov	r18, r24
    3f2e:	30 e0       	ldi	r19, 0x00	; 0
    3f30:	c9 01       	movw	r24, r18
    3f32:	88 0f       	add	r24, r24
    3f34:	99 1f       	adc	r25, r25
    3f36:	88 0f       	add	r24, r24
    3f38:	99 1f       	adc	r25, r25
    3f3a:	88 0f       	add	r24, r24
    3f3c:	99 1f       	adc	r25, r25
    3f3e:	82 0f       	add	r24, r18
    3f40:	93 1f       	adc	r25, r19
    3f42:	fc 01       	movw	r30, r24
    3f44:	e8 5d       	subi	r30, 0xD8	; 216
    3f46:	fb 4f       	sbci	r31, 0xFB	; 251
    3f48:	80 81       	ld	r24, Z
    3f4a:	88 23       	and	r24, r24
    3f4c:	41 f3       	breq	.-48     	; 0x3f1e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3f4e:	80 91 21 04 	lds	r24, 0x0421
    3f52:	28 2f       	mov	r18, r24
    3f54:	30 e0       	ldi	r19, 0x00	; 0
    3f56:	c9 01       	movw	r24, r18
    3f58:	88 0f       	add	r24, r24
    3f5a:	99 1f       	adc	r25, r25
    3f5c:	88 0f       	add	r24, r24
    3f5e:	99 1f       	adc	r25, r25
    3f60:	88 0f       	add	r24, r24
    3f62:	99 1f       	adc	r25, r25
    3f64:	82 0f       	add	r24, r18
    3f66:	93 1f       	adc	r25, r19
    3f68:	88 5d       	subi	r24, 0xD8	; 216
    3f6a:	9b 4f       	sbci	r25, 0xFB	; 251
    3f6c:	9a 83       	std	Y+2, r25	; 0x02
    3f6e:	89 83       	std	Y+1, r24	; 0x01
    3f70:	e9 81       	ldd	r30, Y+1	; 0x01
    3f72:	fa 81       	ldd	r31, Y+2	; 0x02
    3f74:	01 80       	ldd	r0, Z+1	; 0x01
    3f76:	f2 81       	ldd	r31, Z+2	; 0x02
    3f78:	e0 2d       	mov	r30, r0
    3f7a:	82 81       	ldd	r24, Z+2	; 0x02
    3f7c:	93 81       	ldd	r25, Z+3	; 0x03
    3f7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f80:	fa 81       	ldd	r31, Y+2	; 0x02
    3f82:	92 83       	std	Z+2, r25	; 0x02
    3f84:	81 83       	std	Z+1, r24	; 0x01
    3f86:	e9 81       	ldd	r30, Y+1	; 0x01
    3f88:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8a:	21 81       	ldd	r18, Z+1	; 0x01
    3f8c:	32 81       	ldd	r19, Z+2	; 0x02
    3f8e:	89 81       	ldd	r24, Y+1	; 0x01
    3f90:	9a 81       	ldd	r25, Y+2	; 0x02
    3f92:	03 96       	adiw	r24, 0x03	; 3
    3f94:	28 17       	cp	r18, r24
    3f96:	39 07       	cpc	r19, r25
    3f98:	59 f4       	brne	.+22     	; 0x3fb0 <vTaskSwitchContext+0xac>
    3f9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9e:	01 80       	ldd	r0, Z+1	; 0x01
    3fa0:	f2 81       	ldd	r31, Z+2	; 0x02
    3fa2:	e0 2d       	mov	r30, r0
    3fa4:	82 81       	ldd	r24, Z+2	; 0x02
    3fa6:	93 81       	ldd	r25, Z+3	; 0x03
    3fa8:	e9 81       	ldd	r30, Y+1	; 0x01
    3faa:	fa 81       	ldd	r31, Y+2	; 0x02
    3fac:	92 83       	std	Z+2, r25	; 0x02
    3fae:	81 83       	std	Z+1, r24	; 0x01
    3fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb4:	01 80       	ldd	r0, Z+1	; 0x01
    3fb6:	f2 81       	ldd	r31, Z+2	; 0x02
    3fb8:	e0 2d       	mov	r30, r0
    3fba:	86 81       	ldd	r24, Z+6	; 0x06
    3fbc:	97 81       	ldd	r25, Z+7	; 0x07
    3fbe:	90 93 1b 04 	sts	0x041B, r25
    3fc2:	80 93 1a 04 	sts	0x041A, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3fc6:	0f 90       	pop	r0
    3fc8:	0f 90       	pop	r0
    3fca:	cf 91       	pop	r28
    3fcc:	df 91       	pop	r29
    3fce:	08 95       	ret

00003fd0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3fd0:	df 93       	push	r29
    3fd2:	cf 93       	push	r28
    3fd4:	00 d0       	rcall	.+0      	; 0x3fd6 <vTaskPlaceOnEventList+0x6>
    3fd6:	00 d0       	rcall	.+0      	; 0x3fd8 <vTaskPlaceOnEventList+0x8>
    3fd8:	00 d0       	rcall	.+0      	; 0x3fda <vTaskPlaceOnEventList+0xa>
    3fda:	cd b7       	in	r28, 0x3d	; 61
    3fdc:	de b7       	in	r29, 0x3e	; 62
    3fde:	9c 83       	std	Y+4, r25	; 0x04
    3fe0:	8b 83       	std	Y+3, r24	; 0x03
    3fe2:	7e 83       	std	Y+6, r23	; 0x06
    3fe4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3fe6:	4b 81       	ldd	r20, Y+3	; 0x03
    3fe8:	5c 81       	ldd	r21, Y+4	; 0x04
    3fea:	80 91 1a 04 	lds	r24, 0x041A
    3fee:	90 91 1b 04 	lds	r25, 0x041B
    3ff2:	9c 01       	movw	r18, r24
    3ff4:	24 5f       	subi	r18, 0xF4	; 244
    3ff6:	3f 4f       	sbci	r19, 0xFF	; 255
    3ff8:	ca 01       	movw	r24, r20
    3ffa:	b9 01       	movw	r22, r18
    3ffc:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4000:	80 91 1a 04 	lds	r24, 0x041A
    4004:	90 91 1b 04 	lds	r25, 0x041B
    4008:	02 96       	adiw	r24, 0x02	; 2
    400a:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    400e:	20 91 1e 04 	lds	r18, 0x041E
    4012:	30 91 1f 04 	lds	r19, 0x041F
    4016:	8d 81       	ldd	r24, Y+5	; 0x05
    4018:	9e 81       	ldd	r25, Y+6	; 0x06
    401a:	82 0f       	add	r24, r18
    401c:	93 1f       	adc	r25, r19
    401e:	9a 83       	std	Y+2, r25	; 0x02
    4020:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4022:	89 81       	ldd	r24, Y+1	; 0x01
    4024:	9a 81       	ldd	r25, Y+2	; 0x02
    4026:	0e 94 e2 21 	call	0x43c4	; 0x43c4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    402a:	26 96       	adiw	r28, 0x06	; 6
    402c:	0f b6       	in	r0, 0x3f	; 63
    402e:	f8 94       	cli
    4030:	de bf       	out	0x3e, r29	; 62
    4032:	0f be       	out	0x3f, r0	; 63
    4034:	cd bf       	out	0x3d, r28	; 61
    4036:	cf 91       	pop	r28
    4038:	df 91       	pop	r29
    403a:	08 95       	ret

0000403c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    403c:	df 93       	push	r29
    403e:	cf 93       	push	r28
    4040:	00 d0       	rcall	.+0      	; 0x4042 <xTaskRemoveFromEventList+0x6>
    4042:	00 d0       	rcall	.+0      	; 0x4044 <xTaskRemoveFromEventList+0x8>
    4044:	0f 92       	push	r0
    4046:	cd b7       	in	r28, 0x3d	; 61
    4048:	de b7       	in	r29, 0x3e	; 62
    404a:	9d 83       	std	Y+5, r25	; 0x05
    404c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    404e:	ec 81       	ldd	r30, Y+4	; 0x04
    4050:	fd 81       	ldd	r31, Y+5	; 0x05
    4052:	05 80       	ldd	r0, Z+5	; 0x05
    4054:	f6 81       	ldd	r31, Z+6	; 0x06
    4056:	e0 2d       	mov	r30, r0
    4058:	86 81       	ldd	r24, Z+6	; 0x06
    405a:	97 81       	ldd	r25, Z+7	; 0x07
    405c:	9b 83       	std	Y+3, r25	; 0x03
    405e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4060:	8a 81       	ldd	r24, Y+2	; 0x02
    4062:	9b 81       	ldd	r25, Y+3	; 0x03
    4064:	0c 96       	adiw	r24, 0x0c	; 12
    4066:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    406a:	80 91 23 04 	lds	r24, 0x0423
    406e:	88 23       	and	r24, r24
    4070:	61 f5       	brne	.+88     	; 0x40ca <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4072:	8a 81       	ldd	r24, Y+2	; 0x02
    4074:	9b 81       	ldd	r25, Y+3	; 0x03
    4076:	02 96       	adiw	r24, 0x02	; 2
    4078:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    407c:	ea 81       	ldd	r30, Y+2	; 0x02
    407e:	fb 81       	ldd	r31, Y+3	; 0x03
    4080:	96 89       	ldd	r25, Z+22	; 0x16
    4082:	80 91 21 04 	lds	r24, 0x0421
    4086:	89 17       	cp	r24, r25
    4088:	28 f4       	brcc	.+10     	; 0x4094 <xTaskRemoveFromEventList+0x58>
    408a:	ea 81       	ldd	r30, Y+2	; 0x02
    408c:	fb 81       	ldd	r31, Y+3	; 0x03
    408e:	86 89       	ldd	r24, Z+22	; 0x16
    4090:	80 93 21 04 	sts	0x0421, r24
    4094:	ea 81       	ldd	r30, Y+2	; 0x02
    4096:	fb 81       	ldd	r31, Y+3	; 0x03
    4098:	86 89       	ldd	r24, Z+22	; 0x16
    409a:	28 2f       	mov	r18, r24
    409c:	30 e0       	ldi	r19, 0x00	; 0
    409e:	c9 01       	movw	r24, r18
    40a0:	88 0f       	add	r24, r24
    40a2:	99 1f       	adc	r25, r25
    40a4:	88 0f       	add	r24, r24
    40a6:	99 1f       	adc	r25, r25
    40a8:	88 0f       	add	r24, r24
    40aa:	99 1f       	adc	r25, r25
    40ac:	82 0f       	add	r24, r18
    40ae:	93 1f       	adc	r25, r19
    40b0:	ac 01       	movw	r20, r24
    40b2:	48 5d       	subi	r20, 0xD8	; 216
    40b4:	5b 4f       	sbci	r21, 0xFB	; 251
    40b6:	8a 81       	ldd	r24, Y+2	; 0x02
    40b8:	9b 81       	ldd	r25, Y+3	; 0x03
    40ba:	9c 01       	movw	r18, r24
    40bc:	2e 5f       	subi	r18, 0xFE	; 254
    40be:	3f 4f       	sbci	r19, 0xFF	; 255
    40c0:	ca 01       	movw	r24, r20
    40c2:	b9 01       	movw	r22, r18
    40c4:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>
    40c8:	0a c0       	rjmp	.+20     	; 0x40de <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    40ca:	8a 81       	ldd	r24, Y+2	; 0x02
    40cc:	9b 81       	ldd	r25, Y+3	; 0x03
    40ce:	9c 01       	movw	r18, r24
    40d0:	24 5f       	subi	r18, 0xF4	; 244
    40d2:	3f 4f       	sbci	r19, 0xFF	; 255
    40d4:	8b e6       	ldi	r24, 0x6B	; 107
    40d6:	94 e0       	ldi	r25, 0x04	; 4
    40d8:	b9 01       	movw	r22, r18
    40da:	0e 94 b5 12 	call	0x256a	; 0x256a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    40de:	ea 81       	ldd	r30, Y+2	; 0x02
    40e0:	fb 81       	ldd	r31, Y+3	; 0x03
    40e2:	96 89       	ldd	r25, Z+22	; 0x16
    40e4:	e0 91 1a 04 	lds	r30, 0x041A
    40e8:	f0 91 1b 04 	lds	r31, 0x041B
    40ec:	86 89       	ldd	r24, Z+22	; 0x16
    40ee:	98 17       	cp	r25, r24
    40f0:	18 f0       	brcs	.+6      	; 0x40f8 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    40f2:	81 e0       	ldi	r24, 0x01	; 1
    40f4:	89 83       	std	Y+1, r24	; 0x01
    40f6:	01 c0       	rjmp	.+2      	; 0x40fa <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    40f8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    40fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    40fc:	0f 90       	pop	r0
    40fe:	0f 90       	pop	r0
    4100:	0f 90       	pop	r0
    4102:	0f 90       	pop	r0
    4104:	0f 90       	pop	r0
    4106:	cf 91       	pop	r28
    4108:	df 91       	pop	r29
    410a:	08 95       	ret

0000410c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    410c:	df 93       	push	r29
    410e:	cf 93       	push	r28
    4110:	00 d0       	rcall	.+0      	; 0x4112 <vTaskSetTimeOutState+0x6>
    4112:	cd b7       	in	r28, 0x3d	; 61
    4114:	de b7       	in	r29, 0x3e	; 62
    4116:	9a 83       	std	Y+2, r25	; 0x02
    4118:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    411a:	80 91 26 04 	lds	r24, 0x0426
    411e:	e9 81       	ldd	r30, Y+1	; 0x01
    4120:	fa 81       	ldd	r31, Y+2	; 0x02
    4122:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4124:	80 91 1e 04 	lds	r24, 0x041E
    4128:	90 91 1f 04 	lds	r25, 0x041F
    412c:	e9 81       	ldd	r30, Y+1	; 0x01
    412e:	fa 81       	ldd	r31, Y+2	; 0x02
    4130:	92 83       	std	Z+2, r25	; 0x02
    4132:	81 83       	std	Z+1, r24	; 0x01
}
    4134:	0f 90       	pop	r0
    4136:	0f 90       	pop	r0
    4138:	cf 91       	pop	r28
    413a:	df 91       	pop	r29
    413c:	08 95       	ret

0000413e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    413e:	df 93       	push	r29
    4140:	cf 93       	push	r28
    4142:	00 d0       	rcall	.+0      	; 0x4144 <xTaskCheckForTimeOut+0x6>
    4144:	00 d0       	rcall	.+0      	; 0x4146 <xTaskCheckForTimeOut+0x8>
    4146:	0f 92       	push	r0
    4148:	cd b7       	in	r28, 0x3d	; 61
    414a:	de b7       	in	r29, 0x3e	; 62
    414c:	9b 83       	std	Y+3, r25	; 0x03
    414e:	8a 83       	std	Y+2, r24	; 0x02
    4150:	7d 83       	std	Y+5, r23	; 0x05
    4152:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4154:	0f b6       	in	r0, 0x3f	; 63
    4156:	f8 94       	cli
    4158:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    415a:	ea 81       	ldd	r30, Y+2	; 0x02
    415c:	fb 81       	ldd	r31, Y+3	; 0x03
    415e:	90 81       	ld	r25, Z
    4160:	80 91 26 04 	lds	r24, 0x0426
    4164:	98 17       	cp	r25, r24
    4166:	71 f0       	breq	.+28     	; 0x4184 <xTaskCheckForTimeOut+0x46>
    4168:	ea 81       	ldd	r30, Y+2	; 0x02
    416a:	fb 81       	ldd	r31, Y+3	; 0x03
    416c:	21 81       	ldd	r18, Z+1	; 0x01
    416e:	32 81       	ldd	r19, Z+2	; 0x02
    4170:	80 91 1e 04 	lds	r24, 0x041E
    4174:	90 91 1f 04 	lds	r25, 0x041F
    4178:	82 17       	cp	r24, r18
    417a:	93 07       	cpc	r25, r19
    417c:	18 f0       	brcs	.+6      	; 0x4184 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    417e:	81 e0       	ldi	r24, 0x01	; 1
    4180:	89 83       	std	Y+1, r24	; 0x01
    4182:	2f c0       	rjmp	.+94     	; 0x41e2 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4184:	20 91 1e 04 	lds	r18, 0x041E
    4188:	30 91 1f 04 	lds	r19, 0x041F
    418c:	ea 81       	ldd	r30, Y+2	; 0x02
    418e:	fb 81       	ldd	r31, Y+3	; 0x03
    4190:	81 81       	ldd	r24, Z+1	; 0x01
    4192:	92 81       	ldd	r25, Z+2	; 0x02
    4194:	28 1b       	sub	r18, r24
    4196:	39 0b       	sbc	r19, r25
    4198:	ec 81       	ldd	r30, Y+4	; 0x04
    419a:	fd 81       	ldd	r31, Y+5	; 0x05
    419c:	80 81       	ld	r24, Z
    419e:	91 81       	ldd	r25, Z+1	; 0x01
    41a0:	28 17       	cp	r18, r24
    41a2:	39 07       	cpc	r19, r25
    41a4:	e0 f4       	brcc	.+56     	; 0x41de <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    41a6:	ec 81       	ldd	r30, Y+4	; 0x04
    41a8:	fd 81       	ldd	r31, Y+5	; 0x05
    41aa:	40 81       	ld	r20, Z
    41ac:	51 81       	ldd	r21, Z+1	; 0x01
    41ae:	ea 81       	ldd	r30, Y+2	; 0x02
    41b0:	fb 81       	ldd	r31, Y+3	; 0x03
    41b2:	21 81       	ldd	r18, Z+1	; 0x01
    41b4:	32 81       	ldd	r19, Z+2	; 0x02
    41b6:	80 91 1e 04 	lds	r24, 0x041E
    41ba:	90 91 1f 04 	lds	r25, 0x041F
    41be:	b9 01       	movw	r22, r18
    41c0:	68 1b       	sub	r22, r24
    41c2:	79 0b       	sbc	r23, r25
    41c4:	cb 01       	movw	r24, r22
    41c6:	84 0f       	add	r24, r20
    41c8:	95 1f       	adc	r25, r21
    41ca:	ec 81       	ldd	r30, Y+4	; 0x04
    41cc:	fd 81       	ldd	r31, Y+5	; 0x05
    41ce:	91 83       	std	Z+1, r25	; 0x01
    41d0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    41d2:	8a 81       	ldd	r24, Y+2	; 0x02
    41d4:	9b 81       	ldd	r25, Y+3	; 0x03
    41d6:	0e 94 86 20 	call	0x410c	; 0x410c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    41da:	19 82       	std	Y+1, r1	; 0x01
    41dc:	02 c0       	rjmp	.+4      	; 0x41e2 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    41de:	81 e0       	ldi	r24, 0x01	; 1
    41e0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    41e2:	0f 90       	pop	r0
    41e4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    41e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    41e8:	0f 90       	pop	r0
    41ea:	0f 90       	pop	r0
    41ec:	0f 90       	pop	r0
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	cf 91       	pop	r28
    41f4:	df 91       	pop	r29
    41f6:	08 95       	ret

000041f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    41f8:	df 93       	push	r29
    41fa:	cf 93       	push	r28
    41fc:	cd b7       	in	r28, 0x3d	; 61
    41fe:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4200:	81 e0       	ldi	r24, 0x01	; 1
    4202:	80 93 25 04 	sts	0x0425, r24
}
    4206:	cf 91       	pop	r28
    4208:	df 91       	pop	r29
    420a:	08 95       	ret

0000420c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    420c:	df 93       	push	r29
    420e:	cf 93       	push	r28
    4210:	00 d0       	rcall	.+0      	; 0x4212 <prvIdleTask+0x6>
    4212:	cd b7       	in	r28, 0x3d	; 61
    4214:	de b7       	in	r29, 0x3e	; 62
    4216:	9a 83       	std	Y+2, r25	; 0x02
    4218:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    421a:	0e 94 a4 21 	call	0x4348	; 0x4348 <prvCheckTasksWaitingTermination>
    421e:	fd cf       	rjmp	.-6      	; 0x421a <prvIdleTask+0xe>

00004220 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4220:	0f 93       	push	r16
    4222:	1f 93       	push	r17
    4224:	df 93       	push	r29
    4226:	cf 93       	push	r28
    4228:	cd b7       	in	r28, 0x3d	; 61
    422a:	de b7       	in	r29, 0x3e	; 62
    422c:	29 97       	sbiw	r28, 0x09	; 9
    422e:	0f b6       	in	r0, 0x3f	; 63
    4230:	f8 94       	cli
    4232:	de bf       	out	0x3e, r29	; 62
    4234:	0f be       	out	0x3f, r0	; 63
    4236:	cd bf       	out	0x3d, r28	; 61
    4238:	9a 83       	std	Y+2, r25	; 0x02
    423a:	89 83       	std	Y+1, r24	; 0x01
    423c:	7c 83       	std	Y+4, r23	; 0x04
    423e:	6b 83       	std	Y+3, r22	; 0x03
    4240:	4d 83       	std	Y+5, r20	; 0x05
    4242:	3f 83       	std	Y+7, r19	; 0x07
    4244:	2e 83       	std	Y+6, r18	; 0x06
    4246:	19 87       	std	Y+9, r17	; 0x09
    4248:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    424a:	89 81       	ldd	r24, Y+1	; 0x01
    424c:	9a 81       	ldd	r25, Y+2	; 0x02
    424e:	49 96       	adiw	r24, 0x19	; 25
    4250:	2b 81       	ldd	r18, Y+3	; 0x03
    4252:	3c 81       	ldd	r19, Y+4	; 0x04
    4254:	b9 01       	movw	r22, r18
    4256:	48 e0       	ldi	r20, 0x08	; 8
    4258:	50 e0       	ldi	r21, 0x00	; 0
    425a:	0e 94 ec 22 	call	0x45d8	; 0x45d8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    425e:	e9 81       	ldd	r30, Y+1	; 0x01
    4260:	fa 81       	ldd	r31, Y+2	; 0x02
    4262:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4264:	8d 81       	ldd	r24, Y+5	; 0x05
    4266:	85 30       	cpi	r24, 0x05	; 5
    4268:	10 f0       	brcs	.+4      	; 0x426e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    426a:	84 e0       	ldi	r24, 0x04	; 4
    426c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    426e:	e9 81       	ldd	r30, Y+1	; 0x01
    4270:	fa 81       	ldd	r31, Y+2	; 0x02
    4272:	8d 81       	ldd	r24, Y+5	; 0x05
    4274:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4276:	89 81       	ldd	r24, Y+1	; 0x01
    4278:	9a 81       	ldd	r25, Y+2	; 0x02
    427a:	02 96       	adiw	r24, 0x02	; 2
    427c:	0e 94 a5 12 	call	0x254a	; 0x254a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4280:	89 81       	ldd	r24, Y+1	; 0x01
    4282:	9a 81       	ldd	r25, Y+2	; 0x02
    4284:	0c 96       	adiw	r24, 0x0c	; 12
    4286:	0e 94 a5 12 	call	0x254a	; 0x254a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    428a:	e9 81       	ldd	r30, Y+1	; 0x01
    428c:	fa 81       	ldd	r31, Y+2	; 0x02
    428e:	89 81       	ldd	r24, Y+1	; 0x01
    4290:	9a 81       	ldd	r25, Y+2	; 0x02
    4292:	91 87       	std	Z+9, r25	; 0x09
    4294:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4296:	8d 81       	ldd	r24, Y+5	; 0x05
    4298:	28 2f       	mov	r18, r24
    429a:	30 e0       	ldi	r19, 0x00	; 0
    429c:	85 e0       	ldi	r24, 0x05	; 5
    429e:	90 e0       	ldi	r25, 0x00	; 0
    42a0:	82 1b       	sub	r24, r18
    42a2:	93 0b       	sbc	r25, r19
    42a4:	e9 81       	ldd	r30, Y+1	; 0x01
    42a6:	fa 81       	ldd	r31, Y+2	; 0x02
    42a8:	95 87       	std	Z+13, r25	; 0x0d
    42aa:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    42ac:	e9 81       	ldd	r30, Y+1	; 0x01
    42ae:	fa 81       	ldd	r31, Y+2	; 0x02
    42b0:	89 81       	ldd	r24, Y+1	; 0x01
    42b2:	9a 81       	ldd	r25, Y+2	; 0x02
    42b4:	93 8b       	std	Z+19, r25	; 0x13
    42b6:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    42b8:	29 96       	adiw	r28, 0x09	; 9
    42ba:	0f b6       	in	r0, 0x3f	; 63
    42bc:	f8 94       	cli
    42be:	de bf       	out	0x3e, r29	; 62
    42c0:	0f be       	out	0x3f, r0	; 63
    42c2:	cd bf       	out	0x3d, r28	; 61
    42c4:	cf 91       	pop	r28
    42c6:	df 91       	pop	r29
    42c8:	1f 91       	pop	r17
    42ca:	0f 91       	pop	r16
    42cc:	08 95       	ret

000042ce <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    42ce:	df 93       	push	r29
    42d0:	cf 93       	push	r28
    42d2:	0f 92       	push	r0
    42d4:	cd b7       	in	r28, 0x3d	; 61
    42d6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    42d8:	19 82       	std	Y+1, r1	; 0x01
    42da:	13 c0       	rjmp	.+38     	; 0x4302 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	28 2f       	mov	r18, r24
    42e0:	30 e0       	ldi	r19, 0x00	; 0
    42e2:	c9 01       	movw	r24, r18
    42e4:	88 0f       	add	r24, r24
    42e6:	99 1f       	adc	r25, r25
    42e8:	88 0f       	add	r24, r24
    42ea:	99 1f       	adc	r25, r25
    42ec:	88 0f       	add	r24, r24
    42ee:	99 1f       	adc	r25, r25
    42f0:	82 0f       	add	r24, r18
    42f2:	93 1f       	adc	r25, r19
    42f4:	88 5d       	subi	r24, 0xD8	; 216
    42f6:	9b 4f       	sbci	r25, 0xFB	; 251
    42f8:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    42fc:	89 81       	ldd	r24, Y+1	; 0x01
    42fe:	8f 5f       	subi	r24, 0xFF	; 255
    4300:	89 83       	std	Y+1, r24	; 0x01
    4302:	89 81       	ldd	r24, Y+1	; 0x01
    4304:	85 30       	cpi	r24, 0x05	; 5
    4306:	50 f3       	brcs	.-44     	; 0x42dc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4308:	85 e5       	ldi	r24, 0x55	; 85
    430a:	94 e0       	ldi	r25, 0x04	; 4
    430c:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4310:	8e e5       	ldi	r24, 0x5E	; 94
    4312:	94 e0       	ldi	r25, 0x04	; 4
    4314:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4318:	8b e6       	ldi	r24, 0x6B	; 107
    431a:	94 e0       	ldi	r25, 0x04	; 4
    431c:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4320:	84 e7       	ldi	r24, 0x74	; 116
    4322:	94 e0       	ldi	r25, 0x04	; 4
    4324:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4328:	85 e5       	ldi	r24, 0x55	; 85
    432a:	94 e0       	ldi	r25, 0x04	; 4
    432c:	90 93 68 04 	sts	0x0468, r25
    4330:	80 93 67 04 	sts	0x0467, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4334:	8e e5       	ldi	r24, 0x5E	; 94
    4336:	94 e0       	ldi	r25, 0x04	; 4
    4338:	90 93 6a 04 	sts	0x046A, r25
    433c:	80 93 69 04 	sts	0x0469, r24
}
    4340:	0f 90       	pop	r0
    4342:	cf 91       	pop	r28
    4344:	df 91       	pop	r29
    4346:	08 95       	ret

00004348 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4348:	df 93       	push	r29
    434a:	cf 93       	push	r28
    434c:	00 d0       	rcall	.+0      	; 0x434e <prvCheckTasksWaitingTermination+0x6>
    434e:	0f 92       	push	r0
    4350:	cd b7       	in	r28, 0x3d	; 61
    4352:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4354:	80 91 1c 04 	lds	r24, 0x041C
    4358:	88 23       	and	r24, r24
    435a:	71 f1       	breq	.+92     	; 0x43b8 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    435c:	0e 94 e2 1d 	call	0x3bc4	; 0x3bc4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4360:	80 91 74 04 	lds	r24, 0x0474
    4364:	1b 82       	std	Y+3, r1	; 0x03
    4366:	88 23       	and	r24, r24
    4368:	11 f4       	brne	.+4      	; 0x436e <prvCheckTasksWaitingTermination+0x26>
    436a:	81 e0       	ldi	r24, 0x01	; 1
    436c:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    436e:	0e 94 ee 1d 	call	0x3bdc	; 0x3bdc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4372:	8b 81       	ldd	r24, Y+3	; 0x03
    4374:	88 23       	and	r24, r24
    4376:	01 f5       	brne	.+64     	; 0x43b8 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4378:	0f b6       	in	r0, 0x3f	; 63
    437a:	f8 94       	cli
    437c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    437e:	e0 91 79 04 	lds	r30, 0x0479
    4382:	f0 91 7a 04 	lds	r31, 0x047A
    4386:	86 81       	ldd	r24, Z+6	; 0x06
    4388:	97 81       	ldd	r25, Z+7	; 0x07
    438a:	9a 83       	std	Y+2, r25	; 0x02
    438c:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    438e:	89 81       	ldd	r24, Y+1	; 0x01
    4390:	9a 81       	ldd	r25, Y+2	; 0x02
    4392:	02 96       	adiw	r24, 0x02	; 2
    4394:	0e 94 6d 13 	call	0x26da	; 0x26da <vListRemove>
					--uxCurrentNumberOfTasks;
    4398:	80 91 1d 04 	lds	r24, 0x041D
    439c:	81 50       	subi	r24, 0x01	; 1
    439e:	80 93 1d 04 	sts	0x041D, r24
					--uxTasksDeleted;
    43a2:	80 91 1c 04 	lds	r24, 0x041C
    43a6:	81 50       	subi	r24, 0x01	; 1
    43a8:	80 93 1c 04 	sts	0x041C, r24
				}
				taskEXIT_CRITICAL();
    43ac:	0f 90       	pop	r0
    43ae:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    43b0:	89 81       	ldd	r24, Y+1	; 0x01
    43b2:	9a 81       	ldd	r25, Y+2	; 0x02
    43b4:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    43b8:	0f 90       	pop	r0
    43ba:	0f 90       	pop	r0
    43bc:	0f 90       	pop	r0
    43be:	cf 91       	pop	r28
    43c0:	df 91       	pop	r29
    43c2:	08 95       	ret

000043c4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    43c4:	df 93       	push	r29
    43c6:	cf 93       	push	r28
    43c8:	00 d0       	rcall	.+0      	; 0x43ca <prvAddCurrentTaskToDelayedList+0x6>
    43ca:	cd b7       	in	r28, 0x3d	; 61
    43cc:	de b7       	in	r29, 0x3e	; 62
    43ce:	9a 83       	std	Y+2, r25	; 0x02
    43d0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    43d2:	e0 91 1a 04 	lds	r30, 0x041A
    43d6:	f0 91 1b 04 	lds	r31, 0x041B
    43da:	89 81       	ldd	r24, Y+1	; 0x01
    43dc:	9a 81       	ldd	r25, Y+2	; 0x02
    43de:	93 83       	std	Z+3, r25	; 0x03
    43e0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    43e2:	20 91 1e 04 	lds	r18, 0x041E
    43e6:	30 91 1f 04 	lds	r19, 0x041F
    43ea:	89 81       	ldd	r24, Y+1	; 0x01
    43ec:	9a 81       	ldd	r25, Y+2	; 0x02
    43ee:	82 17       	cp	r24, r18
    43f0:	93 07       	cpc	r25, r19
    43f2:	70 f4       	brcc	.+28     	; 0x4410 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    43f4:	80 91 69 04 	lds	r24, 0x0469
    43f8:	90 91 6a 04 	lds	r25, 0x046A
    43fc:	20 91 1a 04 	lds	r18, 0x041A
    4400:	30 91 1b 04 	lds	r19, 0x041B
    4404:	2e 5f       	subi	r18, 0xFE	; 254
    4406:	3f 4f       	sbci	r19, 0xFF	; 255
    4408:	b9 01       	movw	r22, r18
    440a:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>
    440e:	1e c0       	rjmp	.+60     	; 0x444c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4410:	40 91 67 04 	lds	r20, 0x0467
    4414:	50 91 68 04 	lds	r21, 0x0468
    4418:	80 91 1a 04 	lds	r24, 0x041A
    441c:	90 91 1b 04 	lds	r25, 0x041B
    4420:	9c 01       	movw	r18, r24
    4422:	2e 5f       	subi	r18, 0xFE	; 254
    4424:	3f 4f       	sbci	r19, 0xFF	; 255
    4426:	ca 01       	movw	r24, r20
    4428:	b9 01       	movw	r22, r18
    442a:	0e 94 01 13 	call	0x2602	; 0x2602 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    442e:	20 91 81 01 	lds	r18, 0x0181
    4432:	30 91 82 01 	lds	r19, 0x0182
    4436:	89 81       	ldd	r24, Y+1	; 0x01
    4438:	9a 81       	ldd	r25, Y+2	; 0x02
    443a:	82 17       	cp	r24, r18
    443c:	93 07       	cpc	r25, r19
    443e:	30 f4       	brcc	.+12     	; 0x444c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4440:	89 81       	ldd	r24, Y+1	; 0x01
    4442:	9a 81       	ldd	r25, Y+2	; 0x02
    4444:	90 93 82 01 	sts	0x0182, r25
    4448:	80 93 81 01 	sts	0x0181, r24
		}
	}
}
    444c:	0f 90       	pop	r0
    444e:	0f 90       	pop	r0
    4450:	cf 91       	pop	r28
    4452:	df 91       	pop	r29
    4454:	08 95       	ret

00004456 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4456:	df 93       	push	r29
    4458:	cf 93       	push	r28
    445a:	cd b7       	in	r28, 0x3d	; 61
    445c:	de b7       	in	r29, 0x3e	; 62
    445e:	28 97       	sbiw	r28, 0x08	; 8
    4460:	0f b6       	in	r0, 0x3f	; 63
    4462:	f8 94       	cli
    4464:	de bf       	out	0x3e, r29	; 62
    4466:	0f be       	out	0x3f, r0	; 63
    4468:	cd bf       	out	0x3d, r28	; 61
    446a:	9c 83       	std	Y+4, r25	; 0x04
    446c:	8b 83       	std	Y+3, r24	; 0x03
    446e:	7e 83       	std	Y+6, r23	; 0x06
    4470:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4472:	81 e2       	ldi	r24, 0x21	; 33
    4474:	90 e0       	ldi	r25, 0x00	; 0
    4476:	0e 94 0f 12 	call	0x241e	; 0x241e <pvPortMalloc>
    447a:	9a 83       	std	Y+2, r25	; 0x02
    447c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    447e:	89 81       	ldd	r24, Y+1	; 0x01
    4480:	9a 81       	ldd	r25, Y+2	; 0x02
    4482:	00 97       	sbiw	r24, 0x00	; 0
    4484:	69 f1       	breq	.+90     	; 0x44e0 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4486:	8d 81       	ldd	r24, Y+5	; 0x05
    4488:	9e 81       	ldd	r25, Y+6	; 0x06
    448a:	00 97       	sbiw	r24, 0x00	; 0
    448c:	39 f4       	brne	.+14     	; 0x449c <prvAllocateTCBAndStack+0x46>
    448e:	8b 81       	ldd	r24, Y+3	; 0x03
    4490:	9c 81       	ldd	r25, Y+4	; 0x04
    4492:	0e 94 0f 12 	call	0x241e	; 0x241e <pvPortMalloc>
    4496:	98 87       	std	Y+8, r25	; 0x08
    4498:	8f 83       	std	Y+7, r24	; 0x07
    449a:	04 c0       	rjmp	.+8      	; 0x44a4 <prvAllocateTCBAndStack+0x4e>
    449c:	8d 81       	ldd	r24, Y+5	; 0x05
    449e:	9e 81       	ldd	r25, Y+6	; 0x06
    44a0:	98 87       	std	Y+8, r25	; 0x08
    44a2:	8f 83       	std	Y+7, r24	; 0x07
    44a4:	e9 81       	ldd	r30, Y+1	; 0x01
    44a6:	fa 81       	ldd	r31, Y+2	; 0x02
    44a8:	8f 81       	ldd	r24, Y+7	; 0x07
    44aa:	98 85       	ldd	r25, Y+8	; 0x08
    44ac:	90 8f       	std	Z+24, r25	; 0x18
    44ae:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    44b0:	e9 81       	ldd	r30, Y+1	; 0x01
    44b2:	fa 81       	ldd	r31, Y+2	; 0x02
    44b4:	87 89       	ldd	r24, Z+23	; 0x17
    44b6:	90 8d       	ldd	r25, Z+24	; 0x18
    44b8:	00 97       	sbiw	r24, 0x00	; 0
    44ba:	39 f4       	brne	.+14     	; 0x44ca <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    44bc:	89 81       	ldd	r24, Y+1	; 0x01
    44be:	9a 81       	ldd	r25, Y+2	; 0x02
    44c0:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
			pxNewTCB = NULL;
    44c4:	1a 82       	std	Y+2, r1	; 0x02
    44c6:	19 82       	std	Y+1, r1	; 0x01
    44c8:	0b c0       	rjmp	.+22     	; 0x44e0 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    44ca:	e9 81       	ldd	r30, Y+1	; 0x01
    44cc:	fa 81       	ldd	r31, Y+2	; 0x02
    44ce:	87 89       	ldd	r24, Z+23	; 0x17
    44d0:	90 8d       	ldd	r25, Z+24	; 0x18
    44d2:	2b 81       	ldd	r18, Y+3	; 0x03
    44d4:	3c 81       	ldd	r19, Y+4	; 0x04
    44d6:	65 ea       	ldi	r22, 0xA5	; 165
    44d8:	70 e0       	ldi	r23, 0x00	; 0
    44da:	a9 01       	movw	r20, r18
    44dc:	0e 94 e5 22 	call	0x45ca	; 0x45ca <memset>
		}
	}

	return pxNewTCB;
    44e0:	89 81       	ldd	r24, Y+1	; 0x01
    44e2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    44e4:	28 96       	adiw	r28, 0x08	; 8
    44e6:	0f b6       	in	r0, 0x3f	; 63
    44e8:	f8 94       	cli
    44ea:	de bf       	out	0x3e, r29	; 62
    44ec:	0f be       	out	0x3f, r0	; 63
    44ee:	cd bf       	out	0x3d, r28	; 61
    44f0:	cf 91       	pop	r28
    44f2:	df 91       	pop	r29
    44f4:	08 95       	ret

000044f6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    44f6:	df 93       	push	r29
    44f8:	cf 93       	push	r28
    44fa:	00 d0       	rcall	.+0      	; 0x44fc <prvDeleteTCB+0x6>
    44fc:	cd b7       	in	r28, 0x3d	; 61
    44fe:	de b7       	in	r29, 0x3e	; 62
    4500:	9a 83       	std	Y+2, r25	; 0x02
    4502:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4504:	e9 81       	ldd	r30, Y+1	; 0x01
    4506:	fa 81       	ldd	r31, Y+2	; 0x02
    4508:	87 89       	ldd	r24, Z+23	; 0x17
    450a:	90 8d       	ldd	r25, Z+24	; 0x18
    450c:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
		vPortFree( pxTCB );
    4510:	89 81       	ldd	r24, Y+1	; 0x01
    4512:	9a 81       	ldd	r25, Y+2	; 0x02
    4514:	0e 94 55 12 	call	0x24aa	; 0x24aa <vPortFree>
	}
    4518:	0f 90       	pop	r0
    451a:	0f 90       	pop	r0
    451c:	cf 91       	pop	r28
    451e:	df 91       	pop	r29
    4520:	08 95       	ret

00004522 <__udivmodhi4>:
    4522:	aa 1b       	sub	r26, r26
    4524:	bb 1b       	sub	r27, r27
    4526:	51 e1       	ldi	r21, 0x11	; 17
    4528:	07 c0       	rjmp	.+14     	; 0x4538 <__udivmodhi4_ep>

0000452a <__udivmodhi4_loop>:
    452a:	aa 1f       	adc	r26, r26
    452c:	bb 1f       	adc	r27, r27
    452e:	a6 17       	cp	r26, r22
    4530:	b7 07       	cpc	r27, r23
    4532:	10 f0       	brcs	.+4      	; 0x4538 <__udivmodhi4_ep>
    4534:	a6 1b       	sub	r26, r22
    4536:	b7 0b       	sbc	r27, r23

00004538 <__udivmodhi4_ep>:
    4538:	88 1f       	adc	r24, r24
    453a:	99 1f       	adc	r25, r25
    453c:	5a 95       	dec	r21
    453e:	a9 f7       	brne	.-22     	; 0x452a <__udivmodhi4_loop>
    4540:	80 95       	com	r24
    4542:	90 95       	com	r25
    4544:	bc 01       	movw	r22, r24
    4546:	cd 01       	movw	r24, r26
    4548:	08 95       	ret

0000454a <__prologue_saves__>:
    454a:	2f 92       	push	r2
    454c:	3f 92       	push	r3
    454e:	4f 92       	push	r4
    4550:	5f 92       	push	r5
    4552:	6f 92       	push	r6
    4554:	7f 92       	push	r7
    4556:	8f 92       	push	r8
    4558:	9f 92       	push	r9
    455a:	af 92       	push	r10
    455c:	bf 92       	push	r11
    455e:	cf 92       	push	r12
    4560:	df 92       	push	r13
    4562:	ef 92       	push	r14
    4564:	ff 92       	push	r15
    4566:	0f 93       	push	r16
    4568:	1f 93       	push	r17
    456a:	cf 93       	push	r28
    456c:	df 93       	push	r29
    456e:	cd b7       	in	r28, 0x3d	; 61
    4570:	de b7       	in	r29, 0x3e	; 62
    4572:	ca 1b       	sub	r28, r26
    4574:	db 0b       	sbc	r29, r27
    4576:	0f b6       	in	r0, 0x3f	; 63
    4578:	f8 94       	cli
    457a:	de bf       	out	0x3e, r29	; 62
    457c:	0f be       	out	0x3f, r0	; 63
    457e:	cd bf       	out	0x3d, r28	; 61
    4580:	09 94       	ijmp

00004582 <__epilogue_restores__>:
    4582:	2a 88       	ldd	r2, Y+18	; 0x12
    4584:	39 88       	ldd	r3, Y+17	; 0x11
    4586:	48 88       	ldd	r4, Y+16	; 0x10
    4588:	5f 84       	ldd	r5, Y+15	; 0x0f
    458a:	6e 84       	ldd	r6, Y+14	; 0x0e
    458c:	7d 84       	ldd	r7, Y+13	; 0x0d
    458e:	8c 84       	ldd	r8, Y+12	; 0x0c
    4590:	9b 84       	ldd	r9, Y+11	; 0x0b
    4592:	aa 84       	ldd	r10, Y+10	; 0x0a
    4594:	b9 84       	ldd	r11, Y+9	; 0x09
    4596:	c8 84       	ldd	r12, Y+8	; 0x08
    4598:	df 80       	ldd	r13, Y+7	; 0x07
    459a:	ee 80       	ldd	r14, Y+6	; 0x06
    459c:	fd 80       	ldd	r15, Y+5	; 0x05
    459e:	0c 81       	ldd	r16, Y+4	; 0x04
    45a0:	1b 81       	ldd	r17, Y+3	; 0x03
    45a2:	aa 81       	ldd	r26, Y+2	; 0x02
    45a4:	b9 81       	ldd	r27, Y+1	; 0x01
    45a6:	ce 0f       	add	r28, r30
    45a8:	d1 1d       	adc	r29, r1
    45aa:	0f b6       	in	r0, 0x3f	; 63
    45ac:	f8 94       	cli
    45ae:	de bf       	out	0x3e, r29	; 62
    45b0:	0f be       	out	0x3f, r0	; 63
    45b2:	cd bf       	out	0x3d, r28	; 61
    45b4:	ed 01       	movw	r28, r26
    45b6:	08 95       	ret

000045b8 <memcpy>:
    45b8:	fb 01       	movw	r30, r22
    45ba:	dc 01       	movw	r26, r24
    45bc:	02 c0       	rjmp	.+4      	; 0x45c2 <memcpy+0xa>
    45be:	01 90       	ld	r0, Z+
    45c0:	0d 92       	st	X+, r0
    45c2:	41 50       	subi	r20, 0x01	; 1
    45c4:	50 40       	sbci	r21, 0x00	; 0
    45c6:	d8 f7       	brcc	.-10     	; 0x45be <memcpy+0x6>
    45c8:	08 95       	ret

000045ca <memset>:
    45ca:	dc 01       	movw	r26, r24
    45cc:	01 c0       	rjmp	.+2      	; 0x45d0 <memset+0x6>
    45ce:	6d 93       	st	X+, r22
    45d0:	41 50       	subi	r20, 0x01	; 1
    45d2:	50 40       	sbci	r21, 0x00	; 0
    45d4:	e0 f7       	brcc	.-8      	; 0x45ce <memset+0x4>
    45d6:	08 95       	ret

000045d8 <strncpy>:
    45d8:	fb 01       	movw	r30, r22
    45da:	dc 01       	movw	r26, r24
    45dc:	41 50       	subi	r20, 0x01	; 1
    45de:	50 40       	sbci	r21, 0x00	; 0
    45e0:	48 f0       	brcs	.+18     	; 0x45f4 <strncpy+0x1c>
    45e2:	01 90       	ld	r0, Z+
    45e4:	0d 92       	st	X+, r0
    45e6:	00 20       	and	r0, r0
    45e8:	c9 f7       	brne	.-14     	; 0x45dc <strncpy+0x4>
    45ea:	01 c0       	rjmp	.+2      	; 0x45ee <strncpy+0x16>
    45ec:	1d 92       	st	X+, r1
    45ee:	41 50       	subi	r20, 0x01	; 1
    45f0:	50 40       	sbci	r21, 0x00	; 0
    45f2:	e0 f7       	brcc	.-8      	; 0x45ec <strncpy+0x14>
    45f4:	08 95       	ret

000045f6 <_exit>:
    45f6:	f8 94       	cli

000045f8 <__stop_program>:
    45f8:	ff cf       	rjmp	.-2      	; 0x45f8 <__stop_program>
